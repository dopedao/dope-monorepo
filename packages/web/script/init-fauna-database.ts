import { getRarityForDopeId } from '../src/dope-rarity-check';
import * as dotenv from 'dotenv';
import DopeJson from 'dope-metrics/output/loot.json';
import faunadb from 'faunadb';
import fetch from 'isomorphic-fetch';
import fs from 'fs';

dotenv.config({ path: __dirname + '/../../../.env' });

const FAUNA_KEY = process.env.FAUNA_KEY ?? '';

// https://docs.fauna.com/fauna/current/drivers/javascript
// https://fauna.github.io/faunadb-js/
const client = new faunadb.Client({
  secret: FAUNA_KEY,
  domain: 'db.us.fauna.com',
  port: 443,
  scheme: 'https',
});

const q = faunadb.query;

// Fauna only provides a way to load GraphQL schema through this endpoint
// https://docs.fauna.com/fauna/current/api/graphql/endpoints?lang=javascript
// https://forums.fauna.com/t/importing-graphql-schema-from-js-file/642/3
const initFromGraphQL = async () => {
  try {
    console.log('Initializing Collections from GraphQL schema');
    const schema = fs.readFileSync(
      __dirname + '/../fauna/dope_token_schema.graphql', 
      'utf8'
    );
    // Override deletes documents and replaces schema in place
    // https://docs.fauna.com/fauna/current/api/graphql/endpoints?lang=javascript
    const url = 'https://graphql.us.fauna.com/import?mode=override';
    const response = await fetch(url, {
      method: 'POST', 
      headers: {
        'Authorization': `Bearer ${FAUNA_KEY}`
      },
      body: schema
    });
    // console.log(response);
    // const result = await response.text();
    // console.log(result);
  } catch (err) {
    console.error(err)
  }
};

// Returns data structures that should map to the GraphQL schema for DopeToken
// as defined in dope_token_schema.graphql
const buildTokenObjects = () => {
  console.log('Building token objects');
  const lootJsonEntries = Object.entries(DopeJson);
  const tokens = [];
  for (let i = 0; i < lootJsonEntries.length; i++) {
    const dopeAsset = lootJsonEntries[i][1];
    const tokenId = Object.keys(dopeAsset)[0];
    const itemValues = Object.values(dopeAsset)[0];
    // Merge items we have with smart defaults we can update later.
    // Default claimed / unbundled to worst possible status
    // and update from The Graph later.
    const tokenDocument = Object.assign(
      {
        token_id: tokenId,
        claimed: true,
        unbundled: true,
        rank: getRarityForDopeId(tokenId)
      }, 
      itemValues
    );
    // Adding tokenId to nested array allows us to use it as 
    // the Fauna "ref" instead of an autogenerated one they create.
    tokens.push([tokenId, tokenDocument]);
  }
  return tokens;
}

const populate = async(tokens: any[]) => {
  console.log(`Populating ${tokens.length} DOPE tokens`)
  try {
    const response = await client.query(
      q.Map(
        tokens, 
        q.Lambda(
          ['token_id', 'data'], 
          q.Create(
            q.Ref(q.Collection('DopeToken'), q.Var('token_id')),
            { data: q.Var('data') }
          )
        )
      )
    );
    console.log(response);
  } catch (error) {
    console.error('Error: %s', error);
  }
};

(async () => {
  //await initFromGraphQL();
  const tokens = buildTokenObjects();
  await populate(tokens);
})();
