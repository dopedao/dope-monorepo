import { useQuery, UseQueryOptions, useInfiniteQuery, UseInfiniteQueryOptions, QueryFunctionContext } from 'react-query';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };

function fetcher<TData, TVariables>(query: string, variables?: TVariables) {
  return async (): Promise<TData> => {
    const res = await fetch(process.env.DOPEWARS_API as string, {
    method: "POST",
    ...({"headers":{"Content-Type":"application/json"}}),
      body: JSON.stringify({ query, variables }),
    });

    const json = await res.json();

    if (json.errors) {
      const { message } = json.errors[0];

      throw new Error(message);
    }

    return json.data;
  }
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** Address is a 20 byte Ethereum address, represented as 0x-prefixed hexadecimal. */
  Address: any;
  /** BigInt is a large integer represented as a string. */
  BigInt: any;
  /**
   * Bytes is an arbitrary length binary string, represented as 0x-prefixed hexadecimal.
   * An empty byte string is represented as '0x'. Byte strings must have an even number of hexadecimal nybbles.
   */
  Bytes: any;
  /** Bytes32 is a 32 byte binary string, represented as 0x-prefixed hexadecimal. */
  Bytes32: any;
  Cursor: any;
  /** Long is a 64 bit unsigned integer. */
  Long: any;
  /** Maps a Time GraphQL scalar to a Go time.Time struct. */
  Time: any;
  /** Timestamp is a RFC3339 string. */
  Timestamp: any;
};

export type BodyPart = Node & {
  __typename?: 'BodyPart';
  id: Scalars['ID'];
  rle: Scalars['String'];
  sex: BodyPartSex;
  type: BodyPartType;
};

export enum BodyPartSex {
  Female = 'FEMALE',
  Male = 'MALE'
}

export enum BodyPartType {
  Beard = 'BEARD',
  Body = 'BODY',
  Hair = 'HAIR'
}

/**
 * BodyPartWhereInput is used for filtering BodyPart objects.
 * Input was generated by ent.
 */
export type BodyPartWhereInput = {
  and?: InputMaybe<Array<BodyPartWhereInput>>;
  /** hustler_beards edge predicates */
  hasHustlerBeards?: InputMaybe<Scalars['Boolean']>;
  hasHustlerBeardsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_bodies edge predicates */
  hasHustlerBodies?: InputMaybe<Scalars['Boolean']>;
  hasHustlerBodiesWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_hairs edge predicates */
  hasHustlerHairs?: InputMaybe<Scalars['Boolean']>;
  hasHustlerHairsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<BodyPartWhereInput>;
  or?: InputMaybe<Array<BodyPartWhereInput>>;
  /** rle field predicates */
  rle?: InputMaybe<Scalars['String']>;
  rleContains?: InputMaybe<Scalars['String']>;
  rleContainsFold?: InputMaybe<Scalars['String']>;
  rleEqualFold?: InputMaybe<Scalars['String']>;
  rleGT?: InputMaybe<Scalars['String']>;
  rleGTE?: InputMaybe<Scalars['String']>;
  rleHasPrefix?: InputMaybe<Scalars['String']>;
  rleHasSuffix?: InputMaybe<Scalars['String']>;
  rleIn?: InputMaybe<Array<Scalars['String']>>;
  rleLT?: InputMaybe<Scalars['String']>;
  rleLTE?: InputMaybe<Scalars['String']>;
  rleNEQ?: InputMaybe<Scalars['String']>;
  rleNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** sex field predicates */
  sex?: InputMaybe<BodyPartSex>;
  sexIn?: InputMaybe<Array<BodyPartSex>>;
  sexNEQ?: InputMaybe<BodyPartSex>;
  sexNotIn?: InputMaybe<Array<BodyPartSex>>;
  /** type field predicates */
  type?: InputMaybe<BodyPartType>;
  typeIn?: InputMaybe<Array<BodyPartType>>;
  typeNEQ?: InputMaybe<BodyPartType>;
  typeNotIn?: InputMaybe<Array<BodyPartType>>;
};

export type Dope = Node & {
  __typename?: 'Dope';
  claimed: Scalars['Boolean'];
  id: Scalars['ID'];
  items: Array<Item>;
  opened: Scalars['Boolean'];
  rank: Scalars['Int'];
  score: Scalars['Int'];
};

export type DopeConnection = {
  __typename?: 'DopeConnection';
  edges?: Maybe<Array<Maybe<DopeEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type DopeEdge = {
  __typename?: 'DopeEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Dope>;
};

export type DopeOrder = {
  direction: OrderDirection;
  field?: InputMaybe<DopeOrderField>;
};

export enum DopeOrderField {
  Id = 'ID',
  Rank = 'RANK'
}

/**
 * DopeWhereInput is used for filtering Dope objects.
 * Input was generated by ent.
 */
export type DopeWhereInput = {
  and?: InputMaybe<Array<DopeWhereInput>>;
  /** claimed field predicates */
  claimed?: InputMaybe<Scalars['Boolean']>;
  claimedNEQ?: InputMaybe<Scalars['Boolean']>;
  /** items edge predicates */
  hasItems?: InputMaybe<Scalars['Boolean']>;
  hasItemsWith?: InputMaybe<Array<ItemWhereInput>>;
  /** wallet edge predicates */
  hasWallet?: InputMaybe<Scalars['Boolean']>;
  hasWalletWith?: InputMaybe<Array<WalletWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<DopeWhereInput>;
  /** opened field predicates */
  opened?: InputMaybe<Scalars['Boolean']>;
  openedNEQ?: InputMaybe<Scalars['Boolean']>;
  or?: InputMaybe<Array<DopeWhereInput>>;
  /** order field predicates */
  order?: InputMaybe<Scalars['Int']>;
  orderGT?: InputMaybe<Scalars['Int']>;
  orderGTE?: InputMaybe<Scalars['Int']>;
  orderIn?: InputMaybe<Array<Scalars['Int']>>;
  orderLT?: InputMaybe<Scalars['Int']>;
  orderLTE?: InputMaybe<Scalars['Int']>;
  orderNEQ?: InputMaybe<Scalars['Int']>;
  orderNotIn?: InputMaybe<Array<Scalars['Int']>>;
  /** rank field predicates */
  rank?: InputMaybe<Scalars['Int']>;
  rankGT?: InputMaybe<Scalars['Int']>;
  rankGTE?: InputMaybe<Scalars['Int']>;
  rankIn?: InputMaybe<Array<Scalars['Int']>>;
  rankIsNil?: InputMaybe<Scalars['Boolean']>;
  rankLT?: InputMaybe<Scalars['Int']>;
  rankLTE?: InputMaybe<Scalars['Int']>;
  rankNEQ?: InputMaybe<Scalars['Int']>;
  rankNotIn?: InputMaybe<Array<Scalars['Int']>>;
  rankNotNil?: InputMaybe<Scalars['Boolean']>;
  /** score field predicates */
  score?: InputMaybe<Scalars['Int']>;
  scoreGT?: InputMaybe<Scalars['Int']>;
  scoreGTE?: InputMaybe<Scalars['Int']>;
  scoreIn?: InputMaybe<Array<Scalars['Int']>>;
  scoreIsNil?: InputMaybe<Scalars['Boolean']>;
  scoreLT?: InputMaybe<Scalars['Int']>;
  scoreLTE?: InputMaybe<Scalars['Int']>;
  scoreNEQ?: InputMaybe<Scalars['Int']>;
  scoreNotIn?: InputMaybe<Array<Scalars['Int']>>;
  scoreNotNil?: InputMaybe<Scalars['Boolean']>;
};

/**
 * EventWhereInput is used for filtering Event objects.
 * Input was generated by ent.
 */
export type EventWhereInput = {
  and?: InputMaybe<Array<EventWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** index field predicates */
  index?: InputMaybe<Scalars['Long']>;
  indexGT?: InputMaybe<Scalars['Long']>;
  indexGTE?: InputMaybe<Scalars['Long']>;
  indexIn?: InputMaybe<Array<Scalars['Long']>>;
  indexLT?: InputMaybe<Scalars['Long']>;
  indexLTE?: InputMaybe<Scalars['Long']>;
  indexNEQ?: InputMaybe<Scalars['Long']>;
  indexNotIn?: InputMaybe<Array<Scalars['Long']>>;
  not?: InputMaybe<EventWhereInput>;
  or?: InputMaybe<Array<EventWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Hustler = Node & {
  __typename?: 'Hustler';
  accessory?: Maybe<Item>;
  age: Scalars['Long'];
  background?: Maybe<Scalars['String']>;
  beard?: Maybe<BodyPart>;
  body?: Maybe<BodyPart>;
  clothes?: Maybe<Item>;
  color?: Maybe<Scalars['String']>;
  drug?: Maybe<Item>;
  foot?: Maybe<Item>;
  hair?: Maybe<BodyPart>;
  hand?: Maybe<Item>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  neck?: Maybe<Item>;
  order: Array<Scalars['Int']>;
  ring?: Maybe<Item>;
  sex: HustlerSex;
  svg?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  type: HustlerType;
  vehicle?: Maybe<Item>;
  viewbox: Array<Scalars['Int']>;
  waist?: Maybe<Item>;
  weapon?: Maybe<Item>;
};

export type HustlerConnection = {
  __typename?: 'HustlerConnection';
  edges?: Maybe<Array<Maybe<HustlerEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type HustlerEdge = {
  __typename?: 'HustlerEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Hustler>;
};

export type HustlerOrder = {
  direction: OrderDirection;
};

export enum HustlerSex {
  Female = 'FEMALE',
  Male = 'MALE'
}

export enum HustlerType {
  OriginalGangsta = 'ORIGINAL_GANGSTA',
  Regular = 'REGULAR'
}

/**
 * HustlerWhereInput is used for filtering Hustler objects.
 * Input was generated by ent.
 */
export type HustlerWhereInput = {
  /** age field predicates */
  age?: InputMaybe<Scalars['Long']>;
  ageGT?: InputMaybe<Scalars['Long']>;
  ageGTE?: InputMaybe<Scalars['Long']>;
  ageIn?: InputMaybe<Array<Scalars['Long']>>;
  ageLT?: InputMaybe<Scalars['Long']>;
  ageLTE?: InputMaybe<Scalars['Long']>;
  ageNEQ?: InputMaybe<Scalars['Long']>;
  ageNotIn?: InputMaybe<Array<Scalars['Long']>>;
  and?: InputMaybe<Array<HustlerWhereInput>>;
  /** background field predicates */
  background?: InputMaybe<Scalars['String']>;
  backgroundContains?: InputMaybe<Scalars['String']>;
  backgroundContainsFold?: InputMaybe<Scalars['String']>;
  backgroundEqualFold?: InputMaybe<Scalars['String']>;
  backgroundGT?: InputMaybe<Scalars['String']>;
  backgroundGTE?: InputMaybe<Scalars['String']>;
  backgroundHasPrefix?: InputMaybe<Scalars['String']>;
  backgroundHasSuffix?: InputMaybe<Scalars['String']>;
  backgroundIn?: InputMaybe<Array<Scalars['String']>>;
  backgroundIsNil?: InputMaybe<Scalars['Boolean']>;
  backgroundLT?: InputMaybe<Scalars['String']>;
  backgroundLTE?: InputMaybe<Scalars['String']>;
  backgroundNEQ?: InputMaybe<Scalars['String']>;
  backgroundNotIn?: InputMaybe<Array<Scalars['String']>>;
  backgroundNotNil?: InputMaybe<Scalars['Boolean']>;
  /** color field predicates */
  color?: InputMaybe<Scalars['String']>;
  colorContains?: InputMaybe<Scalars['String']>;
  colorContainsFold?: InputMaybe<Scalars['String']>;
  colorEqualFold?: InputMaybe<Scalars['String']>;
  colorGT?: InputMaybe<Scalars['String']>;
  colorGTE?: InputMaybe<Scalars['String']>;
  colorHasPrefix?: InputMaybe<Scalars['String']>;
  colorHasSuffix?: InputMaybe<Scalars['String']>;
  colorIn?: InputMaybe<Array<Scalars['String']>>;
  colorIsNil?: InputMaybe<Scalars['Boolean']>;
  colorLT?: InputMaybe<Scalars['String']>;
  colorLTE?: InputMaybe<Scalars['String']>;
  colorNEQ?: InputMaybe<Scalars['String']>;
  colorNotIn?: InputMaybe<Array<Scalars['String']>>;
  colorNotNil?: InputMaybe<Scalars['Boolean']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** accessory edge predicates */
  hasAccessory?: InputMaybe<Scalars['Boolean']>;
  hasAccessoryWith?: InputMaybe<Array<ItemWhereInput>>;
  /** beard edge predicates */
  hasBeard?: InputMaybe<Scalars['Boolean']>;
  hasBeardWith?: InputMaybe<Array<BodyPartWhereInput>>;
  /** body edge predicates */
  hasBody?: InputMaybe<Scalars['Boolean']>;
  hasBodyWith?: InputMaybe<Array<BodyPartWhereInput>>;
  /** clothes edge predicates */
  hasClothes?: InputMaybe<Scalars['Boolean']>;
  hasClothesWith?: InputMaybe<Array<ItemWhereInput>>;
  /** drug edge predicates */
  hasDrug?: InputMaybe<Scalars['Boolean']>;
  hasDrugWith?: InputMaybe<Array<ItemWhereInput>>;
  /** foot edge predicates */
  hasFoot?: InputMaybe<Scalars['Boolean']>;
  hasFootWith?: InputMaybe<Array<ItemWhereInput>>;
  /** hair edge predicates */
  hasHair?: InputMaybe<Scalars['Boolean']>;
  hasHairWith?: InputMaybe<Array<BodyPartWhereInput>>;
  /** hand edge predicates */
  hasHand?: InputMaybe<Scalars['Boolean']>;
  hasHandWith?: InputMaybe<Array<ItemWhereInput>>;
  /** neck edge predicates */
  hasNeck?: InputMaybe<Scalars['Boolean']>;
  hasNeckWith?: InputMaybe<Array<ItemWhereInput>>;
  /** ring edge predicates */
  hasRing?: InputMaybe<Scalars['Boolean']>;
  hasRingWith?: InputMaybe<Array<ItemWhereInput>>;
  /** vehicle edge predicates */
  hasVehicle?: InputMaybe<Scalars['Boolean']>;
  hasVehicleWith?: InputMaybe<Array<ItemWhereInput>>;
  /** waist edge predicates */
  hasWaist?: InputMaybe<Scalars['Boolean']>;
  hasWaistWith?: InputMaybe<Array<ItemWhereInput>>;
  /** wallet edge predicates */
  hasWallet?: InputMaybe<Scalars['Boolean']>;
  hasWalletWith?: InputMaybe<Array<WalletWhereInput>>;
  /** weapon edge predicates */
  hasWeapon?: InputMaybe<Scalars['Boolean']>;
  hasWeaponWith?: InputMaybe<Array<ItemWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<HustlerWhereInput>;
  or?: InputMaybe<Array<HustlerWhereInput>>;
  /** sex field predicates */
  sex?: InputMaybe<HustlerSex>;
  sexIn?: InputMaybe<Array<HustlerSex>>;
  sexNEQ?: InputMaybe<HustlerSex>;
  sexNotIn?: InputMaybe<Array<HustlerSex>>;
  /** svg field predicates */
  svg?: InputMaybe<Scalars['String']>;
  svgContains?: InputMaybe<Scalars['String']>;
  svgContainsFold?: InputMaybe<Scalars['String']>;
  svgEqualFold?: InputMaybe<Scalars['String']>;
  svgGT?: InputMaybe<Scalars['String']>;
  svgGTE?: InputMaybe<Scalars['String']>;
  svgHasPrefix?: InputMaybe<Scalars['String']>;
  svgHasSuffix?: InputMaybe<Scalars['String']>;
  svgIn?: InputMaybe<Array<Scalars['String']>>;
  svgIsNil?: InputMaybe<Scalars['Boolean']>;
  svgLT?: InputMaybe<Scalars['String']>;
  svgLTE?: InputMaybe<Scalars['String']>;
  svgNEQ?: InputMaybe<Scalars['String']>;
  svgNotIn?: InputMaybe<Array<Scalars['String']>>;
  svgNotNil?: InputMaybe<Scalars['Boolean']>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']>;
  titleContains?: InputMaybe<Scalars['String']>;
  titleContainsFold?: InputMaybe<Scalars['String']>;
  titleEqualFold?: InputMaybe<Scalars['String']>;
  titleGT?: InputMaybe<Scalars['String']>;
  titleGTE?: InputMaybe<Scalars['String']>;
  titleHasPrefix?: InputMaybe<Scalars['String']>;
  titleHasSuffix?: InputMaybe<Scalars['String']>;
  titleIn?: InputMaybe<Array<Scalars['String']>>;
  titleIsNil?: InputMaybe<Scalars['Boolean']>;
  titleLT?: InputMaybe<Scalars['String']>;
  titleLTE?: InputMaybe<Scalars['String']>;
  titleNEQ?: InputMaybe<Scalars['String']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']>>;
  titleNotNil?: InputMaybe<Scalars['Boolean']>;
  /** type field predicates */
  type?: InputMaybe<HustlerType>;
  typeIn?: InputMaybe<Array<HustlerType>>;
  typeNEQ?: InputMaybe<HustlerType>;
  typeNotIn?: InputMaybe<Array<HustlerType>>;
};

export type Item = Node & {
  __typename?: 'Item';
  augmented?: Maybe<Scalars['Boolean']>;
  count: Scalars['Int'];
  greatness: Scalars['Int'];
  id: Scalars['ID'];
  name: Scalars['String'];
  namePrefix?: Maybe<Scalars['String']>;
  nameSuffix?: Maybe<Scalars['String']>;
  suffix?: Maybe<Scalars['String']>;
  tier: ItemTier;
  type: ItemType;
};

export type ItemConnection = {
  __typename?: 'ItemConnection';
  edges?: Maybe<Array<Maybe<ItemEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type ItemEdge = {
  __typename?: 'ItemEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Item>;
};

export type ItemOrder = {
  direction: OrderDirection;
  field?: InputMaybe<ItemOrderField>;
};

export enum ItemOrderField {
  Greatness = 'GREATNESS'
}

/** ItemTier represents the tier of an item. */
export enum ItemTier {
  BlackMarket = 'BLACK_MARKET',
  Common = 'COMMON',
  Custom = 'CUSTOM',
  Rare = 'RARE'
}

/** ItemType represents the item slot the item belongs to. */
export enum ItemType {
  Accessory = 'ACCESSORY',
  Clothes = 'CLOTHES',
  Drugs = 'DRUGS',
  Foot = 'FOOT',
  Hand = 'HAND',
  Neck = 'NECK',
  Ring = 'RING',
  Vehcile = 'VEHCILE',
  Waist = 'WAIST',
  Weapon = 'WEAPON'
}

/**
 * ItemWhereInput is used for filtering Item objects.
 * Input was generated by ent.
 */
export type ItemWhereInput = {
  and?: InputMaybe<Array<ItemWhereInput>>;
  /** augmented field predicates */
  augmented?: InputMaybe<Scalars['Boolean']>;
  augmentedIsNil?: InputMaybe<Scalars['Boolean']>;
  augmentedNEQ?: InputMaybe<Scalars['Boolean']>;
  augmentedNotNil?: InputMaybe<Scalars['Boolean']>;
  /** count field predicates */
  count?: InputMaybe<Scalars['Int']>;
  countGT?: InputMaybe<Scalars['Int']>;
  countGTE?: InputMaybe<Scalars['Int']>;
  countIn?: InputMaybe<Array<Scalars['Int']>>;
  countIsNil?: InputMaybe<Scalars['Boolean']>;
  countLT?: InputMaybe<Scalars['Int']>;
  countLTE?: InputMaybe<Scalars['Int']>;
  countNEQ?: InputMaybe<Scalars['Int']>;
  countNotIn?: InputMaybe<Array<Scalars['Int']>>;
  countNotNil?: InputMaybe<Scalars['Boolean']>;
  /** greatness field predicates */
  greatness?: InputMaybe<Scalars['Int']>;
  greatnessGT?: InputMaybe<Scalars['Int']>;
  greatnessGTE?: InputMaybe<Scalars['Int']>;
  greatnessIn?: InputMaybe<Array<Scalars['Int']>>;
  greatnessIsNil?: InputMaybe<Scalars['Boolean']>;
  greatnessLT?: InputMaybe<Scalars['Int']>;
  greatnessLTE?: InputMaybe<Scalars['Int']>;
  greatnessNEQ?: InputMaybe<Scalars['Int']>;
  greatnessNotIn?: InputMaybe<Array<Scalars['Int']>>;
  greatnessNotNil?: InputMaybe<Scalars['Boolean']>;
  /** base edge predicates */
  hasBase?: InputMaybe<Scalars['Boolean']>;
  hasBaseWith?: InputMaybe<Array<ItemWhereInput>>;
  /** derivative edge predicates */
  hasDerivative?: InputMaybe<Scalars['Boolean']>;
  hasDerivativeWith?: InputMaybe<Array<ItemWhereInput>>;
  /** dopes edge predicates */
  hasDopes?: InputMaybe<Scalars['Boolean']>;
  hasDopesWith?: InputMaybe<Array<DopeWhereInput>>;
  /** hustler_accessories edge predicates */
  hasHustlerAccessories?: InputMaybe<Scalars['Boolean']>;
  hasHustlerAccessoriesWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_clothes edge predicates */
  hasHustlerClothes?: InputMaybe<Scalars['Boolean']>;
  hasHustlerClothesWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_drugs edge predicates */
  hasHustlerDrugs?: InputMaybe<Scalars['Boolean']>;
  hasHustlerDrugsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_feet edge predicates */
  hasHustlerFeet?: InputMaybe<Scalars['Boolean']>;
  hasHustlerFeetWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_hands edge predicates */
  hasHustlerHands?: InputMaybe<Scalars['Boolean']>;
  hasHustlerHandsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_necks edge predicates */
  hasHustlerNecks?: InputMaybe<Scalars['Boolean']>;
  hasHustlerNecksWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_rings edge predicates */
  hasHustlerRings?: InputMaybe<Scalars['Boolean']>;
  hasHustlerRingsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_vehicles edge predicates */
  hasHustlerVehicles?: InputMaybe<Scalars['Boolean']>;
  hasHustlerVehiclesWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_waists edge predicates */
  hasHustlerWaists?: InputMaybe<Scalars['Boolean']>;
  hasHustlerWaistsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_weapons edge predicates */
  hasHustlerWeapons?: InputMaybe<Scalars['Boolean']>;
  hasHustlerWeaponsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** wallets edge predicates */
  hasWallets?: InputMaybe<Scalars['Boolean']>;
  hasWalletsWith?: InputMaybe<Array<WalletItemsWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** name_prefix field predicates */
  namePrefix?: InputMaybe<Scalars['String']>;
  namePrefixContains?: InputMaybe<Scalars['String']>;
  namePrefixContainsFold?: InputMaybe<Scalars['String']>;
  namePrefixEqualFold?: InputMaybe<Scalars['String']>;
  namePrefixGT?: InputMaybe<Scalars['String']>;
  namePrefixGTE?: InputMaybe<Scalars['String']>;
  namePrefixHasPrefix?: InputMaybe<Scalars['String']>;
  namePrefixHasSuffix?: InputMaybe<Scalars['String']>;
  namePrefixIn?: InputMaybe<Array<Scalars['String']>>;
  namePrefixIsNil?: InputMaybe<Scalars['Boolean']>;
  namePrefixLT?: InputMaybe<Scalars['String']>;
  namePrefixLTE?: InputMaybe<Scalars['String']>;
  namePrefixNEQ?: InputMaybe<Scalars['String']>;
  namePrefixNotIn?: InputMaybe<Array<Scalars['String']>>;
  namePrefixNotNil?: InputMaybe<Scalars['Boolean']>;
  /** name_suffix field predicates */
  nameSuffix?: InputMaybe<Scalars['String']>;
  nameSuffixContains?: InputMaybe<Scalars['String']>;
  nameSuffixContainsFold?: InputMaybe<Scalars['String']>;
  nameSuffixEqualFold?: InputMaybe<Scalars['String']>;
  nameSuffixGT?: InputMaybe<Scalars['String']>;
  nameSuffixGTE?: InputMaybe<Scalars['String']>;
  nameSuffixHasPrefix?: InputMaybe<Scalars['String']>;
  nameSuffixHasSuffix?: InputMaybe<Scalars['String']>;
  nameSuffixIn?: InputMaybe<Array<Scalars['String']>>;
  nameSuffixIsNil?: InputMaybe<Scalars['Boolean']>;
  nameSuffixLT?: InputMaybe<Scalars['String']>;
  nameSuffixLTE?: InputMaybe<Scalars['String']>;
  nameSuffixNEQ?: InputMaybe<Scalars['String']>;
  nameSuffixNotIn?: InputMaybe<Array<Scalars['String']>>;
  nameSuffixNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<ItemWhereInput>;
  or?: InputMaybe<Array<ItemWhereInput>>;
  /** suffix field predicates */
  suffix?: InputMaybe<Scalars['String']>;
  suffixContains?: InputMaybe<Scalars['String']>;
  suffixContainsFold?: InputMaybe<Scalars['String']>;
  suffixEqualFold?: InputMaybe<Scalars['String']>;
  suffixGT?: InputMaybe<Scalars['String']>;
  suffixGTE?: InputMaybe<Scalars['String']>;
  suffixHasPrefix?: InputMaybe<Scalars['String']>;
  suffixHasSuffix?: InputMaybe<Scalars['String']>;
  suffixIn?: InputMaybe<Array<Scalars['String']>>;
  suffixIsNil?: InputMaybe<Scalars['Boolean']>;
  suffixLT?: InputMaybe<Scalars['String']>;
  suffixLTE?: InputMaybe<Scalars['String']>;
  suffixNEQ?: InputMaybe<Scalars['String']>;
  suffixNotIn?: InputMaybe<Array<Scalars['String']>>;
  suffixNotNil?: InputMaybe<Scalars['Boolean']>;
  /** svg field predicates */
  svg?: InputMaybe<Scalars['String']>;
  svgContains?: InputMaybe<Scalars['String']>;
  svgContainsFold?: InputMaybe<Scalars['String']>;
  svgEqualFold?: InputMaybe<Scalars['String']>;
  svgGT?: InputMaybe<Scalars['String']>;
  svgGTE?: InputMaybe<Scalars['String']>;
  svgHasPrefix?: InputMaybe<Scalars['String']>;
  svgHasSuffix?: InputMaybe<Scalars['String']>;
  svgIn?: InputMaybe<Array<Scalars['String']>>;
  svgIsNil?: InputMaybe<Scalars['Boolean']>;
  svgLT?: InputMaybe<Scalars['String']>;
  svgLTE?: InputMaybe<Scalars['String']>;
  svgNEQ?: InputMaybe<Scalars['String']>;
  svgNotIn?: InputMaybe<Array<Scalars['String']>>;
  svgNotNil?: InputMaybe<Scalars['Boolean']>;
  /** tier field predicates */
  tier?: InputMaybe<ItemTier>;
  tierIn?: InputMaybe<Array<ItemTier>>;
  tierIsNil?: InputMaybe<Scalars['Boolean']>;
  tierNEQ?: InputMaybe<ItemTier>;
  tierNotIn?: InputMaybe<Array<ItemTier>>;
  tierNotNil?: InputMaybe<Scalars['Boolean']>;
  /** type field predicates */
  type?: InputMaybe<ItemType>;
  typeIn?: InputMaybe<Array<ItemType>>;
  typeNEQ?: InputMaybe<ItemType>;
  typeNotIn?: InputMaybe<Array<ItemType>>;
};

export type Node = {
  id: Scalars['ID'];
};

export enum OrderDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor?: Maybe<Scalars['Cursor']>;
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor?: Maybe<Scalars['Cursor']>;
};

export type Query = {
  __typename?: 'Query';
  dopes: DopeConnection;
  hustlers: HustlerConnection;
  items: ItemConnection;
  node?: Maybe<Node>;
  nodes: Array<Maybe<Node>>;
  wallets: WalletConnection;
};


export type QueryDopesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<DopeOrder>;
  where?: InputMaybe<DopeWhereInput>;
};


export type QueryHustlersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<HustlerOrder>;
  where?: InputMaybe<HustlerWhereInput>;
};


export type QueryItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ItemOrder>;
  where?: InputMaybe<ItemWhereInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};


export type QueryWalletsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<WalletOrder>;
  where?: InputMaybe<WalletWhereInput>;
};

/**
 * SyncStateWhereInput is used for filtering SyncState objects.
 * Input was generated by ent.
 */
export type SyncStateWhereInput = {
  and?: InputMaybe<Array<SyncStateWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<SyncStateWhereInput>;
  or?: InputMaybe<Array<SyncStateWhereInput>>;
  /** start_block field predicates */
  startBlock?: InputMaybe<Scalars['Long']>;
  startBlockGT?: InputMaybe<Scalars['Long']>;
  startBlockGTE?: InputMaybe<Scalars['Long']>;
  startBlockIn?: InputMaybe<Array<Scalars['Long']>>;
  startBlockLT?: InputMaybe<Scalars['Long']>;
  startBlockLTE?: InputMaybe<Scalars['Long']>;
  startBlockNEQ?: InputMaybe<Scalars['Long']>;
  startBlockNotIn?: InputMaybe<Array<Scalars['Long']>>;
};

export type Wallet = Node & {
  __typename?: 'Wallet';
  dopes: Array<Dope>;
  hustlers: Array<Hustler>;
  id: Scalars['ID'];
  items: Array<WalletItems>;
  paper: Scalars['BigInt'];
};

export type WalletConnection = {
  __typename?: 'WalletConnection';
  edges?: Maybe<Array<Maybe<WalletEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type WalletEdge = {
  __typename?: 'WalletEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Wallet>;
};

export type WalletItems = Node & {
  __typename?: 'WalletItems';
  balance: Scalars['BigInt'];
  id: Scalars['ID'];
  item: Item;
  wallet: Wallet;
};

/**
 * WalletItemsWhereInput is used for filtering WalletItems objects.
 * Input was generated by ent.
 */
export type WalletItemsWhereInput = {
  and?: InputMaybe<Array<WalletItemsWhereInput>>;
  /** balance field predicates */
  balance?: InputMaybe<Scalars['BigInt']>;
  balanceGT?: InputMaybe<Scalars['BigInt']>;
  balanceGTE?: InputMaybe<Scalars['BigInt']>;
  balanceIn?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceLT?: InputMaybe<Scalars['BigInt']>;
  balanceLTE?: InputMaybe<Scalars['BigInt']>;
  balanceNEQ?: InputMaybe<Scalars['BigInt']>;
  balanceNotIn?: InputMaybe<Array<Scalars['BigInt']>>;
  /** item edge predicates */
  hasItem?: InputMaybe<Scalars['Boolean']>;
  hasItemWith?: InputMaybe<Array<ItemWhereInput>>;
  /** wallet edge predicates */
  hasWallet?: InputMaybe<Scalars['Boolean']>;
  hasWalletWith?: InputMaybe<Array<WalletWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<WalletItemsWhereInput>;
  or?: InputMaybe<Array<WalletItemsWhereInput>>;
};

export type WalletOrder = {
  direction: OrderDirection;
};

/**
 * WalletWhereInput is used for filtering Wallet objects.
 * Input was generated by ent.
 */
export type WalletWhereInput = {
  and?: InputMaybe<Array<WalletWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** dopes edge predicates */
  hasDopes?: InputMaybe<Scalars['Boolean']>;
  hasDopesWith?: InputMaybe<Array<DopeWhereInput>>;
  /** hustlers edge predicates */
  hasHustlers?: InputMaybe<Scalars['Boolean']>;
  hasHustlersWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** items edge predicates */
  hasItems?: InputMaybe<Scalars['Boolean']>;
  hasItemsWith?: InputMaybe<Array<WalletItemsWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<WalletWhereInput>;
  or?: InputMaybe<Array<WalletWhereInput>>;
  /** paper field predicates */
  paper?: InputMaybe<Scalars['BigInt']>;
  paperGT?: InputMaybe<Scalars['BigInt']>;
  paperGTE?: InputMaybe<Scalars['BigInt']>;
  paperIn?: InputMaybe<Array<Scalars['BigInt']>>;
  paperLT?: InputMaybe<Scalars['BigInt']>;
  paperLTE?: InputMaybe<Scalars['BigInt']>;
  paperNEQ?: InputMaybe<Scalars['BigInt']>;
  paperNotIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type AllHustlersQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<HustlerOrder>;
  where?: InputMaybe<HustlerWhereInput>;
}>;


export type AllHustlersQuery = { __typename?: 'Query', hustlers: { __typename?: 'HustlerConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null | undefined, endCursor?: any | null | undefined }, edges?: Array<{ __typename?: 'HustlerEdge', cursor: any, node?: { __typename?: 'Hustler', id: string, title?: string | null | undefined, name?: string | null | undefined, type: HustlerType, color?: string | null | undefined, background?: string | null | undefined, age: any, sex: HustlerSex, viewbox: Array<number>, order: Array<number>, svg?: string | null | undefined, neck?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, ring?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, accessory?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, body?: { __typename?: 'BodyPart', id: string, type: BodyPartType, sex: BodyPartSex, rle: string } | null | undefined, beard?: { __typename?: 'BodyPart', id: string, type: BodyPartType, sex: BodyPartSex, rle: string } | null | undefined, drug?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, hand?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, weapon?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, clothes?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, vehicle?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, waist?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, foot?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined } | null | undefined } | null | undefined> | null | undefined } };

export type DopesQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<DopeOrder>;
  where?: InputMaybe<DopeWhereInput>;
}>;


export type DopesQuery = { __typename?: 'Query', dopes: { __typename?: 'DopeConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null | undefined, endCursor?: any | null | undefined }, edges?: Array<{ __typename?: 'DopeEdge', cursor: any, node?: { __typename?: 'Dope', id: string, claimed: boolean, opened: boolean, score: number, rank: number, items: Array<{ __typename?: 'Item', id: string, type: ItemType, name: string, namePrefix?: string | null | undefined, nameSuffix?: string | null | undefined, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number }> } | null | undefined } | null | undefined> | null | undefined } };

export type HustlerQueryVariables = Exact<{
  where?: InputMaybe<HustlerWhereInput>;
}>;


export type HustlerQuery = { __typename?: 'Query', hustlers: { __typename?: 'HustlerConnection', edges?: Array<{ __typename?: 'HustlerEdge', node?: { __typename?: 'Hustler', id: string, title?: string | null | undefined, name?: string | null | undefined, type: HustlerType, color?: string | null | undefined, background?: string | null | undefined, age: any, sex: HustlerSex, viewbox: Array<number>, order: Array<number>, svg?: string | null | undefined, neck?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, ring?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, accessory?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, body?: { __typename?: 'BodyPart', id: string, type: BodyPartType, sex: BodyPartSex, rle: string } | null | undefined, beard?: { __typename?: 'BodyPart', id: string, type: BodyPartType, sex: BodyPartSex, rle: string } | null | undefined, drug?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, hand?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, weapon?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, clothes?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, vehicle?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, waist?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, foot?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined } | null | undefined } | null | undefined> | null | undefined } };

export type HustlersWalletQueryVariables = Exact<{
  where?: InputMaybe<WalletWhereInput>;
}>;


export type HustlersWalletQuery = { __typename?: 'Query', wallets: { __typename?: 'WalletConnection', edges?: Array<{ __typename?: 'WalletEdge', node?: { __typename?: 'Wallet', id: string, paper: any, hustlers: Array<{ __typename?: 'Hustler', id: string, title?: string | null | undefined, name?: string | null | undefined, type: HustlerType, color?: string | null | undefined, background?: string | null | undefined, age: any, sex: HustlerSex, viewbox: Array<number>, order: Array<number>, svg?: string | null | undefined, neck?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, ring?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, accessory?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, body?: { __typename?: 'BodyPart', id: string, type: BodyPartType, sex: BodyPartSex, rle: string } | null | undefined, beard?: { __typename?: 'BodyPart', id: string, type: BodyPartType, sex: BodyPartSex, rle: string } | null | undefined, drug?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, hand?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, weapon?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, clothes?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, vehicle?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, waist?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined, foot?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number } | null | undefined }>, items: Array<{ __typename?: 'WalletItems', id: string, balance: any, item: { __typename?: 'Item', id: string, name: string } }>, dopes: Array<{ __typename?: 'Dope', id: string, claimed: boolean, opened: boolean }> } | null | undefined } | null | undefined> | null | undefined } };

export type WalletQueryVariables = Exact<{
  where?: InputMaybe<WalletWhereInput>;
}>;


export type WalletQuery = { __typename?: 'Query', wallets: { __typename?: 'WalletConnection', edges?: Array<{ __typename?: 'WalletEdge', node?: { __typename?: 'Wallet', id: string, paper: any, hustlers: Array<{ __typename?: 'Hustler', id: string, title?: string | null | undefined, name?: string | null | undefined }>, items: Array<{ __typename?: 'WalletItems', id: string, balance: any, item: { __typename?: 'Item', id: string, name: string } }>, dopes: Array<{ __typename?: 'Dope', id: string, claimed: boolean, opened: boolean, score: number, rank: number }> } | null | undefined } | null | undefined> | null | undefined } };


export const AllHustlersDocument = `
    query AllHustlers($after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: HustlerOrder, $where: HustlerWhereInput) {
  hustlers(
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: $where
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        title
        name
        type
        title
        color
        background
        age
        background
        neck {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        sex
        viewbox
        order
        ring {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        accessory {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        svg
        body {
          id
          type
          sex
          rle
        }
        beard {
          id
          type
          sex
          rle
        }
        drug {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        hand {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        weapon {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        clothes {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        vehicle {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        waist {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        foot {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
      }
    }
  }
}
    `;
export const useAllHustlersQuery = <
      TData = AllHustlersQuery,
      TError = unknown
    >(
      variables?: AllHustlersQueryVariables,
      options?: UseQueryOptions<AllHustlersQuery, TError, TData>
    ) =>
    useQuery<AllHustlersQuery, TError, TData>(
      variables === undefined ? ['AllHustlers'] : ['AllHustlers', variables],
      fetcher<AllHustlersQuery, AllHustlersQueryVariables>(AllHustlersDocument, variables),
      options
    );
export const useInfiniteAllHustlersQuery = <
      TData = AllHustlersQuery,
      TError = unknown
    >(
      pageParamKey: keyof AllHustlersQueryVariables,
      variables?: AllHustlersQueryVariables,
      options?: UseInfiniteQueryOptions<AllHustlersQuery, TError, TData>
    ) =>
    useInfiniteQuery<AllHustlersQuery, TError, TData>(
      variables === undefined ? ['AllHustlers.infinite'] : ['AllHustlers.infinite', variables],
      (metaData) => fetcher<AllHustlersQuery, AllHustlersQueryVariables>(AllHustlersDocument, {...variables, ...(metaData.pageParam ?? {})})(),
      options
    );

export const DopesDocument = `
    query Dopes($after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: DopeOrder, $where: DopeWhereInput) {
  dopes(
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: $where
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        claimed
        opened
        score
        rank
        items {
          id
          type
          name
          namePrefix
          nameSuffix
          suffix
          augmented
          tier
          greatness
          count
        }
      }
    }
  }
}
    `;
export const useDopesQuery = <
      TData = DopesQuery,
      TError = unknown
    >(
      variables?: DopesQueryVariables,
      options?: UseQueryOptions<DopesQuery, TError, TData>
    ) =>
    useQuery<DopesQuery, TError, TData>(
      variables === undefined ? ['Dopes'] : ['Dopes', variables],
      fetcher<DopesQuery, DopesQueryVariables>(DopesDocument, variables),
      options
    );
export const useInfiniteDopesQuery = <
      TData = DopesQuery,
      TError = unknown
    >(
      pageParamKey: keyof DopesQueryVariables,
      variables?: DopesQueryVariables,
      options?: UseInfiniteQueryOptions<DopesQuery, TError, TData>
    ) =>
    useInfiniteQuery<DopesQuery, TError, TData>(
      variables === undefined ? ['Dopes.infinite'] : ['Dopes.infinite', variables],
      (metaData) => fetcher<DopesQuery, DopesQueryVariables>(DopesDocument, {...variables, ...(metaData.pageParam ?? {})})(),
      options
    );

export const HustlerDocument = `
    query Hustler($where: HustlerWhereInput) {
  hustlers(where: $where) {
    edges {
      node {
        id
        title
        name
        type
        title
        color
        background
        age
        background
        neck {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        sex
        viewbox
        order
        ring {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        accessory {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        svg
        body {
          id
          type
          sex
          rle
        }
        beard {
          id
          type
          sex
          rle
        }
        drug {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        hand {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        weapon {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        clothes {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        vehicle {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        waist {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
        foot {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
        }
      }
    }
  }
}
    `;
export const useHustlerQuery = <
      TData = HustlerQuery,
      TError = unknown
    >(
      variables?: HustlerQueryVariables,
      options?: UseQueryOptions<HustlerQuery, TError, TData>
    ) =>
    useQuery<HustlerQuery, TError, TData>(
      variables === undefined ? ['Hustler'] : ['Hustler', variables],
      fetcher<HustlerQuery, HustlerQueryVariables>(HustlerDocument, variables),
      options
    );
export const useInfiniteHustlerQuery = <
      TData = HustlerQuery,
      TError = unknown
    >(
      pageParamKey: keyof HustlerQueryVariables,
      variables?: HustlerQueryVariables,
      options?: UseInfiniteQueryOptions<HustlerQuery, TError, TData>
    ) =>
    useInfiniteQuery<HustlerQuery, TError, TData>(
      variables === undefined ? ['Hustler.infinite'] : ['Hustler.infinite', variables],
      (metaData) => fetcher<HustlerQuery, HustlerQueryVariables>(HustlerDocument, {...variables, ...(metaData.pageParam ?? {})})(),
      options
    );

export const HustlersWalletDocument = `
    query HustlersWallet($where: WalletWhereInput) {
  wallets(where: $where) {
    edges {
      node {
        id
        paper
        hustlers {
          id
          title
          name
          type
          title
          color
          background
          age
          background
          neck {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
          }
          sex
          viewbox
          order
          ring {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
          }
          accessory {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
          }
          svg
          body {
            id
            type
            sex
            rle
          }
          beard {
            id
            type
            sex
            rle
          }
          drug {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
          }
          hand {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
          }
          weapon {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
          }
          clothes {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
          }
          vehicle {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
          }
          waist {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
          }
          foot {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
          }
        }
        items {
          id
          balance
          item {
            id
            name
          }
        }
        dopes {
          id
          claimed
          opened
        }
      }
    }
  }
}
    `;
export const useHustlersWalletQuery = <
      TData = HustlersWalletQuery,
      TError = unknown
    >(
      variables?: HustlersWalletQueryVariables,
      options?: UseQueryOptions<HustlersWalletQuery, TError, TData>
    ) =>
    useQuery<HustlersWalletQuery, TError, TData>(
      variables === undefined ? ['HustlersWallet'] : ['HustlersWallet', variables],
      fetcher<HustlersWalletQuery, HustlersWalletQueryVariables>(HustlersWalletDocument, variables),
      options
    );
export const useInfiniteHustlersWalletQuery = <
      TData = HustlersWalletQuery,
      TError = unknown
    >(
      pageParamKey: keyof HustlersWalletQueryVariables,
      variables?: HustlersWalletQueryVariables,
      options?: UseInfiniteQueryOptions<HustlersWalletQuery, TError, TData>
    ) =>
    useInfiniteQuery<HustlersWalletQuery, TError, TData>(
      variables === undefined ? ['HustlersWallet.infinite'] : ['HustlersWallet.infinite', variables],
      (metaData) => fetcher<HustlersWalletQuery, HustlersWalletQueryVariables>(HustlersWalletDocument, {...variables, ...(metaData.pageParam ?? {})})(),
      options
    );

export const WalletDocument = `
    query Wallet($where: WalletWhereInput) {
  wallets(where: $where) {
    edges {
      node {
        id
        paper
        hustlers {
          id
          title
          name
        }
        items {
          id
          balance
          item {
            id
            name
          }
        }
        dopes {
          id
          claimed
          opened
          score
          rank
        }
      }
    }
  }
}
    `;
export const useWalletQuery = <
      TData = WalletQuery,
      TError = unknown
    >(
      variables?: WalletQueryVariables,
      options?: UseQueryOptions<WalletQuery, TError, TData>
    ) =>
    useQuery<WalletQuery, TError, TData>(
      variables === undefined ? ['Wallet'] : ['Wallet', variables],
      fetcher<WalletQuery, WalletQueryVariables>(WalletDocument, variables),
      options
    );
export const useInfiniteWalletQuery = <
      TData = WalletQuery,
      TError = unknown
    >(
      pageParamKey: keyof WalletQueryVariables,
      variables?: WalletQueryVariables,
      options?: UseInfiniteQueryOptions<WalletQuery, TError, TData>
    ) =>
    useInfiniteQuery<WalletQuery, TError, TData>(
      variables === undefined ? ['Wallet.infinite'] : ['Wallet.infinite', variables],
      (metaData) => fetcher<WalletQuery, WalletQueryVariables>(WalletDocument, {...variables, ...(metaData.pageParam ?? {})})(),
      options
    );
