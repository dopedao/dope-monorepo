import { useQuery, UseQueryOptions, useInfiniteQuery, UseInfiniteQueryOptions, QueryFunctionContext } from 'react-query';
import { useFetchData } from 'hooks/fetcher';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** Address is a 20 byte Ethereum address, represented as 0x-prefixed hexadecimal. */
  Address: any;
  /** BigInt is a large integer represented as a string. */
  BigInt: any;
  /**
   * Bytes is an arbitrary length binary string, represented as 0x-prefixed hexadecimal.
   * An empty byte string is represented as '0x'. Byte strings must have an even number of hexadecimal nybbles.
   */
  Bytes: any;
  /** Bytes32 is a 32 byte binary string, represented as 0x-prefixed hexadecimal. */
  Bytes32: any;
  Cursor: any;
  /** Long is a 64 bit unsigned integer. */
  Long: any;
  /** Maps a Time GraphQL scalar to a Go time.Time struct. */
  Time: any;
  /** Timestamp is a RFC3339 string. */
  Timestamp: any;
};

export type Amount = Node & {
  __typename?: 'Amount';
  amount: Scalars['BigInt'];
  id: Scalars['ID'];
  token?: Maybe<Token>;
  type: AmountType;
};

export enum AmountType {
  Dope = 'DOPE',
  Equipment = 'EQUIPMENT',
  Eth = 'ETH',
  Hustler = 'HUSTLER',
  Paper = 'PAPER',
  Turf = 'TURF'
}

/**
 * AmountWhereInput is used for filtering Amount objects.
 * Input was generated by ent.
 */
export type AmountWhereInput = {
  /** amount field predicates */
  amount?: InputMaybe<Scalars['BigInt']>;
  amountGT?: InputMaybe<Scalars['BigInt']>;
  amountGTE?: InputMaybe<Scalars['BigInt']>;
  amountIn?: InputMaybe<Array<Scalars['BigInt']>>;
  amountLT?: InputMaybe<Scalars['BigInt']>;
  amountLTE?: InputMaybe<Scalars['BigInt']>;
  amountNEQ?: InputMaybe<Scalars['BigInt']>;
  amountNotIn?: InputMaybe<Array<Scalars['BigInt']>>;
  and?: InputMaybe<Array<AmountWhereInput>>;
  /** asset_id field predicates */
  assetID?: InputMaybe<Scalars['BigInt']>;
  assetIDGT?: InputMaybe<Scalars['BigInt']>;
  assetIDGTE?: InputMaybe<Scalars['BigInt']>;
  assetIDIn?: InputMaybe<Array<Scalars['BigInt']>>;
  assetIDLT?: InputMaybe<Scalars['BigInt']>;
  assetIDLTE?: InputMaybe<Scalars['BigInt']>;
  assetIDNEQ?: InputMaybe<Scalars['BigInt']>;
  assetIDNotIn?: InputMaybe<Array<Scalars['BigInt']>>;
  /** listing_input edge predicates */
  hasListingInput?: InputMaybe<Scalars['Boolean']>;
  hasListingInputWith?: InputMaybe<Array<ListingWhereInput>>;
  /** listing_output edge predicates */
  hasListingOutput?: InputMaybe<Scalars['Boolean']>;
  hasListingOutputWith?: InputMaybe<Array<ListingWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<AmountWhereInput>;
  or?: InputMaybe<Array<AmountWhereInput>>;
  /** type field predicates */
  type?: InputMaybe<AmountType>;
  typeIn?: InputMaybe<Array<AmountType>>;
  typeNEQ?: InputMaybe<AmountType>;
  typeNotIn?: InputMaybe<Array<AmountType>>;
};

export type BodyPart = Node & {
  __typename?: 'BodyPart';
  id: Scalars['ID'];
  rle: Scalars['String'];
  sex: BodyPartSex;
  type: BodyPartType;
};

export enum BodyPartSex {
  Female = 'FEMALE',
  Male = 'MALE'
}

export enum BodyPartType {
  Beard = 'BEARD',
  Body = 'BODY',
  Hair = 'HAIR'
}

/**
 * BodyPartWhereInput is used for filtering BodyPart objects.
 * Input was generated by ent.
 */
export type BodyPartWhereInput = {
  and?: InputMaybe<Array<BodyPartWhereInput>>;
  /** hustler_beards edge predicates */
  hasHustlerBeards?: InputMaybe<Scalars['Boolean']>;
  hasHustlerBeardsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_bodies edge predicates */
  hasHustlerBodies?: InputMaybe<Scalars['Boolean']>;
  hasHustlerBodiesWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_hairs edge predicates */
  hasHustlerHairs?: InputMaybe<Scalars['Boolean']>;
  hasHustlerHairsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<BodyPartWhereInput>;
  or?: InputMaybe<Array<BodyPartWhereInput>>;
  /** rle field predicates */
  rle?: InputMaybe<Scalars['String']>;
  rleContains?: InputMaybe<Scalars['String']>;
  rleContainsFold?: InputMaybe<Scalars['String']>;
  rleEqualFold?: InputMaybe<Scalars['String']>;
  rleGT?: InputMaybe<Scalars['String']>;
  rleGTE?: InputMaybe<Scalars['String']>;
  rleHasPrefix?: InputMaybe<Scalars['String']>;
  rleHasSuffix?: InputMaybe<Scalars['String']>;
  rleIn?: InputMaybe<Array<Scalars['String']>>;
  rleLT?: InputMaybe<Scalars['String']>;
  rleLTE?: InputMaybe<Scalars['String']>;
  rleNEQ?: InputMaybe<Scalars['String']>;
  rleNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** sex field predicates */
  sex?: InputMaybe<BodyPartSex>;
  sexIn?: InputMaybe<Array<BodyPartSex>>;
  sexNEQ?: InputMaybe<BodyPartSex>;
  sexNotIn?: InputMaybe<Array<BodyPartSex>>;
  /** sprite field predicates */
  sprite?: InputMaybe<Scalars['String']>;
  spriteContains?: InputMaybe<Scalars['String']>;
  spriteContainsFold?: InputMaybe<Scalars['String']>;
  spriteEqualFold?: InputMaybe<Scalars['String']>;
  spriteGT?: InputMaybe<Scalars['String']>;
  spriteGTE?: InputMaybe<Scalars['String']>;
  spriteHasPrefix?: InputMaybe<Scalars['String']>;
  spriteHasSuffix?: InputMaybe<Scalars['String']>;
  spriteIn?: InputMaybe<Array<Scalars['String']>>;
  spriteIsNil?: InputMaybe<Scalars['Boolean']>;
  spriteLT?: InputMaybe<Scalars['String']>;
  spriteLTE?: InputMaybe<Scalars['String']>;
  spriteNEQ?: InputMaybe<Scalars['String']>;
  spriteNotIn?: InputMaybe<Array<Scalars['String']>>;
  spriteNotNil?: InputMaybe<Scalars['Boolean']>;
  /** type field predicates */
  type?: InputMaybe<BodyPartType>;
  typeIn?: InputMaybe<Array<BodyPartType>>;
  typeNEQ?: InputMaybe<BodyPartType>;
  typeNotIn?: InputMaybe<Array<BodyPartType>>;
};

export type Dope = Node & {
  __typename?: 'Dope';
  claimed: Scalars['Boolean'];
  id: Scalars['ID'];
  items: Array<Item>;
  lastSale?: Maybe<Listing>;
  listings?: Maybe<Array<Maybe<Listing>>>;
  opened: Scalars['Boolean'];
  rank: Scalars['Int'];
  score: Scalars['Int'];
};

export type DopeConnection = {
  __typename?: 'DopeConnection';
  edges?: Maybe<Array<Maybe<DopeEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type DopeEdge = {
  __typename?: 'DopeEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Dope>;
};

export type DopeOrder = {
  direction: OrderDirection;
  field?: InputMaybe<DopeOrderField>;
};

export enum DopeOrderField {
  Id = 'ID',
  Rank = 'RANK'
}

/**
 * DopeWhereInput is used for filtering Dope objects.
 * Input was generated by ent.
 */
export type DopeWhereInput = {
  and?: InputMaybe<Array<DopeWhereInput>>;
  /** claimed field predicates */
  claimed?: InputMaybe<Scalars['Boolean']>;
  claimedNEQ?: InputMaybe<Scalars['Boolean']>;
  /** index edge predicates */
  hasIndex?: InputMaybe<Scalars['Boolean']>;
  hasIndexWith?: InputMaybe<Array<SearchWhereInput>>;
  /** items edge predicates */
  hasItems?: InputMaybe<Scalars['Boolean']>;
  hasItemsWith?: InputMaybe<Array<ItemWhereInput>>;
  /** last_sale edge predicates */
  hasLastSale?: InputMaybe<Scalars['Boolean']>;
  hasLastSaleWith?: InputMaybe<Array<ListingWhereInput>>;
  /** listings edge predicates */
  hasListings?: InputMaybe<Scalars['Boolean']>;
  hasListingsWith?: InputMaybe<Array<ListingWhereInput>>;
  /** wallet edge predicates */
  hasWallet?: InputMaybe<Scalars['Boolean']>;
  hasWalletWith?: InputMaybe<Array<WalletWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<DopeWhereInput>;
  /** opened field predicates */
  opened?: InputMaybe<Scalars['Boolean']>;
  openedNEQ?: InputMaybe<Scalars['Boolean']>;
  or?: InputMaybe<Array<DopeWhereInput>>;
  /** order field predicates */
  order?: InputMaybe<Scalars['Int']>;
  orderGT?: InputMaybe<Scalars['Int']>;
  orderGTE?: InputMaybe<Scalars['Int']>;
  orderIn?: InputMaybe<Array<Scalars['Int']>>;
  orderLT?: InputMaybe<Scalars['Int']>;
  orderLTE?: InputMaybe<Scalars['Int']>;
  orderNEQ?: InputMaybe<Scalars['Int']>;
  orderNotIn?: InputMaybe<Array<Scalars['Int']>>;
  /** rank field predicates */
  rank?: InputMaybe<Scalars['Int']>;
  rankGT?: InputMaybe<Scalars['Int']>;
  rankGTE?: InputMaybe<Scalars['Int']>;
  rankIn?: InputMaybe<Array<Scalars['Int']>>;
  rankIsNil?: InputMaybe<Scalars['Boolean']>;
  rankLT?: InputMaybe<Scalars['Int']>;
  rankLTE?: InputMaybe<Scalars['Int']>;
  rankNEQ?: InputMaybe<Scalars['Int']>;
  rankNotIn?: InputMaybe<Array<Scalars['Int']>>;
  rankNotNil?: InputMaybe<Scalars['Boolean']>;
  /** score field predicates */
  score?: InputMaybe<Scalars['Int']>;
  scoreGT?: InputMaybe<Scalars['Int']>;
  scoreGTE?: InputMaybe<Scalars['Int']>;
  scoreIn?: InputMaybe<Array<Scalars['Int']>>;
  scoreIsNil?: InputMaybe<Scalars['Boolean']>;
  scoreLT?: InputMaybe<Scalars['Int']>;
  scoreLTE?: InputMaybe<Scalars['Int']>;
  scoreNEQ?: InputMaybe<Scalars['Int']>;
  scoreNotIn?: InputMaybe<Array<Scalars['Int']>>;
  scoreNotNil?: InputMaybe<Scalars['Boolean']>;
};

/**
 * EventWhereInput is used for filtering Event objects.
 * Input was generated by ent.
 */
export type EventWhereInput = {
  and?: InputMaybe<Array<EventWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** index field predicates */
  index?: InputMaybe<Scalars['Long']>;
  indexGT?: InputMaybe<Scalars['Long']>;
  indexGTE?: InputMaybe<Scalars['Long']>;
  indexIn?: InputMaybe<Array<Scalars['Long']>>;
  indexLT?: InputMaybe<Scalars['Long']>;
  indexLTE?: InputMaybe<Scalars['Long']>;
  indexNEQ?: InputMaybe<Scalars['Long']>;
  indexNotIn?: InputMaybe<Array<Scalars['Long']>>;
  not?: InputMaybe<EventWhereInput>;
  or?: InputMaybe<Array<EventWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Hustler = Node & {
  __typename?: 'Hustler';
  accessory?: Maybe<Item>;
  age: Scalars['Long'];
  background?: Maybe<Scalars['String']>;
  beard?: Maybe<BodyPart>;
  body?: Maybe<BodyPart>;
  clothes?: Maybe<Item>;
  color?: Maybe<Scalars['String']>;
  drug?: Maybe<Item>;
  foot?: Maybe<Item>;
  hair?: Maybe<BodyPart>;
  hand?: Maybe<Item>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  neck?: Maybe<Item>;
  order: Array<Scalars['Int']>;
  ring?: Maybe<Item>;
  sex: HustlerSex;
  svg?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  type: HustlerType;
  vehicle?: Maybe<Item>;
  viewbox: Array<Scalars['Int']>;
  waist?: Maybe<Item>;
  weapon?: Maybe<Item>;
};

export type HustlerConnection = {
  __typename?: 'HustlerConnection';
  edges?: Maybe<Array<Maybe<HustlerEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type HustlerEdge = {
  __typename?: 'HustlerEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Hustler>;
};

export type HustlerOrder = {
  direction: OrderDirection;
};

export enum HustlerSex {
  Female = 'FEMALE',
  Male = 'MALE'
}

export enum HustlerType {
  OriginalGangsta = 'ORIGINAL_GANGSTA',
  Regular = 'REGULAR'
}

/**
 * HustlerWhereInput is used for filtering Hustler objects.
 * Input was generated by ent.
 */
export type HustlerWhereInput = {
  /** age field predicates */
  age?: InputMaybe<Scalars['Long']>;
  ageGT?: InputMaybe<Scalars['Long']>;
  ageGTE?: InputMaybe<Scalars['Long']>;
  ageIn?: InputMaybe<Array<Scalars['Long']>>;
  ageLT?: InputMaybe<Scalars['Long']>;
  ageLTE?: InputMaybe<Scalars['Long']>;
  ageNEQ?: InputMaybe<Scalars['Long']>;
  ageNotIn?: InputMaybe<Array<Scalars['Long']>>;
  and?: InputMaybe<Array<HustlerWhereInput>>;
  /** background field predicates */
  background?: InputMaybe<Scalars['String']>;
  backgroundContains?: InputMaybe<Scalars['String']>;
  backgroundContainsFold?: InputMaybe<Scalars['String']>;
  backgroundEqualFold?: InputMaybe<Scalars['String']>;
  backgroundGT?: InputMaybe<Scalars['String']>;
  backgroundGTE?: InputMaybe<Scalars['String']>;
  backgroundHasPrefix?: InputMaybe<Scalars['String']>;
  backgroundHasSuffix?: InputMaybe<Scalars['String']>;
  backgroundIn?: InputMaybe<Array<Scalars['String']>>;
  backgroundIsNil?: InputMaybe<Scalars['Boolean']>;
  backgroundLT?: InputMaybe<Scalars['String']>;
  backgroundLTE?: InputMaybe<Scalars['String']>;
  backgroundNEQ?: InputMaybe<Scalars['String']>;
  backgroundNotIn?: InputMaybe<Array<Scalars['String']>>;
  backgroundNotNil?: InputMaybe<Scalars['Boolean']>;
  /** color field predicates */
  color?: InputMaybe<Scalars['String']>;
  colorContains?: InputMaybe<Scalars['String']>;
  colorContainsFold?: InputMaybe<Scalars['String']>;
  colorEqualFold?: InputMaybe<Scalars['String']>;
  colorGT?: InputMaybe<Scalars['String']>;
  colorGTE?: InputMaybe<Scalars['String']>;
  colorHasPrefix?: InputMaybe<Scalars['String']>;
  colorHasSuffix?: InputMaybe<Scalars['String']>;
  colorIn?: InputMaybe<Array<Scalars['String']>>;
  colorIsNil?: InputMaybe<Scalars['Boolean']>;
  colorLT?: InputMaybe<Scalars['String']>;
  colorLTE?: InputMaybe<Scalars['String']>;
  colorNEQ?: InputMaybe<Scalars['String']>;
  colorNotIn?: InputMaybe<Array<Scalars['String']>>;
  colorNotNil?: InputMaybe<Scalars['Boolean']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** accessory edge predicates */
  hasAccessory?: InputMaybe<Scalars['Boolean']>;
  hasAccessoryWith?: InputMaybe<Array<ItemWhereInput>>;
  /** beard edge predicates */
  hasBeard?: InputMaybe<Scalars['Boolean']>;
  hasBeardWith?: InputMaybe<Array<BodyPartWhereInput>>;
  /** body edge predicates */
  hasBody?: InputMaybe<Scalars['Boolean']>;
  hasBodyWith?: InputMaybe<Array<BodyPartWhereInput>>;
  /** clothes edge predicates */
  hasClothes?: InputMaybe<Scalars['Boolean']>;
  hasClothesWith?: InputMaybe<Array<ItemWhereInput>>;
  /** drug edge predicates */
  hasDrug?: InputMaybe<Scalars['Boolean']>;
  hasDrugWith?: InputMaybe<Array<ItemWhereInput>>;
  /** foot edge predicates */
  hasFoot?: InputMaybe<Scalars['Boolean']>;
  hasFootWith?: InputMaybe<Array<ItemWhereInput>>;
  /** hair edge predicates */
  hasHair?: InputMaybe<Scalars['Boolean']>;
  hasHairWith?: InputMaybe<Array<BodyPartWhereInput>>;
  /** hand edge predicates */
  hasHand?: InputMaybe<Scalars['Boolean']>;
  hasHandWith?: InputMaybe<Array<ItemWhereInput>>;
  /** index edge predicates */
  hasIndex?: InputMaybe<Scalars['Boolean']>;
  hasIndexWith?: InputMaybe<Array<SearchWhereInput>>;
  /** neck edge predicates */
  hasNeck?: InputMaybe<Scalars['Boolean']>;
  hasNeckWith?: InputMaybe<Array<ItemWhereInput>>;
  /** ring edge predicates */
  hasRing?: InputMaybe<Scalars['Boolean']>;
  hasRingWith?: InputMaybe<Array<ItemWhereInput>>;
  /** vehicle edge predicates */
  hasVehicle?: InputMaybe<Scalars['Boolean']>;
  hasVehicleWith?: InputMaybe<Array<ItemWhereInput>>;
  /** waist edge predicates */
  hasWaist?: InputMaybe<Scalars['Boolean']>;
  hasWaistWith?: InputMaybe<Array<ItemWhereInput>>;
  /** wallet edge predicates */
  hasWallet?: InputMaybe<Scalars['Boolean']>;
  hasWalletWith?: InputMaybe<Array<WalletWhereInput>>;
  /** weapon edge predicates */
  hasWeapon?: InputMaybe<Scalars['Boolean']>;
  hasWeaponWith?: InputMaybe<Array<ItemWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<HustlerWhereInput>;
  or?: InputMaybe<Array<HustlerWhereInput>>;
  /** sex field predicates */
  sex?: InputMaybe<HustlerSex>;
  sexIn?: InputMaybe<Array<HustlerSex>>;
  sexNEQ?: InputMaybe<HustlerSex>;
  sexNotIn?: InputMaybe<Array<HustlerSex>>;
  /** svg field predicates */
  svg?: InputMaybe<Scalars['String']>;
  svgContains?: InputMaybe<Scalars['String']>;
  svgContainsFold?: InputMaybe<Scalars['String']>;
  svgEqualFold?: InputMaybe<Scalars['String']>;
  svgGT?: InputMaybe<Scalars['String']>;
  svgGTE?: InputMaybe<Scalars['String']>;
  svgHasPrefix?: InputMaybe<Scalars['String']>;
  svgHasSuffix?: InputMaybe<Scalars['String']>;
  svgIn?: InputMaybe<Array<Scalars['String']>>;
  svgIsNil?: InputMaybe<Scalars['Boolean']>;
  svgLT?: InputMaybe<Scalars['String']>;
  svgLTE?: InputMaybe<Scalars['String']>;
  svgNEQ?: InputMaybe<Scalars['String']>;
  svgNotIn?: InputMaybe<Array<Scalars['String']>>;
  svgNotNil?: InputMaybe<Scalars['Boolean']>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']>;
  titleContains?: InputMaybe<Scalars['String']>;
  titleContainsFold?: InputMaybe<Scalars['String']>;
  titleEqualFold?: InputMaybe<Scalars['String']>;
  titleGT?: InputMaybe<Scalars['String']>;
  titleGTE?: InputMaybe<Scalars['String']>;
  titleHasPrefix?: InputMaybe<Scalars['String']>;
  titleHasSuffix?: InputMaybe<Scalars['String']>;
  titleIn?: InputMaybe<Array<Scalars['String']>>;
  titleIsNil?: InputMaybe<Scalars['Boolean']>;
  titleLT?: InputMaybe<Scalars['String']>;
  titleLTE?: InputMaybe<Scalars['String']>;
  titleNEQ?: InputMaybe<Scalars['String']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']>>;
  titleNotNil?: InputMaybe<Scalars['Boolean']>;
  /** type field predicates */
  type?: InputMaybe<HustlerType>;
  typeIn?: InputMaybe<Array<HustlerType>>;
  typeNEQ?: InputMaybe<HustlerType>;
  typeNotIn?: InputMaybe<Array<HustlerType>>;
};

export type Item = Node & {
  __typename?: 'Item';
  augmented?: Maybe<Scalars['Boolean']>;
  base?: Maybe<Item>;
  count: Scalars['Int'];
  fullname: Scalars['String'];
  greatness: Scalars['Int'];
  id: Scalars['ID'];
  name: Scalars['String'];
  namePrefix?: Maybe<Scalars['String']>;
  nameSuffix?: Maybe<Scalars['String']>;
  rles?: Maybe<RlEs>;
  suffix?: Maybe<Scalars['String']>;
  svg?: Maybe<Scalars['String']>;
  tier: ItemTier;
  type: ItemType;
};

export type ItemConnection = {
  __typename?: 'ItemConnection';
  edges?: Maybe<Array<Maybe<ItemEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type ItemEdge = {
  __typename?: 'ItemEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Item>;
};

export type ItemOrder = {
  direction: OrderDirection;
  field?: InputMaybe<ItemOrderField>;
};

export enum ItemOrderField {
  Greatness = 'GREATNESS'
}

/** ItemTier represents the tier of an item. */
export enum ItemTier {
  BlackMarket = 'BLACK_MARKET',
  Common = 'COMMON',
  Custom = 'CUSTOM',
  Rare = 'RARE'
}

/** ItemType represents the item slot the item belongs to. */
export enum ItemType {
  Accessory = 'ACCESSORY',
  Clothes = 'CLOTHES',
  Drugs = 'DRUGS',
  Foot = 'FOOT',
  Hand = 'HAND',
  Neck = 'NECK',
  Ring = 'RING',
  Vehcile = 'VEHCILE',
  Waist = 'WAIST',
  Weapon = 'WEAPON'
}

/**
 * ItemWhereInput is used for filtering Item objects.
 * Input was generated by ent.
 */
export type ItemWhereInput = {
  and?: InputMaybe<Array<ItemWhereInput>>;
  /** augmented field predicates */
  augmented?: InputMaybe<Scalars['Boolean']>;
  augmentedIsNil?: InputMaybe<Scalars['Boolean']>;
  augmentedNEQ?: InputMaybe<Scalars['Boolean']>;
  augmentedNotNil?: InputMaybe<Scalars['Boolean']>;
  /** count field predicates */
  count?: InputMaybe<Scalars['Int']>;
  countGT?: InputMaybe<Scalars['Int']>;
  countGTE?: InputMaybe<Scalars['Int']>;
  countIn?: InputMaybe<Array<Scalars['Int']>>;
  countIsNil?: InputMaybe<Scalars['Boolean']>;
  countLT?: InputMaybe<Scalars['Int']>;
  countLTE?: InputMaybe<Scalars['Int']>;
  countNEQ?: InputMaybe<Scalars['Int']>;
  countNotIn?: InputMaybe<Array<Scalars['Int']>>;
  countNotNil?: InputMaybe<Scalars['Boolean']>;
  /** greatness field predicates */
  greatness?: InputMaybe<Scalars['Int']>;
  greatnessGT?: InputMaybe<Scalars['Int']>;
  greatnessGTE?: InputMaybe<Scalars['Int']>;
  greatnessIn?: InputMaybe<Array<Scalars['Int']>>;
  greatnessIsNil?: InputMaybe<Scalars['Boolean']>;
  greatnessLT?: InputMaybe<Scalars['Int']>;
  greatnessLTE?: InputMaybe<Scalars['Int']>;
  greatnessNEQ?: InputMaybe<Scalars['Int']>;
  greatnessNotIn?: InputMaybe<Array<Scalars['Int']>>;
  greatnessNotNil?: InputMaybe<Scalars['Boolean']>;
  /** base edge predicates */
  hasBase?: InputMaybe<Scalars['Boolean']>;
  hasBaseWith?: InputMaybe<Array<ItemWhereInput>>;
  /** derivative edge predicates */
  hasDerivative?: InputMaybe<Scalars['Boolean']>;
  hasDerivativeWith?: InputMaybe<Array<ItemWhereInput>>;
  /** dopes edge predicates */
  hasDopes?: InputMaybe<Scalars['Boolean']>;
  hasDopesWith?: InputMaybe<Array<DopeWhereInput>>;
  /** hustler_accessories edge predicates */
  hasHustlerAccessories?: InputMaybe<Scalars['Boolean']>;
  hasHustlerAccessoriesWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_clothes edge predicates */
  hasHustlerClothes?: InputMaybe<Scalars['Boolean']>;
  hasHustlerClothesWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_drugs edge predicates */
  hasHustlerDrugs?: InputMaybe<Scalars['Boolean']>;
  hasHustlerDrugsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_feet edge predicates */
  hasHustlerFeet?: InputMaybe<Scalars['Boolean']>;
  hasHustlerFeetWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_hands edge predicates */
  hasHustlerHands?: InputMaybe<Scalars['Boolean']>;
  hasHustlerHandsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_necks edge predicates */
  hasHustlerNecks?: InputMaybe<Scalars['Boolean']>;
  hasHustlerNecksWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_rings edge predicates */
  hasHustlerRings?: InputMaybe<Scalars['Boolean']>;
  hasHustlerRingsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_vehicles edge predicates */
  hasHustlerVehicles?: InputMaybe<Scalars['Boolean']>;
  hasHustlerVehiclesWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_waists edge predicates */
  hasHustlerWaists?: InputMaybe<Scalars['Boolean']>;
  hasHustlerWaistsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_weapons edge predicates */
  hasHustlerWeapons?: InputMaybe<Scalars['Boolean']>;
  hasHustlerWeaponsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** index edge predicates */
  hasIndex?: InputMaybe<Scalars['Boolean']>;
  hasIndexWith?: InputMaybe<Array<SearchWhereInput>>;
  /** wallets edge predicates */
  hasWallets?: InputMaybe<Scalars['Boolean']>;
  hasWalletsWith?: InputMaybe<Array<WalletItemsWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** name_prefix field predicates */
  namePrefix?: InputMaybe<Scalars['String']>;
  namePrefixContains?: InputMaybe<Scalars['String']>;
  namePrefixContainsFold?: InputMaybe<Scalars['String']>;
  namePrefixEqualFold?: InputMaybe<Scalars['String']>;
  namePrefixGT?: InputMaybe<Scalars['String']>;
  namePrefixGTE?: InputMaybe<Scalars['String']>;
  namePrefixHasPrefix?: InputMaybe<Scalars['String']>;
  namePrefixHasSuffix?: InputMaybe<Scalars['String']>;
  namePrefixIn?: InputMaybe<Array<Scalars['String']>>;
  namePrefixIsNil?: InputMaybe<Scalars['Boolean']>;
  namePrefixLT?: InputMaybe<Scalars['String']>;
  namePrefixLTE?: InputMaybe<Scalars['String']>;
  namePrefixNEQ?: InputMaybe<Scalars['String']>;
  namePrefixNotIn?: InputMaybe<Array<Scalars['String']>>;
  namePrefixNotNil?: InputMaybe<Scalars['Boolean']>;
  /** name_suffix field predicates */
  nameSuffix?: InputMaybe<Scalars['String']>;
  nameSuffixContains?: InputMaybe<Scalars['String']>;
  nameSuffixContainsFold?: InputMaybe<Scalars['String']>;
  nameSuffixEqualFold?: InputMaybe<Scalars['String']>;
  nameSuffixGT?: InputMaybe<Scalars['String']>;
  nameSuffixGTE?: InputMaybe<Scalars['String']>;
  nameSuffixHasPrefix?: InputMaybe<Scalars['String']>;
  nameSuffixHasSuffix?: InputMaybe<Scalars['String']>;
  nameSuffixIn?: InputMaybe<Array<Scalars['String']>>;
  nameSuffixIsNil?: InputMaybe<Scalars['Boolean']>;
  nameSuffixLT?: InputMaybe<Scalars['String']>;
  nameSuffixLTE?: InputMaybe<Scalars['String']>;
  nameSuffixNEQ?: InputMaybe<Scalars['String']>;
  nameSuffixNotIn?: InputMaybe<Array<Scalars['String']>>;
  nameSuffixNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<ItemWhereInput>;
  or?: InputMaybe<Array<ItemWhereInput>>;
  /** suffix field predicates */
  suffix?: InputMaybe<Scalars['String']>;
  suffixContains?: InputMaybe<Scalars['String']>;
  suffixContainsFold?: InputMaybe<Scalars['String']>;
  suffixEqualFold?: InputMaybe<Scalars['String']>;
  suffixGT?: InputMaybe<Scalars['String']>;
  suffixGTE?: InputMaybe<Scalars['String']>;
  suffixHasPrefix?: InputMaybe<Scalars['String']>;
  suffixHasSuffix?: InputMaybe<Scalars['String']>;
  suffixIn?: InputMaybe<Array<Scalars['String']>>;
  suffixIsNil?: InputMaybe<Scalars['Boolean']>;
  suffixLT?: InputMaybe<Scalars['String']>;
  suffixLTE?: InputMaybe<Scalars['String']>;
  suffixNEQ?: InputMaybe<Scalars['String']>;
  suffixNotIn?: InputMaybe<Array<Scalars['String']>>;
  suffixNotNil?: InputMaybe<Scalars['Boolean']>;
  /** svg field predicates */
  svg?: InputMaybe<Scalars['String']>;
  svgContains?: InputMaybe<Scalars['String']>;
  svgContainsFold?: InputMaybe<Scalars['String']>;
  svgEqualFold?: InputMaybe<Scalars['String']>;
  svgGT?: InputMaybe<Scalars['String']>;
  svgGTE?: InputMaybe<Scalars['String']>;
  svgHasPrefix?: InputMaybe<Scalars['String']>;
  svgHasSuffix?: InputMaybe<Scalars['String']>;
  svgIn?: InputMaybe<Array<Scalars['String']>>;
  svgIsNil?: InputMaybe<Scalars['Boolean']>;
  svgLT?: InputMaybe<Scalars['String']>;
  svgLTE?: InputMaybe<Scalars['String']>;
  svgNEQ?: InputMaybe<Scalars['String']>;
  svgNotIn?: InputMaybe<Array<Scalars['String']>>;
  svgNotNil?: InputMaybe<Scalars['Boolean']>;
  /** tier field predicates */
  tier?: InputMaybe<ItemTier>;
  tierIn?: InputMaybe<Array<ItemTier>>;
  tierIsNil?: InputMaybe<Scalars['Boolean']>;
  tierNEQ?: InputMaybe<ItemTier>;
  tierNotIn?: InputMaybe<Array<ItemTier>>;
  tierNotNil?: InputMaybe<Scalars['Boolean']>;
  /** type field predicates */
  type?: InputMaybe<ItemType>;
  typeIn?: InputMaybe<Array<ItemType>>;
  typeNEQ?: InputMaybe<ItemType>;
  typeNotIn?: InputMaybe<Array<ItemType>>;
};

export type Listing = Node & {
  __typename?: 'Listing';
  active: Scalars['Boolean'];
  id: Scalars['ID'];
  inputs: Array<Maybe<Amount>>;
  order?: Maybe<OpenSeaOrder>;
  outputs: Array<Maybe<Amount>>;
  source?: Maybe<Source>;
};

export type ListingConnection = {
  __typename?: 'ListingConnection';
  edges?: Maybe<Array<Maybe<ListingEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type ListingEdge = {
  __typename?: 'ListingEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Listing>;
};

export type ListingOrder = {
  direction: OrderDirection;
};

/**
 * ListingWhereInput is used for filtering Listing objects.
 * Input was generated by ent.
 */
export type ListingWhereInput = {
  /** active field predicates */
  active?: InputMaybe<Scalars['Boolean']>;
  activeNEQ?: InputMaybe<Scalars['Boolean']>;
  and?: InputMaybe<Array<ListingWhereInput>>;
  /** dope edge predicates */
  hasDope?: InputMaybe<Scalars['Boolean']>;
  /** dope_lastsales edge predicates */
  hasDopeLastsales?: InputMaybe<Scalars['Boolean']>;
  hasDopeLastsalesWith?: InputMaybe<Array<DopeWhereInput>>;
  hasDopeWith?: InputMaybe<Array<DopeWhereInput>>;
  /** inputs edge predicates */
  hasInputs?: InputMaybe<Scalars['Boolean']>;
  hasInputsWith?: InputMaybe<Array<AmountWhereInput>>;
  /** outputs edge predicates */
  hasOutputs?: InputMaybe<Scalars['Boolean']>;
  hasOutputsWith?: InputMaybe<Array<AmountWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ListingWhereInput>;
  or?: InputMaybe<Array<ListingWhereInput>>;
  /** source field predicates */
  source?: InputMaybe<Source>;
  sourceIn?: InputMaybe<Array<Source>>;
  sourceNEQ?: InputMaybe<Source>;
  sourceNotIn?: InputMaybe<Array<Source>>;
};

export type Node = {
  id: Scalars['ID'];
};

export type OpenSeaOrder = {
  __typename?: 'OpenSeaOrder';
  calldata: Scalars['Bytes'];
  currentPrice: Scalars['String'];
  exchange: Scalars['Address'];
  expirationTime: Scalars['Long'];
  extra: Scalars['String'];
  feeMethod: Scalars['Int'];
  feeRecipient: Scalars['String'];
  howToCall: Scalars['Int'];
  listingTime: Scalars['Long'];
  maker: Scalars['Address'];
  makerProtocolFee: Scalars['String'];
  makerRelayerFee: Scalars['String'];
  r: Scalars['Bytes'];
  replacementPattern: Scalars['Bytes'];
  s: Scalars['Bytes'];
  saleKind: Scalars['Int'];
  salt: Scalars['String'];
  side: Scalars['Int'];
  staticExtradata: Scalars['Bytes'];
  staticTarget: Scalars['String'];
  target: Scalars['Address'];
  v: Scalars['Int'];
};

export enum OrderDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor?: Maybe<Scalars['Cursor']>;
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor?: Maybe<Scalars['Cursor']>;
};

export type Query = {
  __typename?: 'Query';
  dopes: DopeConnection;
  hustlers: HustlerConnection;
  items: ItemConnection;
  listings: ListingConnection;
  node?: Maybe<Node>;
  nodes: Array<Maybe<Node>>;
  search: SearchConnection;
  walletItems: WalletItemsConnection;
  wallets: WalletConnection;
};


export type QueryDopesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<DopeOrder>;
  where?: InputMaybe<DopeWhereInput>;
};


export type QueryHustlersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<HustlerOrder>;
  where?: InputMaybe<HustlerWhereInput>;
};


export type QueryItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ItemOrder>;
  where?: InputMaybe<ItemWhereInput>;
};


export type QueryListingsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ListingOrder>;
  where?: InputMaybe<ListingWhereInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};


export type QuerySearchArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SearchOrder>;
  query: Scalars['String'];
  where?: InputMaybe<SearchWhereInput>;
};


export type QueryWalletItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<WalletItemsOrder>;
  where?: InputMaybe<WalletItemsWhereInput>;
};


export type QueryWalletsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<WalletOrder>;
  where?: InputMaybe<WalletWhereInput>;
};

export type RlEs = {
  __typename?: 'RLEs';
  female: Scalars['String'];
  male: Scalars['String'];
};

export type SearchConnection = {
  __typename?: 'SearchConnection';
  edges?: Maybe<Array<Maybe<SearchEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type SearchEdge = {
  __typename?: 'SearchEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<SearchResult>;
};

/**
 * SearchIndexWhereInput is used for filtering SearchIndex objects.
 * Input was generated by ent.
 */
export type SearchIndexWhereInput = {
  and?: InputMaybe<Array<SearchIndexWhereInput>>;
  /** dope edge predicates */
  hasDope?: InputMaybe<Scalars['Boolean']>;
  hasDopeWith?: InputMaybe<Array<DopeWhereInput>>;
  /** hustler edge predicates */
  hasHustler?: InputMaybe<Scalars['Boolean']>;
  hasHustlerWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** item edge predicates */
  hasItem?: InputMaybe<Scalars['Boolean']>;
  hasItemWith?: InputMaybe<Array<ItemWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<SearchIndexWhereInput>;
  or?: InputMaybe<Array<SearchIndexWhereInput>>;
};

export type SearchOrder = {
  direction?: InputMaybe<OrderDirection>;
  field?: InputMaybe<SearchOrderField>;
};

export enum SearchOrderField {
  Greatness = 'GREATNESS',
  LastSalePrice = 'LAST_SALE_PRICE',
  SalePrice = 'SALE_PRICE'
}

export type SearchResult = Dope | Hustler | Item;

/**
 * SearchResultWhereInput is used for filtering SearchResult objects.
 * Input was generated by ent.
 */
export type SearchResultWhereInput = {
  and?: InputMaybe<Array<SearchResultWhereInput>>;
  /** dope edge predicates */
  hasDope?: InputMaybe<Scalars['Boolean']>;
  hasDopeWith?: InputMaybe<Array<DopeWhereInput>>;
  /** hustler edge predicates */
  hasHustler?: InputMaybe<Scalars['Boolean']>;
  hasHustlerWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** item edge predicates */
  hasItem?: InputMaybe<Scalars['Boolean']>;
  hasItemWith?: InputMaybe<Array<ItemWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<SearchResultWhereInput>;
  or?: InputMaybe<Array<SearchResultWhereInput>>;
};

export enum SearchType {
  Dope = 'DOPE',
  Hustler = 'HUSTLER',
  Item = 'ITEM'
}

/**
 * SearchWhereInput is used for filtering Search objects.
 * Input was generated by ent.
 */
export type SearchWhereInput = {
  and?: InputMaybe<Array<SearchWhereInput>>;
  /** claimed field predicates */
  claimed?: InputMaybe<Scalars['Boolean']>;
  claimedNEQ?: InputMaybe<Scalars['Boolean']>;
  /** greatness field predicates */
  greatness?: InputMaybe<Scalars['Int']>;
  greatnessGT?: InputMaybe<Scalars['Int']>;
  greatnessGTE?: InputMaybe<Scalars['Int']>;
  greatnessIn?: InputMaybe<Array<Scalars['Int']>>;
  greatnessIsNil?: InputMaybe<Scalars['Boolean']>;
  greatnessLT?: InputMaybe<Scalars['Int']>;
  greatnessLTE?: InputMaybe<Scalars['Int']>;
  greatnessNEQ?: InputMaybe<Scalars['Int']>;
  greatnessNotIn?: InputMaybe<Array<Scalars['Int']>>;
  greatnessNotNil?: InputMaybe<Scalars['Boolean']>;
  /** dope edge predicates */
  hasDope?: InputMaybe<Scalars['Boolean']>;
  hasDopeWith?: InputMaybe<Array<DopeWhereInput>>;
  /** hustler edge predicates */
  hasHustler?: InputMaybe<Scalars['Boolean']>;
  hasHustlerWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** item edge predicates */
  hasItem?: InputMaybe<Scalars['Boolean']>;
  hasItemWith?: InputMaybe<Array<ItemWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** last_sale_price field predicates */
  lastSalePrice?: InputMaybe<Scalars['BigInt']>;
  lastSalePriceGT?: InputMaybe<Scalars['BigInt']>;
  lastSalePriceGTE?: InputMaybe<Scalars['BigInt']>;
  lastSalePriceIn?: InputMaybe<Array<Scalars['BigInt']>>;
  lastSalePriceLT?: InputMaybe<Scalars['BigInt']>;
  lastSalePriceLTE?: InputMaybe<Scalars['BigInt']>;
  lastSalePriceNEQ?: InputMaybe<Scalars['BigInt']>;
  lastSalePriceNotIn?: InputMaybe<Array<Scalars['BigInt']>>;
  not?: InputMaybe<SearchWhereInput>;
  /** opened field predicates */
  opened?: InputMaybe<Scalars['Boolean']>;
  openedNEQ?: InputMaybe<Scalars['Boolean']>;
  or?: InputMaybe<Array<SearchWhereInput>>;
  /** sale_active field predicates */
  saleActive?: InputMaybe<Scalars['Boolean']>;
  saleActiveNEQ?: InputMaybe<Scalars['Boolean']>;
  /** sale_price field predicates */
  salePrice?: InputMaybe<Scalars['BigInt']>;
  salePriceGT?: InputMaybe<Scalars['BigInt']>;
  salePriceGTE?: InputMaybe<Scalars['BigInt']>;
  salePriceIn?: InputMaybe<Array<Scalars['BigInt']>>;
  salePriceLT?: InputMaybe<Scalars['BigInt']>;
  salePriceLTE?: InputMaybe<Scalars['BigInt']>;
  salePriceNEQ?: InputMaybe<Scalars['BigInt']>;
  salePriceNotIn?: InputMaybe<Array<Scalars['BigInt']>>;
  /** type field predicates */
  type?: InputMaybe<SearchType>;
  typeIn?: InputMaybe<Array<SearchType>>;
  typeNEQ?: InputMaybe<SearchType>;
  typeNotIn?: InputMaybe<Array<SearchType>>;
};

export enum Source {
  Opensea = 'OPENSEA',
  Swapmeet = 'SWAPMEET'
}

/**
 * SyncStateWhereInput is used for filtering SyncState objects.
 * Input was generated by ent.
 */
export type SyncStateWhereInput = {
  and?: InputMaybe<Array<SyncStateWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<SyncStateWhereInput>;
  or?: InputMaybe<Array<SyncStateWhereInput>>;
  /** start_block field predicates */
  startBlock?: InputMaybe<Scalars['Long']>;
  startBlockGT?: InputMaybe<Scalars['Long']>;
  startBlockGTE?: InputMaybe<Scalars['Long']>;
  startBlockIn?: InputMaybe<Array<Scalars['Long']>>;
  startBlockLT?: InputMaybe<Scalars['Long']>;
  startBlockLTE?: InputMaybe<Scalars['Long']>;
  startBlockNEQ?: InputMaybe<Scalars['Long']>;
  startBlockNotIn?: InputMaybe<Array<Scalars['Long']>>;
};

export type Token = Dope | Hustler | Item;

export type Wallet = Node & {
  __typename?: 'Wallet';
  dopes: Array<Dope>;
  hustlers: Array<Hustler>;
  id: Scalars['ID'];
  items: Array<WalletItems>;
  paper: Scalars['BigInt'];
};

export type WalletConnection = {
  __typename?: 'WalletConnection';
  edges?: Maybe<Array<Maybe<WalletEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type WalletEdge = {
  __typename?: 'WalletEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Wallet>;
};

export type WalletItems = Node & {
  __typename?: 'WalletItems';
  balance: Scalars['BigInt'];
  id: Scalars['ID'];
  item: Item;
  wallet: Wallet;
};

export type WalletItemsConnection = {
  __typename?: 'WalletItemsConnection';
  edges?: Maybe<Array<Maybe<WalletItemsEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type WalletItemsEdge = {
  __typename?: 'WalletItemsEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<WalletItems>;
};

export type WalletItemsOrder = {
  direction: OrderDirection;
};

/**
 * WalletItemsWhereInput is used for filtering WalletItems objects.
 * Input was generated by ent.
 */
export type WalletItemsWhereInput = {
  and?: InputMaybe<Array<WalletItemsWhereInput>>;
  /** balance field predicates */
  balance?: InputMaybe<Scalars['BigInt']>;
  balanceGT?: InputMaybe<Scalars['BigInt']>;
  balanceGTE?: InputMaybe<Scalars['BigInt']>;
  balanceIn?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceLT?: InputMaybe<Scalars['BigInt']>;
  balanceLTE?: InputMaybe<Scalars['BigInt']>;
  balanceNEQ?: InputMaybe<Scalars['BigInt']>;
  balanceNotIn?: InputMaybe<Array<Scalars['BigInt']>>;
  /** item edge predicates */
  hasItem?: InputMaybe<Scalars['Boolean']>;
  hasItemWith?: InputMaybe<Array<ItemWhereInput>>;
  /** wallet edge predicates */
  hasWallet?: InputMaybe<Scalars['Boolean']>;
  hasWalletWith?: InputMaybe<Array<WalletWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<WalletItemsWhereInput>;
  or?: InputMaybe<Array<WalletItemsWhereInput>>;
};

export type WalletOrder = {
  direction: OrderDirection;
};

/**
 * WalletWhereInput is used for filtering Wallet objects.
 * Input was generated by ent.
 */
export type WalletWhereInput = {
  and?: InputMaybe<Array<WalletWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** dopes edge predicates */
  hasDopes?: InputMaybe<Scalars['Boolean']>;
  hasDopesWith?: InputMaybe<Array<DopeWhereInput>>;
  /** hustlers edge predicates */
  hasHustlers?: InputMaybe<Scalars['Boolean']>;
  hasHustlersWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** items edge predicates */
  hasItems?: InputMaybe<Scalars['Boolean']>;
  hasItemsWith?: InputMaybe<Array<WalletItemsWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<WalletWhereInput>;
  or?: InputMaybe<Array<WalletWhereInput>>;
  /** paper field predicates */
  paper?: InputMaybe<Scalars['BigInt']>;
  paperGT?: InputMaybe<Scalars['BigInt']>;
  paperGTE?: InputMaybe<Scalars['BigInt']>;
  paperIn?: InputMaybe<Array<Scalars['BigInt']>>;
  paperLT?: InputMaybe<Scalars['BigInt']>;
  paperLTE?: InputMaybe<Scalars['BigInt']>;
  paperNEQ?: InputMaybe<Scalars['BigInt']>;
  paperNotIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type AllHustlersQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<HustlerOrder>;
  where?: InputMaybe<HustlerWhereInput>;
}>;


export type AllHustlersQuery = { __typename?: 'Query', hustlers: { __typename?: 'HustlerConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null | undefined, endCursor?: any | null | undefined }, edges?: Array<{ __typename?: 'HustlerEdge', cursor: any, node?: { __typename?: 'Hustler', id: string, name?: string | null | undefined, type: HustlerType, title?: string | null | undefined, color?: string | null | undefined, background?: string | null | undefined, age: any, svg?: string | null | undefined, sex: HustlerSex } | null | undefined } | null | undefined> | null | undefined } };

export type AllItemsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ItemOrder>;
  where?: InputMaybe<ItemWhereInput>;
}>;


export type AllItemsQuery = { __typename?: 'Query', items: { __typename?: 'ItemConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null | undefined, endCursor?: any | null | undefined }, edges?: Array<{ __typename?: 'ItemEdge', node?: { __typename?: 'Item', name: string, id: string, fullname: string, greatness: number, svg?: string | null | undefined, base?: { __typename?: 'Item', svg?: string | null | undefined } | null | undefined } | null | undefined } | null | undefined> | null | undefined } };

export type DopeListingQueryVariables = Exact<{
  where?: InputMaybe<DopeWhereInput>;
}>;


export type DopeListingQuery = { __typename?: 'Query', dopes: { __typename?: 'DopeConnection', totalCount: number, edges?: Array<{ __typename?: 'DopeEdge', cursor: any, node?: { __typename?: 'Dope', id: string, listings?: Array<{ __typename?: 'Listing', order?: { __typename?: 'OpenSeaOrder', maker: any, v: number, r: any, s: any, makerRelayerFee: string, makerProtocolFee: string, currentPrice: string, expirationTime: any, listingTime: any, salt: string, calldata: any } | null | undefined } | null | undefined> | null | undefined } | null | undefined } | null | undefined> | null | undefined } };

export type DopesQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<DopeOrder>;
  where?: InputMaybe<DopeWhereInput>;
}>;


export type DopesQuery = { __typename?: 'Query', dopes: { __typename?: 'DopeConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null | undefined, endCursor?: any | null | undefined }, edges?: Array<{ __typename?: 'DopeEdge', cursor: any, node?: { __typename?: 'Dope', id: string, claimed: boolean, opened: boolean, score: number, rank: number, lastSale?: { __typename?: 'Listing', inputs: Array<{ __typename?: 'Amount', amount: any, id: string, type: AmountType } | null | undefined> } | null | undefined, listings?: Array<{ __typename?: 'Listing', id: string, outputs: Array<{ __typename?: 'Amount', id: string, type: AmountType, amount: any, token?: { __typename?: 'Dope', id: string } | { __typename?: 'Hustler' } | { __typename?: 'Item' } | null | undefined } | null | undefined> } | null | undefined> | null | undefined, items: Array<{ __typename?: 'Item', id: string, fullname: string, type: ItemType, name: string, namePrefix?: string | null | undefined, nameSuffix?: string | null | undefined, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number }> } | null | undefined } | null | undefined> | null | undefined } };

export type HustlerQueryVariables = Exact<{
  where?: InputMaybe<HustlerWhereInput>;
}>;


export type HustlerQuery = { __typename?: 'Query', hustlers: { __typename?: 'HustlerConnection', edges?: Array<{ __typename?: 'HustlerEdge', node?: { __typename?: 'Hustler', id: string, title?: string | null | undefined, name?: string | null | undefined, type: HustlerType, color?: string | null | undefined, background?: string | null | undefined, age: any, sex: HustlerSex, viewbox: Array<number>, order: Array<number>, svg?: string | null | undefined, neck?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number, fullname: string, svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined, base?: { __typename?: 'Item', svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined } | null | undefined } | null | undefined, ring?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number, fullname: string, svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined, base?: { __typename?: 'Item', svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined } | null | undefined } | null | undefined, accessory?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number, fullname: string, svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined, base?: { __typename?: 'Item', svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined } | null | undefined } | null | undefined, body?: { __typename?: 'BodyPart', id: string, rle: string } | null | undefined, hair?: { __typename?: 'BodyPart', id: string, rle: string } | null | undefined, beard?: { __typename?: 'BodyPart', id: string, rle: string } | null | undefined, drug?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number, fullname: string, svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined, base?: { __typename?: 'Item', svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined } | null | undefined } | null | undefined, hand?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number, fullname: string, svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined, base?: { __typename?: 'Item', svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined } | null | undefined } | null | undefined, weapon?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number, fullname: string, svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined, base?: { __typename?: 'Item', svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined } | null | undefined } | null | undefined, clothes?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number, fullname: string, svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined, base?: { __typename?: 'Item', svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined } | null | undefined } | null | undefined, vehicle?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number, fullname: string, svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined, base?: { __typename?: 'Item', svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined } | null | undefined } | null | undefined, waist?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number, fullname: string, svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined, base?: { __typename?: 'Item', svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined } | null | undefined } | null | undefined, foot?: { __typename?: 'Item', id: string, type: ItemType, name: string, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number, fullname: string, svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined, base?: { __typename?: 'Item', svg?: string | null | undefined, rles?: { __typename?: 'RLEs', male: string, female: string } | null | undefined } | null | undefined } | null | undefined } | null | undefined } | null | undefined> | null | undefined } };

export type HustlersWalletQueryVariables = Exact<{
  where?: InputMaybe<WalletWhereInput>;
}>;


export type HustlersWalletQuery = { __typename?: 'Query', wallets: { __typename?: 'WalletConnection', edges?: Array<{ __typename?: 'WalletEdge', node?: { __typename?: 'Wallet', id: string, paper: any, hustlers: Array<{ __typename?: 'Hustler', id: string, title?: string | null | undefined, name?: string | null | undefined, type: HustlerType, color?: string | null | undefined, background?: string | null | undefined, age: any, svg?: string | null | undefined }> } | null | undefined } | null | undefined> | null | undefined } };

export type ItemQueryVariables = Exact<{
  where?: InputMaybe<ItemWhereInput>;
}>;


export type ItemQuery = { __typename?: 'Query', items: { __typename?: 'ItemConnection', edges?: Array<{ __typename?: 'ItemEdge', node?: { __typename?: 'Item', id: string, fullname: string, svg?: string | null | undefined, base?: { __typename?: 'Item', svg?: string | null | undefined } | null | undefined } | null | undefined } | null | undefined> | null | undefined } };

export type ProfileDopesQueryVariables = Exact<{
  where?: InputMaybe<DopeWhereInput>;
  first?: InputMaybe<Scalars['Int']>;
  after?: InputMaybe<Scalars['Cursor']>;
}>;


export type ProfileDopesQuery = { __typename?: 'Query', dopes: { __typename?: 'DopeConnection', totalCount: number, edges?: Array<{ __typename?: 'DopeEdge', node?: { __typename?: 'Dope', id: string, rank: number, score: number, claimed: boolean, opened: boolean, items: Array<{ __typename?: 'Item', id: string, fullname: string, type: ItemType, name: string, tier: ItemTier, greatness: number, count: number, suffix?: string | null | undefined }> } | null | undefined } | null | undefined> | null | undefined, pageInfo: { __typename?: 'PageInfo', endCursor?: any | null | undefined, hasNextPage: boolean } } };

export type ProfileHustlersQueryVariables = Exact<{
  where?: InputMaybe<HustlerWhereInput>;
  first?: InputMaybe<Scalars['Int']>;
  after?: InputMaybe<Scalars['Cursor']>;
}>;


export type ProfileHustlersQuery = { __typename?: 'Query', hustlers: { __typename?: 'HustlerConnection', totalCount: number, edges?: Array<{ __typename?: 'HustlerEdge', node?: { __typename?: 'Hustler', id: string, name?: string | null | undefined, svg?: string | null | undefined, title?: string | null | undefined, type: HustlerType } | null | undefined } | null | undefined> | null | undefined, pageInfo: { __typename?: 'PageInfo', endCursor?: any | null | undefined, hasNextPage: boolean } } };

export type ProfileGearQueryVariables = Exact<{
  where?: InputMaybe<WalletItemsWhereInput>;
  first?: InputMaybe<Scalars['Int']>;
  after?: InputMaybe<Scalars['Cursor']>;
}>;


export type ProfileGearQuery = { __typename?: 'Query', walletItems: { __typename?: 'WalletItemsConnection', totalCount: number, edges?: Array<{ __typename?: 'WalletItemsEdge', node?: { __typename?: 'WalletItems', id: string, balance: any, item: { __typename?: 'Item', id: string, count: number, fullname: string, name: string, svg?: string | null | undefined, suffix?: string | null | undefined, type: ItemType, base?: { __typename?: 'Item', svg?: string | null | undefined } | null | undefined } } | null | undefined } | null | undefined> | null | undefined, pageInfo: { __typename?: 'PageInfo', endCursor?: any | null | undefined, hasNextPage: boolean } } };

export type RenderDopeQueryVariables = Exact<{
  where?: InputMaybe<DopeWhereInput>;
}>;


export type RenderDopeQuery = { __typename?: 'Query', dopes: { __typename?: 'DopeConnection', totalCount: number, edges?: Array<{ __typename?: 'DopeEdge', cursor: any, node?: { __typename?: 'Dope', id: string, items: Array<{ __typename?: 'Item', id: string, type: ItemType, rles?: { __typename?: 'RLEs', female: string, male: string } | null | undefined, base?: { __typename?: 'Item', id: string, rles?: { __typename?: 'RLEs', female: string, male: string } | null | undefined } | null | undefined }> } | null | undefined } | null | undefined> | null | undefined } };

export type SearchDopeQueryVariables = Exact<{
  query: Scalars['String'];
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SearchOrder>;
  where?: InputMaybe<SearchWhereInput>;
}>;


export type SearchDopeQuery = { __typename?: 'Query', search: { __typename?: 'SearchConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null | undefined, endCursor?: any | null | undefined }, edges?: Array<{ __typename?: 'SearchEdge', node?: { __typename: 'Dope', id: string, claimed: boolean, opened: boolean, score: number, rank: number, listings?: Array<{ __typename?: 'Listing', id: string, active: boolean, inputs: Array<{ __typename?: 'Amount', amount: any, id: string, type: AmountType } | null | undefined>, order?: { __typename?: 'OpenSeaOrder', feeMethod: number, side: number, saleKind: number, howToCall: number, calldata: any, replacementPattern: any, staticTarget: string, staticExtradata: any, extra: string } | null | undefined } | null | undefined> | null | undefined, items: Array<{ __typename?: 'Item', id: string, fullname: string, type: ItemType, name: string, namePrefix?: string | null | undefined, nameSuffix?: string | null | undefined, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number }> } | { __typename?: 'Hustler' } | { __typename?: 'Item' } | null | undefined } | null | undefined> | null | undefined } };

export type WalletQueryVariables = Exact<{
  where?: InputMaybe<WalletWhereInput>;
}>;


export type WalletQuery = { __typename?: 'Query', wallets: { __typename?: 'WalletConnection', edges?: Array<{ __typename?: 'WalletEdge', node?: { __typename?: 'Wallet', id: string, paper: any, hustlers: Array<{ __typename?: 'Hustler', id: string, title?: string | null | undefined, name?: string | null | undefined }>, items: Array<{ __typename?: 'WalletItems', id: string, balance: any, item: { __typename?: 'Item', id: string, name: string } }>, dopes: Array<{ __typename?: 'Dope', id: string, claimed: boolean, opened: boolean, score: number, rank: number, items: Array<{ __typename?: 'Item', id: string, fullname: string, type: ItemType, name: string, namePrefix?: string | null | undefined, nameSuffix?: string | null | undefined, suffix?: string | null | undefined, augmented?: boolean | null | undefined, tier: ItemTier, greatness: number, count: number }> }> } | null | undefined } | null | undefined> | null | undefined } };


export const AllHustlersDocument = `
    query AllHustlers($after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: HustlerOrder, $where: HustlerWhereInput) {
  hustlers(
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: $where
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        name
        type
        title
        color
        background
        age
        svg
        sex
      }
    }
  }
}
    `;
export const useAllHustlersQuery = <
      TData = AllHustlersQuery,
      TError = unknown
    >(
      variables?: AllHustlersQueryVariables,
      options?: UseQueryOptions<AllHustlersQuery, TError, TData>
    ) =>
    useQuery<AllHustlersQuery, TError, TData>(
      variables === undefined ? ['AllHustlers'] : ['AllHustlers', variables],
      useFetchData<AllHustlersQuery, AllHustlersQueryVariables>(AllHustlersDocument).bind(null, variables),
      options
    );
export const useInfiniteAllHustlersQuery = <
      TData = AllHustlersQuery,
      TError = unknown
    >(
      variables?: AllHustlersQueryVariables,
      options?: UseInfiniteQueryOptions<AllHustlersQuery, TError, TData>
    ) =>{
    const query = useFetchData<AllHustlersQuery, AllHustlersQueryVariables>(AllHustlersDocument)
    return useInfiniteQuery<AllHustlersQuery, TError, TData>(
      variables === undefined ? ['AllHustlers.infinite'] : ['AllHustlers.infinite', variables],
      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      options
    )};

export const AllItemsDocument = `
    query AllItems($after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: ItemOrder, $where: ItemWhereInput) {
  items(
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: $where
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      node {
        name
        id
        fullname
        greatness
        svg
        base {
          svg
        }
      }
    }
  }
}
    `;
export const useAllItemsQuery = <
      TData = AllItemsQuery,
      TError = unknown
    >(
      variables?: AllItemsQueryVariables,
      options?: UseQueryOptions<AllItemsQuery, TError, TData>
    ) =>
    useQuery<AllItemsQuery, TError, TData>(
      variables === undefined ? ['AllItems'] : ['AllItems', variables],
      useFetchData<AllItemsQuery, AllItemsQueryVariables>(AllItemsDocument).bind(null, variables),
      options
    );
export const useInfiniteAllItemsQuery = <
      TData = AllItemsQuery,
      TError = unknown
    >(
      variables?: AllItemsQueryVariables,
      options?: UseInfiniteQueryOptions<AllItemsQuery, TError, TData>
    ) =>{
    const query = useFetchData<AllItemsQuery, AllItemsQueryVariables>(AllItemsDocument)
    return useInfiniteQuery<AllItemsQuery, TError, TData>(
      variables === undefined ? ['AllItems.infinite'] : ['AllItems.infinite', variables],
      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      options
    )};

export const DopeListingDocument = `
    query DopeListing($where: DopeWhereInput) {
  dopes(where: $where) {
    totalCount
    edges {
      cursor
      node {
        id
        listings {
          order {
            maker
            v
            r
            s
            makerRelayerFee
            makerProtocolFee
            currentPrice
            expirationTime
            listingTime
            salt
            calldata
          }
        }
      }
    }
  }
}
    `;
export const useDopeListingQuery = <
      TData = DopeListingQuery,
      TError = unknown
    >(
      variables?: DopeListingQueryVariables,
      options?: UseQueryOptions<DopeListingQuery, TError, TData>
    ) =>
    useQuery<DopeListingQuery, TError, TData>(
      variables === undefined ? ['DopeListing'] : ['DopeListing', variables],
      useFetchData<DopeListingQuery, DopeListingQueryVariables>(DopeListingDocument).bind(null, variables),
      options
    );
export const useInfiniteDopeListingQuery = <
      TData = DopeListingQuery,
      TError = unknown
    >(
      variables?: DopeListingQueryVariables,
      options?: UseInfiniteQueryOptions<DopeListingQuery, TError, TData>
    ) =>{
    const query = useFetchData<DopeListingQuery, DopeListingQueryVariables>(DopeListingDocument)
    return useInfiniteQuery<DopeListingQuery, TError, TData>(
      variables === undefined ? ['DopeListing.infinite'] : ['DopeListing.infinite', variables],
      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      options
    )};

export const DopesDocument = `
    query Dopes($after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: DopeOrder, $where: DopeWhereInput) {
  dopes(
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: $where
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        claimed
        opened
        score
        rank
        lastSale {
          inputs {
            amount
            id
            type
          }
        }
        listings {
          id
          outputs {
            id
            type
            amount
            token {
              ... on Dope {
                id
              }
            }
          }
        }
        items {
          id
          fullname
          type
          name
          namePrefix
          nameSuffix
          suffix
          augmented
          tier
          greatness
          count
        }
      }
    }
  }
}
    `;
export const useDopesQuery = <
      TData = DopesQuery,
      TError = unknown
    >(
      variables?: DopesQueryVariables,
      options?: UseQueryOptions<DopesQuery, TError, TData>
    ) =>
    useQuery<DopesQuery, TError, TData>(
      variables === undefined ? ['Dopes'] : ['Dopes', variables],
      useFetchData<DopesQuery, DopesQueryVariables>(DopesDocument).bind(null, variables),
      options
    );
export const useInfiniteDopesQuery = <
      TData = DopesQuery,
      TError = unknown
    >(
      variables?: DopesQueryVariables,
      options?: UseInfiniteQueryOptions<DopesQuery, TError, TData>
    ) =>{
    const query = useFetchData<DopesQuery, DopesQueryVariables>(DopesDocument)
    return useInfiniteQuery<DopesQuery, TError, TData>(
      variables === undefined ? ['Dopes.infinite'] : ['Dopes.infinite', variables],
      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      options
    )};

export const HustlerDocument = `
    query Hustler($where: HustlerWhereInput) {
  hustlers(where: $where) {
    edges {
      node {
        id
        title
        name
        type
        title
        color
        background
        age
        neck {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        sex
        viewbox
        order
        ring {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        accessory {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        svg
        body {
          id
          rle
        }
        hair {
          id
          rle
        }
        beard {
          id
          rle
        }
        drug {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        hand {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        weapon {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        clothes {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        vehicle {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        waist {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        foot {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
      }
    }
  }
}
    `;
export const useHustlerQuery = <
      TData = HustlerQuery,
      TError = unknown
    >(
      variables?: HustlerQueryVariables,
      options?: UseQueryOptions<HustlerQuery, TError, TData>
    ) =>
    useQuery<HustlerQuery, TError, TData>(
      variables === undefined ? ['Hustler'] : ['Hustler', variables],
      useFetchData<HustlerQuery, HustlerQueryVariables>(HustlerDocument).bind(null, variables),
      options
    );
export const useInfiniteHustlerQuery = <
      TData = HustlerQuery,
      TError = unknown
    >(
      variables?: HustlerQueryVariables,
      options?: UseInfiniteQueryOptions<HustlerQuery, TError, TData>
    ) =>{
    const query = useFetchData<HustlerQuery, HustlerQueryVariables>(HustlerDocument)
    return useInfiniteQuery<HustlerQuery, TError, TData>(
      variables === undefined ? ['Hustler.infinite'] : ['Hustler.infinite', variables],
      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      options
    )};

export const HustlersWalletDocument = `
    query HustlersWallet($where: WalletWhereInput) {
  wallets(where: $where) {
    edges {
      node {
        id
        paper
        hustlers {
          id
          title
          name
          type
          color
          background
          age
          svg
        }
      }
    }
  }
}
    `;
export const useHustlersWalletQuery = <
      TData = HustlersWalletQuery,
      TError = unknown
    >(
      variables?: HustlersWalletQueryVariables,
      options?: UseQueryOptions<HustlersWalletQuery, TError, TData>
    ) =>
    useQuery<HustlersWalletQuery, TError, TData>(
      variables === undefined ? ['HustlersWallet'] : ['HustlersWallet', variables],
      useFetchData<HustlersWalletQuery, HustlersWalletQueryVariables>(HustlersWalletDocument).bind(null, variables),
      options
    );
export const useInfiniteHustlersWalletQuery = <
      TData = HustlersWalletQuery,
      TError = unknown
    >(
      variables?: HustlersWalletQueryVariables,
      options?: UseInfiniteQueryOptions<HustlersWalletQuery, TError, TData>
    ) =>{
    const query = useFetchData<HustlersWalletQuery, HustlersWalletQueryVariables>(HustlersWalletDocument)
    return useInfiniteQuery<HustlersWalletQuery, TError, TData>(
      variables === undefined ? ['HustlersWallet.infinite'] : ['HustlersWallet.infinite', variables],
      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      options
    )};

export const ItemDocument = `
    query Item($where: ItemWhereInput) {
  items(where: $where) {
    edges {
      node {
        id
        fullname
        svg
        base {
          svg
        }
      }
    }
  }
}
    `;
export const useItemQuery = <
      TData = ItemQuery,
      TError = unknown
    >(
      variables?: ItemQueryVariables,
      options?: UseQueryOptions<ItemQuery, TError, TData>
    ) =>
    useQuery<ItemQuery, TError, TData>(
      variables === undefined ? ['Item'] : ['Item', variables],
      useFetchData<ItemQuery, ItemQueryVariables>(ItemDocument).bind(null, variables),
      options
    );
export const useInfiniteItemQuery = <
      TData = ItemQuery,
      TError = unknown
    >(
      variables?: ItemQueryVariables,
      options?: UseInfiniteQueryOptions<ItemQuery, TError, TData>
    ) =>{
    const query = useFetchData<ItemQuery, ItemQueryVariables>(ItemDocument)
    return useInfiniteQuery<ItemQuery, TError, TData>(
      variables === undefined ? ['Item.infinite'] : ['Item.infinite', variables],
      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      options
    )};

export const ProfileDopesDocument = `
    query ProfileDopes($where: DopeWhereInput, $first: Int, $after: Cursor) {
  dopes(where: $where, first: $first, after: $after) {
    totalCount
    edges {
      node {
        id
        id
        rank
        score
        claimed
        opened
        items {
          id
          fullname
          type
          name
          tier
          greatness
          count
          suffix
        }
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}
    `;
export const useProfileDopesQuery = <
      TData = ProfileDopesQuery,
      TError = unknown
    >(
      variables?: ProfileDopesQueryVariables,
      options?: UseQueryOptions<ProfileDopesQuery, TError, TData>
    ) =>
    useQuery<ProfileDopesQuery, TError, TData>(
      variables === undefined ? ['ProfileDopes'] : ['ProfileDopes', variables],
      useFetchData<ProfileDopesQuery, ProfileDopesQueryVariables>(ProfileDopesDocument).bind(null, variables),
      options
    );
export const useInfiniteProfileDopesQuery = <
      TData = ProfileDopesQuery,
      TError = unknown
    >(
      variables?: ProfileDopesQueryVariables,
      options?: UseInfiniteQueryOptions<ProfileDopesQuery, TError, TData>
    ) =>{
    const query = useFetchData<ProfileDopesQuery, ProfileDopesQueryVariables>(ProfileDopesDocument)
    return useInfiniteQuery<ProfileDopesQuery, TError, TData>(
      variables === undefined ? ['ProfileDopes.infinite'] : ['ProfileDopes.infinite', variables],
      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      options
    )};

export const ProfileHustlersDocument = `
    query ProfileHustlers($where: HustlerWhereInput, $first: Int, $after: Cursor) {
  hustlers(where: $where, first: $first, after: $after) {
    totalCount
    edges {
      node {
        id
        name
        svg
        title
        type
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}
    `;
export const useProfileHustlersQuery = <
      TData = ProfileHustlersQuery,
      TError = unknown
    >(
      variables?: ProfileHustlersQueryVariables,
      options?: UseQueryOptions<ProfileHustlersQuery, TError, TData>
    ) =>
    useQuery<ProfileHustlersQuery, TError, TData>(
      variables === undefined ? ['ProfileHustlers'] : ['ProfileHustlers', variables],
      useFetchData<ProfileHustlersQuery, ProfileHustlersQueryVariables>(ProfileHustlersDocument).bind(null, variables),
      options
    );
export const useInfiniteProfileHustlersQuery = <
      TData = ProfileHustlersQuery,
      TError = unknown
    >(
      variables?: ProfileHustlersQueryVariables,
      options?: UseInfiniteQueryOptions<ProfileHustlersQuery, TError, TData>
    ) =>{
    const query = useFetchData<ProfileHustlersQuery, ProfileHustlersQueryVariables>(ProfileHustlersDocument)
    return useInfiniteQuery<ProfileHustlersQuery, TError, TData>(
      variables === undefined ? ['ProfileHustlers.infinite'] : ['ProfileHustlers.infinite', variables],
      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      options
    )};

export const ProfileGearDocument = `
    query ProfileGear($where: WalletItemsWhereInput, $first: Int, $after: Cursor) {
  walletItems(where: $where, first: $first, after: $after) {
    totalCount
    edges {
      node {
        id
        balance
        item {
          id
          count
          fullname
          name
          svg
          suffix
          type
          base {
            svg
          }
        }
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}
    `;
export const useProfileGearQuery = <
      TData = ProfileGearQuery,
      TError = unknown
    >(
      variables?: ProfileGearQueryVariables,
      options?: UseQueryOptions<ProfileGearQuery, TError, TData>
    ) =>
    useQuery<ProfileGearQuery, TError, TData>(
      variables === undefined ? ['ProfileGear'] : ['ProfileGear', variables],
      useFetchData<ProfileGearQuery, ProfileGearQueryVariables>(ProfileGearDocument).bind(null, variables),
      options
    );
export const useInfiniteProfileGearQuery = <
      TData = ProfileGearQuery,
      TError = unknown
    >(
      variables?: ProfileGearQueryVariables,
      options?: UseInfiniteQueryOptions<ProfileGearQuery, TError, TData>
    ) =>{
    const query = useFetchData<ProfileGearQuery, ProfileGearQueryVariables>(ProfileGearDocument)
    return useInfiniteQuery<ProfileGearQuery, TError, TData>(
      variables === undefined ? ['ProfileGear.infinite'] : ['ProfileGear.infinite', variables],
      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      options
    )};

export const RenderDopeDocument = `
    query RenderDope($where: DopeWhereInput) {
  dopes(where: $where) {
    totalCount
    edges {
      cursor
      node {
        id
        items {
          id
          type
          rles {
            female
            male
          }
          base {
            id
            rles {
              female
              male
            }
          }
        }
      }
    }
  }
}
    `;
export const useRenderDopeQuery = <
      TData = RenderDopeQuery,
      TError = unknown
    >(
      variables?: RenderDopeQueryVariables,
      options?: UseQueryOptions<RenderDopeQuery, TError, TData>
    ) =>
    useQuery<RenderDopeQuery, TError, TData>(
      variables === undefined ? ['RenderDope'] : ['RenderDope', variables],
      useFetchData<RenderDopeQuery, RenderDopeQueryVariables>(RenderDopeDocument).bind(null, variables),
      options
    );
export const useInfiniteRenderDopeQuery = <
      TData = RenderDopeQuery,
      TError = unknown
    >(
      variables?: RenderDopeQueryVariables,
      options?: UseInfiniteQueryOptions<RenderDopeQuery, TError, TData>
    ) =>{
    const query = useFetchData<RenderDopeQuery, RenderDopeQueryVariables>(RenderDopeDocument)
    return useInfiniteQuery<RenderDopeQuery, TError, TData>(
      variables === undefined ? ['RenderDope.infinite'] : ['RenderDope.infinite', variables],
      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      options
    )};

export const SearchDopeDocument = `
    query SearchDope($query: String!, $after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: SearchOrder, $where: SearchWhereInput) {
  search(
    query: $query
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: $where
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      node {
        ... on Dope {
          __typename
          id
          claimed
          opened
          score
          rank
          listings {
            id
            active
            inputs {
              amount
              id
              type
            }
            order {
              feeMethod
              side
              saleKind
              howToCall
              calldata
              replacementPattern
              staticTarget
              staticExtradata
              extra
            }
          }
          items {
            id
            fullname
            type
            name
            namePrefix
            nameSuffix
            suffix
            augmented
            tier
            greatness
            count
          }
        }
      }
    }
  }
}
    `;
export const useSearchDopeQuery = <
      TData = SearchDopeQuery,
      TError = unknown
    >(
      variables: SearchDopeQueryVariables,
      options?: UseQueryOptions<SearchDopeQuery, TError, TData>
    ) =>
    useQuery<SearchDopeQuery, TError, TData>(
      ['SearchDope', variables],
      useFetchData<SearchDopeQuery, SearchDopeQueryVariables>(SearchDopeDocument).bind(null, variables),
      options
    );
export const useInfiniteSearchDopeQuery = <
      TData = SearchDopeQuery,
      TError = unknown
    >(
      variables: SearchDopeQueryVariables,
      options?: UseInfiniteQueryOptions<SearchDopeQuery, TError, TData>
    ) =>{
    const query = useFetchData<SearchDopeQuery, SearchDopeQueryVariables>(SearchDopeDocument)
    return useInfiniteQuery<SearchDopeQuery, TError, TData>(
      ['SearchDope.infinite', variables],
      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      options
    )};

export const WalletDocument = `
    query Wallet($where: WalletWhereInput) {
  wallets(where: $where) {
    edges {
      node {
        id
        paper
        hustlers {
          id
          title
          name
        }
        items {
          id
          balance
          item {
            id
            name
          }
        }
        dopes {
          id
          claimed
          opened
          score
          rank
          items {
            id
            fullname
            type
            name
            namePrefix
            nameSuffix
            suffix
            augmented
            tier
            greatness
            count
          }
        }
      }
    }
  }
}
    `;
export const useWalletQuery = <
      TData = WalletQuery,
      TError = unknown
    >(
      variables?: WalletQueryVariables,
      options?: UseQueryOptions<WalletQuery, TError, TData>
    ) =>
    useQuery<WalletQuery, TError, TData>(
      variables === undefined ? ['Wallet'] : ['Wallet', variables],
      useFetchData<WalletQuery, WalletQueryVariables>(WalletDocument).bind(null, variables),
      options
    );
export const useInfiniteWalletQuery = <
      TData = WalletQuery,
      TError = unknown
    >(
      variables?: WalletQueryVariables,
      options?: UseInfiniteQueryOptions<WalletQuery, TError, TData>
    ) =>{
    const query = useFetchData<WalletQuery, WalletQueryVariables>(WalletDocument)
    return useInfiniteQuery<WalletQuery, TError, TData>(
      variables === undefined ? ['Wallet.infinite'] : ['Wallet.infinite', variables],
      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      options
    )};
