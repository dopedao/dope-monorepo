// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/dopedao/dope-monorepo/packages/api/ent/dope"
	"github.com/dopedao/dope-monorepo/packages/api/ent/hustler"
	"github.com/dopedao/dope-monorepo/packages/api/ent/item"
	"github.com/dopedao/dope-monorepo/packages/api/ent/predicate"
	"github.com/dopedao/dope-monorepo/packages/api/ent/schema"
	"github.com/dopedao/dope-monorepo/packages/api/ent/search"
	"github.com/dopedao/dope-monorepo/packages/api/ent/walletitems"
)

// ItemUpdate is the builder for updating Item entities.
type ItemUpdate struct {
	config
	hooks    []Hook
	mutation *ItemMutation
}

// Where appends a list predicates to the ItemUpdate builder.
func (iu *ItemUpdate) Where(ps ...predicate.Item) *ItemUpdate {
	iu.mutation.Where(ps...)
	return iu
}

// SetCount sets the "count" field.
func (iu *ItemUpdate) SetCount(i int) *ItemUpdate {
	iu.mutation.ResetCount()
	iu.mutation.SetCount(i)
	return iu
}

// SetNillableCount sets the "count" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableCount(i *int) *ItemUpdate {
	if i != nil {
		iu.SetCount(*i)
	}
	return iu
}

// AddCount adds i to the "count" field.
func (iu *ItemUpdate) AddCount(i int) *ItemUpdate {
	iu.mutation.AddCount(i)
	return iu
}

// ClearCount clears the value of the "count" field.
func (iu *ItemUpdate) ClearCount() *ItemUpdate {
	iu.mutation.ClearCount()
	return iu
}

// SetTier sets the "tier" field.
func (iu *ItemUpdate) SetTier(i item.Tier) *ItemUpdate {
	iu.mutation.SetTier(i)
	return iu
}

// SetNillableTier sets the "tier" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableTier(i *item.Tier) *ItemUpdate {
	if i != nil {
		iu.SetTier(*i)
	}
	return iu
}

// ClearTier clears the value of the "tier" field.
func (iu *ItemUpdate) ClearTier() *ItemUpdate {
	iu.mutation.ClearTier()
	return iu
}

// SetGreatness sets the "greatness" field.
func (iu *ItemUpdate) SetGreatness(i int) *ItemUpdate {
	iu.mutation.ResetGreatness()
	iu.mutation.SetGreatness(i)
	return iu
}

// SetNillableGreatness sets the "greatness" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableGreatness(i *int) *ItemUpdate {
	if i != nil {
		iu.SetGreatness(*i)
	}
	return iu
}

// AddGreatness adds i to the "greatness" field.
func (iu *ItemUpdate) AddGreatness(i int) *ItemUpdate {
	iu.mutation.AddGreatness(i)
	return iu
}

// ClearGreatness clears the value of the "greatness" field.
func (iu *ItemUpdate) ClearGreatness() *ItemUpdate {
	iu.mutation.ClearGreatness()
	return iu
}

// SetRles sets the "rles" field.
func (iu *ItemUpdate) SetRles(se schema.RLEs) *ItemUpdate {
	iu.mutation.SetRles(se)
	return iu
}

// SetNillableRles sets the "rles" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableRles(se *schema.RLEs) *ItemUpdate {
	if se != nil {
		iu.SetRles(*se)
	}
	return iu
}

// ClearRles clears the value of the "rles" field.
func (iu *ItemUpdate) ClearRles() *ItemUpdate {
	iu.mutation.ClearRles()
	return iu
}

// SetSvg sets the "svg" field.
func (iu *ItemUpdate) SetSvg(s string) *ItemUpdate {
	iu.mutation.SetSvg(s)
	return iu
}

// SetNillableSvg sets the "svg" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableSvg(s *string) *ItemUpdate {
	if s != nil {
		iu.SetSvg(*s)
	}
	return iu
}

// ClearSvg clears the value of the "svg" field.
func (iu *ItemUpdate) ClearSvg() *ItemUpdate {
	iu.mutation.ClearSvg()
	return iu
}

// AddWalletIDs adds the "wallets" edge to the WalletItems entity by IDs.
func (iu *ItemUpdate) AddWalletIDs(ids ...string) *ItemUpdate {
	iu.mutation.AddWalletIDs(ids...)
	return iu
}

// AddWallets adds the "wallets" edges to the WalletItems entity.
func (iu *ItemUpdate) AddWallets(w ...*WalletItems) *ItemUpdate {
	ids := make([]string, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return iu.AddWalletIDs(ids...)
}

// AddDopeIDs adds the "dopes" edge to the Dope entity by IDs.
func (iu *ItemUpdate) AddDopeIDs(ids ...string) *ItemUpdate {
	iu.mutation.AddDopeIDs(ids...)
	return iu
}

// AddDopes adds the "dopes" edges to the Dope entity.
func (iu *ItemUpdate) AddDopes(d ...*Dope) *ItemUpdate {
	ids := make([]string, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return iu.AddDopeIDs(ids...)
}

// AddHustlerWeaponIDs adds the "hustler_weapons" edge to the Hustler entity by IDs.
func (iu *ItemUpdate) AddHustlerWeaponIDs(ids ...string) *ItemUpdate {
	iu.mutation.AddHustlerWeaponIDs(ids...)
	return iu
}

// AddHustlerWeapons adds the "hustler_weapons" edges to the Hustler entity.
func (iu *ItemUpdate) AddHustlerWeapons(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.AddHustlerWeaponIDs(ids...)
}

// AddHustlerClotheIDs adds the "hustler_clothes" edge to the Hustler entity by IDs.
func (iu *ItemUpdate) AddHustlerClotheIDs(ids ...string) *ItemUpdate {
	iu.mutation.AddHustlerClotheIDs(ids...)
	return iu
}

// AddHustlerClothes adds the "hustler_clothes" edges to the Hustler entity.
func (iu *ItemUpdate) AddHustlerClothes(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.AddHustlerClotheIDs(ids...)
}

// AddHustlerVehicleIDs adds the "hustler_vehicles" edge to the Hustler entity by IDs.
func (iu *ItemUpdate) AddHustlerVehicleIDs(ids ...string) *ItemUpdate {
	iu.mutation.AddHustlerVehicleIDs(ids...)
	return iu
}

// AddHustlerVehicles adds the "hustler_vehicles" edges to the Hustler entity.
func (iu *ItemUpdate) AddHustlerVehicles(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.AddHustlerVehicleIDs(ids...)
}

// AddHustlerWaistIDs adds the "hustler_waists" edge to the Hustler entity by IDs.
func (iu *ItemUpdate) AddHustlerWaistIDs(ids ...string) *ItemUpdate {
	iu.mutation.AddHustlerWaistIDs(ids...)
	return iu
}

// AddHustlerWaists adds the "hustler_waists" edges to the Hustler entity.
func (iu *ItemUpdate) AddHustlerWaists(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.AddHustlerWaistIDs(ids...)
}

// AddHustlerFeetIDs adds the "hustler_feet" edge to the Hustler entity by IDs.
func (iu *ItemUpdate) AddHustlerFeetIDs(ids ...string) *ItemUpdate {
	iu.mutation.AddHustlerFeetIDs(ids...)
	return iu
}

// AddHustlerFeet adds the "hustler_feet" edges to the Hustler entity.
func (iu *ItemUpdate) AddHustlerFeet(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.AddHustlerFeetIDs(ids...)
}

// AddHustlerHandIDs adds the "hustler_hands" edge to the Hustler entity by IDs.
func (iu *ItemUpdate) AddHustlerHandIDs(ids ...string) *ItemUpdate {
	iu.mutation.AddHustlerHandIDs(ids...)
	return iu
}

// AddHustlerHands adds the "hustler_hands" edges to the Hustler entity.
func (iu *ItemUpdate) AddHustlerHands(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.AddHustlerHandIDs(ids...)
}

// AddHustlerDrugIDs adds the "hustler_drugs" edge to the Hustler entity by IDs.
func (iu *ItemUpdate) AddHustlerDrugIDs(ids ...string) *ItemUpdate {
	iu.mutation.AddHustlerDrugIDs(ids...)
	return iu
}

// AddHustlerDrugs adds the "hustler_drugs" edges to the Hustler entity.
func (iu *ItemUpdate) AddHustlerDrugs(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.AddHustlerDrugIDs(ids...)
}

// AddHustlerNeckIDs adds the "hustler_necks" edge to the Hustler entity by IDs.
func (iu *ItemUpdate) AddHustlerNeckIDs(ids ...string) *ItemUpdate {
	iu.mutation.AddHustlerNeckIDs(ids...)
	return iu
}

// AddHustlerNecks adds the "hustler_necks" edges to the Hustler entity.
func (iu *ItemUpdate) AddHustlerNecks(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.AddHustlerNeckIDs(ids...)
}

// AddHustlerRingIDs adds the "hustler_rings" edge to the Hustler entity by IDs.
func (iu *ItemUpdate) AddHustlerRingIDs(ids ...string) *ItemUpdate {
	iu.mutation.AddHustlerRingIDs(ids...)
	return iu
}

// AddHustlerRings adds the "hustler_rings" edges to the Hustler entity.
func (iu *ItemUpdate) AddHustlerRings(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.AddHustlerRingIDs(ids...)
}

// AddHustlerAccessoryIDs adds the "hustler_accessories" edge to the Hustler entity by IDs.
func (iu *ItemUpdate) AddHustlerAccessoryIDs(ids ...string) *ItemUpdate {
	iu.mutation.AddHustlerAccessoryIDs(ids...)
	return iu
}

// AddHustlerAccessories adds the "hustler_accessories" edges to the Hustler entity.
func (iu *ItemUpdate) AddHustlerAccessories(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.AddHustlerAccessoryIDs(ids...)
}

// SetBaseID sets the "base" edge to the Item entity by ID.
func (iu *ItemUpdate) SetBaseID(id string) *ItemUpdate {
	iu.mutation.SetBaseID(id)
	return iu
}

// SetNillableBaseID sets the "base" edge to the Item entity by ID if the given value is not nil.
func (iu *ItemUpdate) SetNillableBaseID(id *string) *ItemUpdate {
	if id != nil {
		iu = iu.SetBaseID(*id)
	}
	return iu
}

// SetBase sets the "base" edge to the Item entity.
func (iu *ItemUpdate) SetBase(i *Item) *ItemUpdate {
	return iu.SetBaseID(i.ID)
}

// AddDerivativeIDs adds the "derivative" edge to the Item entity by IDs.
func (iu *ItemUpdate) AddDerivativeIDs(ids ...string) *ItemUpdate {
	iu.mutation.AddDerivativeIDs(ids...)
	return iu
}

// AddDerivative adds the "derivative" edges to the Item entity.
func (iu *ItemUpdate) AddDerivative(i ...*Item) *ItemUpdate {
	ids := make([]string, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.AddDerivativeIDs(ids...)
}

// SetIndexID sets the "index" edge to the Search entity by ID.
func (iu *ItemUpdate) SetIndexID(id string) *ItemUpdate {
	iu.mutation.SetIndexID(id)
	return iu
}

// SetNillableIndexID sets the "index" edge to the Search entity by ID if the given value is not nil.
func (iu *ItemUpdate) SetNillableIndexID(id *string) *ItemUpdate {
	if id != nil {
		iu = iu.SetIndexID(*id)
	}
	return iu
}

// SetIndex sets the "index" edge to the Search entity.
func (iu *ItemUpdate) SetIndex(s *Search) *ItemUpdate {
	return iu.SetIndexID(s.ID)
}

// Mutation returns the ItemMutation object of the builder.
func (iu *ItemUpdate) Mutation() *ItemMutation {
	return iu.mutation
}

// ClearWallets clears all "wallets" edges to the WalletItems entity.
func (iu *ItemUpdate) ClearWallets() *ItemUpdate {
	iu.mutation.ClearWallets()
	return iu
}

// RemoveWalletIDs removes the "wallets" edge to WalletItems entities by IDs.
func (iu *ItemUpdate) RemoveWalletIDs(ids ...string) *ItemUpdate {
	iu.mutation.RemoveWalletIDs(ids...)
	return iu
}

// RemoveWallets removes "wallets" edges to WalletItems entities.
func (iu *ItemUpdate) RemoveWallets(w ...*WalletItems) *ItemUpdate {
	ids := make([]string, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return iu.RemoveWalletIDs(ids...)
}

// ClearDopes clears all "dopes" edges to the Dope entity.
func (iu *ItemUpdate) ClearDopes() *ItemUpdate {
	iu.mutation.ClearDopes()
	return iu
}

// RemoveDopeIDs removes the "dopes" edge to Dope entities by IDs.
func (iu *ItemUpdate) RemoveDopeIDs(ids ...string) *ItemUpdate {
	iu.mutation.RemoveDopeIDs(ids...)
	return iu
}

// RemoveDopes removes "dopes" edges to Dope entities.
func (iu *ItemUpdate) RemoveDopes(d ...*Dope) *ItemUpdate {
	ids := make([]string, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return iu.RemoveDopeIDs(ids...)
}

// ClearHustlerWeapons clears all "hustler_weapons" edges to the Hustler entity.
func (iu *ItemUpdate) ClearHustlerWeapons() *ItemUpdate {
	iu.mutation.ClearHustlerWeapons()
	return iu
}

// RemoveHustlerWeaponIDs removes the "hustler_weapons" edge to Hustler entities by IDs.
func (iu *ItemUpdate) RemoveHustlerWeaponIDs(ids ...string) *ItemUpdate {
	iu.mutation.RemoveHustlerWeaponIDs(ids...)
	return iu
}

// RemoveHustlerWeapons removes "hustler_weapons" edges to Hustler entities.
func (iu *ItemUpdate) RemoveHustlerWeapons(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.RemoveHustlerWeaponIDs(ids...)
}

// ClearHustlerClothes clears all "hustler_clothes" edges to the Hustler entity.
func (iu *ItemUpdate) ClearHustlerClothes() *ItemUpdate {
	iu.mutation.ClearHustlerClothes()
	return iu
}

// RemoveHustlerClotheIDs removes the "hustler_clothes" edge to Hustler entities by IDs.
func (iu *ItemUpdate) RemoveHustlerClotheIDs(ids ...string) *ItemUpdate {
	iu.mutation.RemoveHustlerClotheIDs(ids...)
	return iu
}

// RemoveHustlerClothes removes "hustler_clothes" edges to Hustler entities.
func (iu *ItemUpdate) RemoveHustlerClothes(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.RemoveHustlerClotheIDs(ids...)
}

// ClearHustlerVehicles clears all "hustler_vehicles" edges to the Hustler entity.
func (iu *ItemUpdate) ClearHustlerVehicles() *ItemUpdate {
	iu.mutation.ClearHustlerVehicles()
	return iu
}

// RemoveHustlerVehicleIDs removes the "hustler_vehicles" edge to Hustler entities by IDs.
func (iu *ItemUpdate) RemoveHustlerVehicleIDs(ids ...string) *ItemUpdate {
	iu.mutation.RemoveHustlerVehicleIDs(ids...)
	return iu
}

// RemoveHustlerVehicles removes "hustler_vehicles" edges to Hustler entities.
func (iu *ItemUpdate) RemoveHustlerVehicles(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.RemoveHustlerVehicleIDs(ids...)
}

// ClearHustlerWaists clears all "hustler_waists" edges to the Hustler entity.
func (iu *ItemUpdate) ClearHustlerWaists() *ItemUpdate {
	iu.mutation.ClearHustlerWaists()
	return iu
}

// RemoveHustlerWaistIDs removes the "hustler_waists" edge to Hustler entities by IDs.
func (iu *ItemUpdate) RemoveHustlerWaistIDs(ids ...string) *ItemUpdate {
	iu.mutation.RemoveHustlerWaistIDs(ids...)
	return iu
}

// RemoveHustlerWaists removes "hustler_waists" edges to Hustler entities.
func (iu *ItemUpdate) RemoveHustlerWaists(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.RemoveHustlerWaistIDs(ids...)
}

// ClearHustlerFeet clears all "hustler_feet" edges to the Hustler entity.
func (iu *ItemUpdate) ClearHustlerFeet() *ItemUpdate {
	iu.mutation.ClearHustlerFeet()
	return iu
}

// RemoveHustlerFeetIDs removes the "hustler_feet" edge to Hustler entities by IDs.
func (iu *ItemUpdate) RemoveHustlerFeetIDs(ids ...string) *ItemUpdate {
	iu.mutation.RemoveHustlerFeetIDs(ids...)
	return iu
}

// RemoveHustlerFeet removes "hustler_feet" edges to Hustler entities.
func (iu *ItemUpdate) RemoveHustlerFeet(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.RemoveHustlerFeetIDs(ids...)
}

// ClearHustlerHands clears all "hustler_hands" edges to the Hustler entity.
func (iu *ItemUpdate) ClearHustlerHands() *ItemUpdate {
	iu.mutation.ClearHustlerHands()
	return iu
}

// RemoveHustlerHandIDs removes the "hustler_hands" edge to Hustler entities by IDs.
func (iu *ItemUpdate) RemoveHustlerHandIDs(ids ...string) *ItemUpdate {
	iu.mutation.RemoveHustlerHandIDs(ids...)
	return iu
}

// RemoveHustlerHands removes "hustler_hands" edges to Hustler entities.
func (iu *ItemUpdate) RemoveHustlerHands(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.RemoveHustlerHandIDs(ids...)
}

// ClearHustlerDrugs clears all "hustler_drugs" edges to the Hustler entity.
func (iu *ItemUpdate) ClearHustlerDrugs() *ItemUpdate {
	iu.mutation.ClearHustlerDrugs()
	return iu
}

// RemoveHustlerDrugIDs removes the "hustler_drugs" edge to Hustler entities by IDs.
func (iu *ItemUpdate) RemoveHustlerDrugIDs(ids ...string) *ItemUpdate {
	iu.mutation.RemoveHustlerDrugIDs(ids...)
	return iu
}

// RemoveHustlerDrugs removes "hustler_drugs" edges to Hustler entities.
func (iu *ItemUpdate) RemoveHustlerDrugs(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.RemoveHustlerDrugIDs(ids...)
}

// ClearHustlerNecks clears all "hustler_necks" edges to the Hustler entity.
func (iu *ItemUpdate) ClearHustlerNecks() *ItemUpdate {
	iu.mutation.ClearHustlerNecks()
	return iu
}

// RemoveHustlerNeckIDs removes the "hustler_necks" edge to Hustler entities by IDs.
func (iu *ItemUpdate) RemoveHustlerNeckIDs(ids ...string) *ItemUpdate {
	iu.mutation.RemoveHustlerNeckIDs(ids...)
	return iu
}

// RemoveHustlerNecks removes "hustler_necks" edges to Hustler entities.
func (iu *ItemUpdate) RemoveHustlerNecks(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.RemoveHustlerNeckIDs(ids...)
}

// ClearHustlerRings clears all "hustler_rings" edges to the Hustler entity.
func (iu *ItemUpdate) ClearHustlerRings() *ItemUpdate {
	iu.mutation.ClearHustlerRings()
	return iu
}

// RemoveHustlerRingIDs removes the "hustler_rings" edge to Hustler entities by IDs.
func (iu *ItemUpdate) RemoveHustlerRingIDs(ids ...string) *ItemUpdate {
	iu.mutation.RemoveHustlerRingIDs(ids...)
	return iu
}

// RemoveHustlerRings removes "hustler_rings" edges to Hustler entities.
func (iu *ItemUpdate) RemoveHustlerRings(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.RemoveHustlerRingIDs(ids...)
}

// ClearHustlerAccessories clears all "hustler_accessories" edges to the Hustler entity.
func (iu *ItemUpdate) ClearHustlerAccessories() *ItemUpdate {
	iu.mutation.ClearHustlerAccessories()
	return iu
}

// RemoveHustlerAccessoryIDs removes the "hustler_accessories" edge to Hustler entities by IDs.
func (iu *ItemUpdate) RemoveHustlerAccessoryIDs(ids ...string) *ItemUpdate {
	iu.mutation.RemoveHustlerAccessoryIDs(ids...)
	return iu
}

// RemoveHustlerAccessories removes "hustler_accessories" edges to Hustler entities.
func (iu *ItemUpdate) RemoveHustlerAccessories(h ...*Hustler) *ItemUpdate {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iu.RemoveHustlerAccessoryIDs(ids...)
}

// ClearBase clears the "base" edge to the Item entity.
func (iu *ItemUpdate) ClearBase() *ItemUpdate {
	iu.mutation.ClearBase()
	return iu
}

// ClearDerivative clears all "derivative" edges to the Item entity.
func (iu *ItemUpdate) ClearDerivative() *ItemUpdate {
	iu.mutation.ClearDerivative()
	return iu
}

// RemoveDerivativeIDs removes the "derivative" edge to Item entities by IDs.
func (iu *ItemUpdate) RemoveDerivativeIDs(ids ...string) *ItemUpdate {
	iu.mutation.RemoveDerivativeIDs(ids...)
	return iu
}

// RemoveDerivative removes "derivative" edges to Item entities.
func (iu *ItemUpdate) RemoveDerivative(i ...*Item) *ItemUpdate {
	ids := make([]string, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.RemoveDerivativeIDs(ids...)
}

// ClearIndex clears the "index" edge to the Search entity.
func (iu *ItemUpdate) ClearIndex() *ItemUpdate {
	iu.mutation.ClearIndex()
	return iu
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (iu *ItemUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	if len(iu.hooks) == 0 {
		if err = iu.check(); err != nil {
			return 0, err
		}
		affected, err = iu.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*ItemMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = iu.check(); err != nil {
				return 0, err
			}
			iu.mutation = mutation
			affected, err = iu.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(iu.hooks) - 1; i >= 0; i-- {
			if iu.hooks[i] == nil {
				return 0, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = iu.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, iu.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (iu *ItemUpdate) SaveX(ctx context.Context) int {
	affected, err := iu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (iu *ItemUpdate) Exec(ctx context.Context) error {
	_, err := iu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (iu *ItemUpdate) ExecX(ctx context.Context) {
	if err := iu.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (iu *ItemUpdate) check() error {
	if v, ok := iu.mutation.Tier(); ok {
		if err := item.TierValidator(v); err != nil {
			return &ValidationError{Name: "tier", err: fmt.Errorf(`ent: validator failed for field "Item.tier": %w`, err)}
		}
	}
	return nil
}

func (iu *ItemUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   item.Table,
			Columns: item.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: item.FieldID,
			},
		},
	}
	if ps := iu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if iu.mutation.NamePrefixCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: item.FieldNamePrefix,
		})
	}
	if iu.mutation.NameSuffixCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: item.FieldNameSuffix,
		})
	}
	if iu.mutation.SuffixCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: item.FieldSuffix,
		})
	}
	if iu.mutation.AugmentedCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Column: item.FieldAugmented,
		})
	}
	if value, ok := iu.mutation.Count(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: item.FieldCount,
		})
	}
	if value, ok := iu.mutation.AddedCount(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: item.FieldCount,
		})
	}
	if iu.mutation.CountCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: item.FieldCount,
		})
	}
	if value, ok := iu.mutation.Tier(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: item.FieldTier,
		})
	}
	if iu.mutation.TierCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Column: item.FieldTier,
		})
	}
	if value, ok := iu.mutation.Greatness(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: item.FieldGreatness,
		})
	}
	if value, ok := iu.mutation.AddedGreatness(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: item.FieldGreatness,
		})
	}
	if iu.mutation.GreatnessCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: item.FieldGreatness,
		})
	}
	if value, ok := iu.mutation.Rles(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Value:  value,
			Column: item.FieldRles,
		})
	}
	if iu.mutation.RlesCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Column: item.FieldRles,
		})
	}
	if value, ok := iu.mutation.Svg(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: item.FieldSvg,
		})
	}
	if iu.mutation.SvgCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: item.FieldSvg,
		})
	}
	if iu.mutation.WalletsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.WalletsTable,
			Columns: []string{item.WalletsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: walletitems.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedWalletsIDs(); len(nodes) > 0 && !iu.mutation.WalletsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.WalletsTable,
			Columns: []string{item.WalletsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: walletitems.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.WalletsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.WalletsTable,
			Columns: []string{item.WalletsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: walletitems.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.DopesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   item.DopesTable,
			Columns: item.DopesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: dope.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedDopesIDs(); len(nodes) > 0 && !iu.mutation.DopesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   item.DopesTable,
			Columns: item.DopesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: dope.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.DopesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   item.DopesTable,
			Columns: item.DopesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: dope.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.HustlerWeaponsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerWeaponsTable,
			Columns: []string{item.HustlerWeaponsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedHustlerWeaponsIDs(); len(nodes) > 0 && !iu.mutation.HustlerWeaponsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerWeaponsTable,
			Columns: []string{item.HustlerWeaponsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.HustlerWeaponsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerWeaponsTable,
			Columns: []string{item.HustlerWeaponsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.HustlerClothesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerClothesTable,
			Columns: []string{item.HustlerClothesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedHustlerClothesIDs(); len(nodes) > 0 && !iu.mutation.HustlerClothesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerClothesTable,
			Columns: []string{item.HustlerClothesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.HustlerClothesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerClothesTable,
			Columns: []string{item.HustlerClothesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.HustlerVehiclesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerVehiclesTable,
			Columns: []string{item.HustlerVehiclesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedHustlerVehiclesIDs(); len(nodes) > 0 && !iu.mutation.HustlerVehiclesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerVehiclesTable,
			Columns: []string{item.HustlerVehiclesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.HustlerVehiclesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerVehiclesTable,
			Columns: []string{item.HustlerVehiclesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.HustlerWaistsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerWaistsTable,
			Columns: []string{item.HustlerWaistsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedHustlerWaistsIDs(); len(nodes) > 0 && !iu.mutation.HustlerWaistsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerWaistsTable,
			Columns: []string{item.HustlerWaistsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.HustlerWaistsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerWaistsTable,
			Columns: []string{item.HustlerWaistsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.HustlerFeetCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerFeetTable,
			Columns: []string{item.HustlerFeetColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedHustlerFeetIDs(); len(nodes) > 0 && !iu.mutation.HustlerFeetCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerFeetTable,
			Columns: []string{item.HustlerFeetColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.HustlerFeetIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerFeetTable,
			Columns: []string{item.HustlerFeetColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.HustlerHandsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerHandsTable,
			Columns: []string{item.HustlerHandsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedHustlerHandsIDs(); len(nodes) > 0 && !iu.mutation.HustlerHandsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerHandsTable,
			Columns: []string{item.HustlerHandsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.HustlerHandsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerHandsTable,
			Columns: []string{item.HustlerHandsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.HustlerDrugsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerDrugsTable,
			Columns: []string{item.HustlerDrugsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedHustlerDrugsIDs(); len(nodes) > 0 && !iu.mutation.HustlerDrugsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerDrugsTable,
			Columns: []string{item.HustlerDrugsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.HustlerDrugsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerDrugsTable,
			Columns: []string{item.HustlerDrugsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.HustlerNecksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerNecksTable,
			Columns: []string{item.HustlerNecksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedHustlerNecksIDs(); len(nodes) > 0 && !iu.mutation.HustlerNecksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerNecksTable,
			Columns: []string{item.HustlerNecksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.HustlerNecksIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerNecksTable,
			Columns: []string{item.HustlerNecksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.HustlerRingsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerRingsTable,
			Columns: []string{item.HustlerRingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedHustlerRingsIDs(); len(nodes) > 0 && !iu.mutation.HustlerRingsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerRingsTable,
			Columns: []string{item.HustlerRingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.HustlerRingsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerRingsTable,
			Columns: []string{item.HustlerRingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.HustlerAccessoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerAccessoriesTable,
			Columns: []string{item.HustlerAccessoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedHustlerAccessoriesIDs(); len(nodes) > 0 && !iu.mutation.HustlerAccessoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerAccessoriesTable,
			Columns: []string{item.HustlerAccessoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.HustlerAccessoriesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerAccessoriesTable,
			Columns: []string{item.HustlerAccessoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.BaseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   item.BaseTable,
			Columns: []string{item.BaseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: item.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.BaseIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   item.BaseTable,
			Columns: []string{item.BaseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: item.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.DerivativeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.DerivativeTable,
			Columns: []string{item.DerivativeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: item.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedDerivativeIDs(); len(nodes) > 0 && !iu.mutation.DerivativeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.DerivativeTable,
			Columns: []string{item.DerivativeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: item.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.DerivativeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.DerivativeTable,
			Columns: []string{item.DerivativeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: item.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.IndexCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   item.IndexTable,
			Columns: []string{item.IndexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: search.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.IndexIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   item.IndexTable,
			Columns: []string{item.IndexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: search.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, iu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{item.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return 0, err
	}
	return n, nil
}

// ItemUpdateOne is the builder for updating a single Item entity.
type ItemUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *ItemMutation
}

// SetCount sets the "count" field.
func (iuo *ItemUpdateOne) SetCount(i int) *ItemUpdateOne {
	iuo.mutation.ResetCount()
	iuo.mutation.SetCount(i)
	return iuo
}

// SetNillableCount sets the "count" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableCount(i *int) *ItemUpdateOne {
	if i != nil {
		iuo.SetCount(*i)
	}
	return iuo
}

// AddCount adds i to the "count" field.
func (iuo *ItemUpdateOne) AddCount(i int) *ItemUpdateOne {
	iuo.mutation.AddCount(i)
	return iuo
}

// ClearCount clears the value of the "count" field.
func (iuo *ItemUpdateOne) ClearCount() *ItemUpdateOne {
	iuo.mutation.ClearCount()
	return iuo
}

// SetTier sets the "tier" field.
func (iuo *ItemUpdateOne) SetTier(i item.Tier) *ItemUpdateOne {
	iuo.mutation.SetTier(i)
	return iuo
}

// SetNillableTier sets the "tier" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableTier(i *item.Tier) *ItemUpdateOne {
	if i != nil {
		iuo.SetTier(*i)
	}
	return iuo
}

// ClearTier clears the value of the "tier" field.
func (iuo *ItemUpdateOne) ClearTier() *ItemUpdateOne {
	iuo.mutation.ClearTier()
	return iuo
}

// SetGreatness sets the "greatness" field.
func (iuo *ItemUpdateOne) SetGreatness(i int) *ItemUpdateOne {
	iuo.mutation.ResetGreatness()
	iuo.mutation.SetGreatness(i)
	return iuo
}

// SetNillableGreatness sets the "greatness" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableGreatness(i *int) *ItemUpdateOne {
	if i != nil {
		iuo.SetGreatness(*i)
	}
	return iuo
}

// AddGreatness adds i to the "greatness" field.
func (iuo *ItemUpdateOne) AddGreatness(i int) *ItemUpdateOne {
	iuo.mutation.AddGreatness(i)
	return iuo
}

// ClearGreatness clears the value of the "greatness" field.
func (iuo *ItemUpdateOne) ClearGreatness() *ItemUpdateOne {
	iuo.mutation.ClearGreatness()
	return iuo
}

// SetRles sets the "rles" field.
func (iuo *ItemUpdateOne) SetRles(se schema.RLEs) *ItemUpdateOne {
	iuo.mutation.SetRles(se)
	return iuo
}

// SetNillableRles sets the "rles" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableRles(se *schema.RLEs) *ItemUpdateOne {
	if se != nil {
		iuo.SetRles(*se)
	}
	return iuo
}

// ClearRles clears the value of the "rles" field.
func (iuo *ItemUpdateOne) ClearRles() *ItemUpdateOne {
	iuo.mutation.ClearRles()
	return iuo
}

// SetSvg sets the "svg" field.
func (iuo *ItemUpdateOne) SetSvg(s string) *ItemUpdateOne {
	iuo.mutation.SetSvg(s)
	return iuo
}

// SetNillableSvg sets the "svg" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableSvg(s *string) *ItemUpdateOne {
	if s != nil {
		iuo.SetSvg(*s)
	}
	return iuo
}

// ClearSvg clears the value of the "svg" field.
func (iuo *ItemUpdateOne) ClearSvg() *ItemUpdateOne {
	iuo.mutation.ClearSvg()
	return iuo
}

// AddWalletIDs adds the "wallets" edge to the WalletItems entity by IDs.
func (iuo *ItemUpdateOne) AddWalletIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.AddWalletIDs(ids...)
	return iuo
}

// AddWallets adds the "wallets" edges to the WalletItems entity.
func (iuo *ItemUpdateOne) AddWallets(w ...*WalletItems) *ItemUpdateOne {
	ids := make([]string, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return iuo.AddWalletIDs(ids...)
}

// AddDopeIDs adds the "dopes" edge to the Dope entity by IDs.
func (iuo *ItemUpdateOne) AddDopeIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.AddDopeIDs(ids...)
	return iuo
}

// AddDopes adds the "dopes" edges to the Dope entity.
func (iuo *ItemUpdateOne) AddDopes(d ...*Dope) *ItemUpdateOne {
	ids := make([]string, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return iuo.AddDopeIDs(ids...)
}

// AddHustlerWeaponIDs adds the "hustler_weapons" edge to the Hustler entity by IDs.
func (iuo *ItemUpdateOne) AddHustlerWeaponIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.AddHustlerWeaponIDs(ids...)
	return iuo
}

// AddHustlerWeapons adds the "hustler_weapons" edges to the Hustler entity.
func (iuo *ItemUpdateOne) AddHustlerWeapons(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.AddHustlerWeaponIDs(ids...)
}

// AddHustlerClotheIDs adds the "hustler_clothes" edge to the Hustler entity by IDs.
func (iuo *ItemUpdateOne) AddHustlerClotheIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.AddHustlerClotheIDs(ids...)
	return iuo
}

// AddHustlerClothes adds the "hustler_clothes" edges to the Hustler entity.
func (iuo *ItemUpdateOne) AddHustlerClothes(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.AddHustlerClotheIDs(ids...)
}

// AddHustlerVehicleIDs adds the "hustler_vehicles" edge to the Hustler entity by IDs.
func (iuo *ItemUpdateOne) AddHustlerVehicleIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.AddHustlerVehicleIDs(ids...)
	return iuo
}

// AddHustlerVehicles adds the "hustler_vehicles" edges to the Hustler entity.
func (iuo *ItemUpdateOne) AddHustlerVehicles(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.AddHustlerVehicleIDs(ids...)
}

// AddHustlerWaistIDs adds the "hustler_waists" edge to the Hustler entity by IDs.
func (iuo *ItemUpdateOne) AddHustlerWaistIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.AddHustlerWaistIDs(ids...)
	return iuo
}

// AddHustlerWaists adds the "hustler_waists" edges to the Hustler entity.
func (iuo *ItemUpdateOne) AddHustlerWaists(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.AddHustlerWaistIDs(ids...)
}

// AddHustlerFeetIDs adds the "hustler_feet" edge to the Hustler entity by IDs.
func (iuo *ItemUpdateOne) AddHustlerFeetIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.AddHustlerFeetIDs(ids...)
	return iuo
}

// AddHustlerFeet adds the "hustler_feet" edges to the Hustler entity.
func (iuo *ItemUpdateOne) AddHustlerFeet(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.AddHustlerFeetIDs(ids...)
}

// AddHustlerHandIDs adds the "hustler_hands" edge to the Hustler entity by IDs.
func (iuo *ItemUpdateOne) AddHustlerHandIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.AddHustlerHandIDs(ids...)
	return iuo
}

// AddHustlerHands adds the "hustler_hands" edges to the Hustler entity.
func (iuo *ItemUpdateOne) AddHustlerHands(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.AddHustlerHandIDs(ids...)
}

// AddHustlerDrugIDs adds the "hustler_drugs" edge to the Hustler entity by IDs.
func (iuo *ItemUpdateOne) AddHustlerDrugIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.AddHustlerDrugIDs(ids...)
	return iuo
}

// AddHustlerDrugs adds the "hustler_drugs" edges to the Hustler entity.
func (iuo *ItemUpdateOne) AddHustlerDrugs(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.AddHustlerDrugIDs(ids...)
}

// AddHustlerNeckIDs adds the "hustler_necks" edge to the Hustler entity by IDs.
func (iuo *ItemUpdateOne) AddHustlerNeckIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.AddHustlerNeckIDs(ids...)
	return iuo
}

// AddHustlerNecks adds the "hustler_necks" edges to the Hustler entity.
func (iuo *ItemUpdateOne) AddHustlerNecks(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.AddHustlerNeckIDs(ids...)
}

// AddHustlerRingIDs adds the "hustler_rings" edge to the Hustler entity by IDs.
func (iuo *ItemUpdateOne) AddHustlerRingIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.AddHustlerRingIDs(ids...)
	return iuo
}

// AddHustlerRings adds the "hustler_rings" edges to the Hustler entity.
func (iuo *ItemUpdateOne) AddHustlerRings(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.AddHustlerRingIDs(ids...)
}

// AddHustlerAccessoryIDs adds the "hustler_accessories" edge to the Hustler entity by IDs.
func (iuo *ItemUpdateOne) AddHustlerAccessoryIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.AddHustlerAccessoryIDs(ids...)
	return iuo
}

// AddHustlerAccessories adds the "hustler_accessories" edges to the Hustler entity.
func (iuo *ItemUpdateOne) AddHustlerAccessories(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.AddHustlerAccessoryIDs(ids...)
}

// SetBaseID sets the "base" edge to the Item entity by ID.
func (iuo *ItemUpdateOne) SetBaseID(id string) *ItemUpdateOne {
	iuo.mutation.SetBaseID(id)
	return iuo
}

// SetNillableBaseID sets the "base" edge to the Item entity by ID if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableBaseID(id *string) *ItemUpdateOne {
	if id != nil {
		iuo = iuo.SetBaseID(*id)
	}
	return iuo
}

// SetBase sets the "base" edge to the Item entity.
func (iuo *ItemUpdateOne) SetBase(i *Item) *ItemUpdateOne {
	return iuo.SetBaseID(i.ID)
}

// AddDerivativeIDs adds the "derivative" edge to the Item entity by IDs.
func (iuo *ItemUpdateOne) AddDerivativeIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.AddDerivativeIDs(ids...)
	return iuo
}

// AddDerivative adds the "derivative" edges to the Item entity.
func (iuo *ItemUpdateOne) AddDerivative(i ...*Item) *ItemUpdateOne {
	ids := make([]string, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.AddDerivativeIDs(ids...)
}

// SetIndexID sets the "index" edge to the Search entity by ID.
func (iuo *ItemUpdateOne) SetIndexID(id string) *ItemUpdateOne {
	iuo.mutation.SetIndexID(id)
	return iuo
}

// SetNillableIndexID sets the "index" edge to the Search entity by ID if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableIndexID(id *string) *ItemUpdateOne {
	if id != nil {
		iuo = iuo.SetIndexID(*id)
	}
	return iuo
}

// SetIndex sets the "index" edge to the Search entity.
func (iuo *ItemUpdateOne) SetIndex(s *Search) *ItemUpdateOne {
	return iuo.SetIndexID(s.ID)
}

// Mutation returns the ItemMutation object of the builder.
func (iuo *ItemUpdateOne) Mutation() *ItemMutation {
	return iuo.mutation
}

// ClearWallets clears all "wallets" edges to the WalletItems entity.
func (iuo *ItemUpdateOne) ClearWallets() *ItemUpdateOne {
	iuo.mutation.ClearWallets()
	return iuo
}

// RemoveWalletIDs removes the "wallets" edge to WalletItems entities by IDs.
func (iuo *ItemUpdateOne) RemoveWalletIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.RemoveWalletIDs(ids...)
	return iuo
}

// RemoveWallets removes "wallets" edges to WalletItems entities.
func (iuo *ItemUpdateOne) RemoveWallets(w ...*WalletItems) *ItemUpdateOne {
	ids := make([]string, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return iuo.RemoveWalletIDs(ids...)
}

// ClearDopes clears all "dopes" edges to the Dope entity.
func (iuo *ItemUpdateOne) ClearDopes() *ItemUpdateOne {
	iuo.mutation.ClearDopes()
	return iuo
}

// RemoveDopeIDs removes the "dopes" edge to Dope entities by IDs.
func (iuo *ItemUpdateOne) RemoveDopeIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.RemoveDopeIDs(ids...)
	return iuo
}

// RemoveDopes removes "dopes" edges to Dope entities.
func (iuo *ItemUpdateOne) RemoveDopes(d ...*Dope) *ItemUpdateOne {
	ids := make([]string, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return iuo.RemoveDopeIDs(ids...)
}

// ClearHustlerWeapons clears all "hustler_weapons" edges to the Hustler entity.
func (iuo *ItemUpdateOne) ClearHustlerWeapons() *ItemUpdateOne {
	iuo.mutation.ClearHustlerWeapons()
	return iuo
}

// RemoveHustlerWeaponIDs removes the "hustler_weapons" edge to Hustler entities by IDs.
func (iuo *ItemUpdateOne) RemoveHustlerWeaponIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.RemoveHustlerWeaponIDs(ids...)
	return iuo
}

// RemoveHustlerWeapons removes "hustler_weapons" edges to Hustler entities.
func (iuo *ItemUpdateOne) RemoveHustlerWeapons(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.RemoveHustlerWeaponIDs(ids...)
}

// ClearHustlerClothes clears all "hustler_clothes" edges to the Hustler entity.
func (iuo *ItemUpdateOne) ClearHustlerClothes() *ItemUpdateOne {
	iuo.mutation.ClearHustlerClothes()
	return iuo
}

// RemoveHustlerClotheIDs removes the "hustler_clothes" edge to Hustler entities by IDs.
func (iuo *ItemUpdateOne) RemoveHustlerClotheIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.RemoveHustlerClotheIDs(ids...)
	return iuo
}

// RemoveHustlerClothes removes "hustler_clothes" edges to Hustler entities.
func (iuo *ItemUpdateOne) RemoveHustlerClothes(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.RemoveHustlerClotheIDs(ids...)
}

// ClearHustlerVehicles clears all "hustler_vehicles" edges to the Hustler entity.
func (iuo *ItemUpdateOne) ClearHustlerVehicles() *ItemUpdateOne {
	iuo.mutation.ClearHustlerVehicles()
	return iuo
}

// RemoveHustlerVehicleIDs removes the "hustler_vehicles" edge to Hustler entities by IDs.
func (iuo *ItemUpdateOne) RemoveHustlerVehicleIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.RemoveHustlerVehicleIDs(ids...)
	return iuo
}

// RemoveHustlerVehicles removes "hustler_vehicles" edges to Hustler entities.
func (iuo *ItemUpdateOne) RemoveHustlerVehicles(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.RemoveHustlerVehicleIDs(ids...)
}

// ClearHustlerWaists clears all "hustler_waists" edges to the Hustler entity.
func (iuo *ItemUpdateOne) ClearHustlerWaists() *ItemUpdateOne {
	iuo.mutation.ClearHustlerWaists()
	return iuo
}

// RemoveHustlerWaistIDs removes the "hustler_waists" edge to Hustler entities by IDs.
func (iuo *ItemUpdateOne) RemoveHustlerWaistIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.RemoveHustlerWaistIDs(ids...)
	return iuo
}

// RemoveHustlerWaists removes "hustler_waists" edges to Hustler entities.
func (iuo *ItemUpdateOne) RemoveHustlerWaists(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.RemoveHustlerWaistIDs(ids...)
}

// ClearHustlerFeet clears all "hustler_feet" edges to the Hustler entity.
func (iuo *ItemUpdateOne) ClearHustlerFeet() *ItemUpdateOne {
	iuo.mutation.ClearHustlerFeet()
	return iuo
}

// RemoveHustlerFeetIDs removes the "hustler_feet" edge to Hustler entities by IDs.
func (iuo *ItemUpdateOne) RemoveHustlerFeetIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.RemoveHustlerFeetIDs(ids...)
	return iuo
}

// RemoveHustlerFeet removes "hustler_feet" edges to Hustler entities.
func (iuo *ItemUpdateOne) RemoveHustlerFeet(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.RemoveHustlerFeetIDs(ids...)
}

// ClearHustlerHands clears all "hustler_hands" edges to the Hustler entity.
func (iuo *ItemUpdateOne) ClearHustlerHands() *ItemUpdateOne {
	iuo.mutation.ClearHustlerHands()
	return iuo
}

// RemoveHustlerHandIDs removes the "hustler_hands" edge to Hustler entities by IDs.
func (iuo *ItemUpdateOne) RemoveHustlerHandIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.RemoveHustlerHandIDs(ids...)
	return iuo
}

// RemoveHustlerHands removes "hustler_hands" edges to Hustler entities.
func (iuo *ItemUpdateOne) RemoveHustlerHands(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.RemoveHustlerHandIDs(ids...)
}

// ClearHustlerDrugs clears all "hustler_drugs" edges to the Hustler entity.
func (iuo *ItemUpdateOne) ClearHustlerDrugs() *ItemUpdateOne {
	iuo.mutation.ClearHustlerDrugs()
	return iuo
}

// RemoveHustlerDrugIDs removes the "hustler_drugs" edge to Hustler entities by IDs.
func (iuo *ItemUpdateOne) RemoveHustlerDrugIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.RemoveHustlerDrugIDs(ids...)
	return iuo
}

// RemoveHustlerDrugs removes "hustler_drugs" edges to Hustler entities.
func (iuo *ItemUpdateOne) RemoveHustlerDrugs(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.RemoveHustlerDrugIDs(ids...)
}

// ClearHustlerNecks clears all "hustler_necks" edges to the Hustler entity.
func (iuo *ItemUpdateOne) ClearHustlerNecks() *ItemUpdateOne {
	iuo.mutation.ClearHustlerNecks()
	return iuo
}

// RemoveHustlerNeckIDs removes the "hustler_necks" edge to Hustler entities by IDs.
func (iuo *ItemUpdateOne) RemoveHustlerNeckIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.RemoveHustlerNeckIDs(ids...)
	return iuo
}

// RemoveHustlerNecks removes "hustler_necks" edges to Hustler entities.
func (iuo *ItemUpdateOne) RemoveHustlerNecks(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.RemoveHustlerNeckIDs(ids...)
}

// ClearHustlerRings clears all "hustler_rings" edges to the Hustler entity.
func (iuo *ItemUpdateOne) ClearHustlerRings() *ItemUpdateOne {
	iuo.mutation.ClearHustlerRings()
	return iuo
}

// RemoveHustlerRingIDs removes the "hustler_rings" edge to Hustler entities by IDs.
func (iuo *ItemUpdateOne) RemoveHustlerRingIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.RemoveHustlerRingIDs(ids...)
	return iuo
}

// RemoveHustlerRings removes "hustler_rings" edges to Hustler entities.
func (iuo *ItemUpdateOne) RemoveHustlerRings(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.RemoveHustlerRingIDs(ids...)
}

// ClearHustlerAccessories clears all "hustler_accessories" edges to the Hustler entity.
func (iuo *ItemUpdateOne) ClearHustlerAccessories() *ItemUpdateOne {
	iuo.mutation.ClearHustlerAccessories()
	return iuo
}

// RemoveHustlerAccessoryIDs removes the "hustler_accessories" edge to Hustler entities by IDs.
func (iuo *ItemUpdateOne) RemoveHustlerAccessoryIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.RemoveHustlerAccessoryIDs(ids...)
	return iuo
}

// RemoveHustlerAccessories removes "hustler_accessories" edges to Hustler entities.
func (iuo *ItemUpdateOne) RemoveHustlerAccessories(h ...*Hustler) *ItemUpdateOne {
	ids := make([]string, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return iuo.RemoveHustlerAccessoryIDs(ids...)
}

// ClearBase clears the "base" edge to the Item entity.
func (iuo *ItemUpdateOne) ClearBase() *ItemUpdateOne {
	iuo.mutation.ClearBase()
	return iuo
}

// ClearDerivative clears all "derivative" edges to the Item entity.
func (iuo *ItemUpdateOne) ClearDerivative() *ItemUpdateOne {
	iuo.mutation.ClearDerivative()
	return iuo
}

// RemoveDerivativeIDs removes the "derivative" edge to Item entities by IDs.
func (iuo *ItemUpdateOne) RemoveDerivativeIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.RemoveDerivativeIDs(ids...)
	return iuo
}

// RemoveDerivative removes "derivative" edges to Item entities.
func (iuo *ItemUpdateOne) RemoveDerivative(i ...*Item) *ItemUpdateOne {
	ids := make([]string, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.RemoveDerivativeIDs(ids...)
}

// ClearIndex clears the "index" edge to the Search entity.
func (iuo *ItemUpdateOne) ClearIndex() *ItemUpdateOne {
	iuo.mutation.ClearIndex()
	return iuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (iuo *ItemUpdateOne) Select(field string, fields ...string) *ItemUpdateOne {
	iuo.fields = append([]string{field}, fields...)
	return iuo
}

// Save executes the query and returns the updated Item entity.
func (iuo *ItemUpdateOne) Save(ctx context.Context) (*Item, error) {
	var (
		err  error
		node *Item
	)
	if len(iuo.hooks) == 0 {
		if err = iuo.check(); err != nil {
			return nil, err
		}
		node, err = iuo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*ItemMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = iuo.check(); err != nil {
				return nil, err
			}
			iuo.mutation = mutation
			node, err = iuo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(iuo.hooks) - 1; i >= 0; i-- {
			if iuo.hooks[i] == nil {
				return nil, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = iuo.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, iuo.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (iuo *ItemUpdateOne) SaveX(ctx context.Context) *Item {
	node, err := iuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (iuo *ItemUpdateOne) Exec(ctx context.Context) error {
	_, err := iuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (iuo *ItemUpdateOne) ExecX(ctx context.Context) {
	if err := iuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (iuo *ItemUpdateOne) check() error {
	if v, ok := iuo.mutation.Tier(); ok {
		if err := item.TierValidator(v); err != nil {
			return &ValidationError{Name: "tier", err: fmt.Errorf(`ent: validator failed for field "Item.tier": %w`, err)}
		}
	}
	return nil
}

func (iuo *ItemUpdateOne) sqlSave(ctx context.Context) (_node *Item, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   item.Table,
			Columns: item.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: item.FieldID,
			},
		},
	}
	id, ok := iuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Item.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := iuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, item.FieldID)
		for _, f := range fields {
			if !item.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != item.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := iuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if iuo.mutation.NamePrefixCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: item.FieldNamePrefix,
		})
	}
	if iuo.mutation.NameSuffixCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: item.FieldNameSuffix,
		})
	}
	if iuo.mutation.SuffixCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: item.FieldSuffix,
		})
	}
	if iuo.mutation.AugmentedCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Column: item.FieldAugmented,
		})
	}
	if value, ok := iuo.mutation.Count(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: item.FieldCount,
		})
	}
	if value, ok := iuo.mutation.AddedCount(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: item.FieldCount,
		})
	}
	if iuo.mutation.CountCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: item.FieldCount,
		})
	}
	if value, ok := iuo.mutation.Tier(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: item.FieldTier,
		})
	}
	if iuo.mutation.TierCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Column: item.FieldTier,
		})
	}
	if value, ok := iuo.mutation.Greatness(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: item.FieldGreatness,
		})
	}
	if value, ok := iuo.mutation.AddedGreatness(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: item.FieldGreatness,
		})
	}
	if iuo.mutation.GreatnessCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: item.FieldGreatness,
		})
	}
	if value, ok := iuo.mutation.Rles(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Value:  value,
			Column: item.FieldRles,
		})
	}
	if iuo.mutation.RlesCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Column: item.FieldRles,
		})
	}
	if value, ok := iuo.mutation.Svg(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: item.FieldSvg,
		})
	}
	if iuo.mutation.SvgCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: item.FieldSvg,
		})
	}
	if iuo.mutation.WalletsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.WalletsTable,
			Columns: []string{item.WalletsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: walletitems.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedWalletsIDs(); len(nodes) > 0 && !iuo.mutation.WalletsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.WalletsTable,
			Columns: []string{item.WalletsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: walletitems.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.WalletsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.WalletsTable,
			Columns: []string{item.WalletsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: walletitems.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.DopesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   item.DopesTable,
			Columns: item.DopesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: dope.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedDopesIDs(); len(nodes) > 0 && !iuo.mutation.DopesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   item.DopesTable,
			Columns: item.DopesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: dope.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.DopesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   item.DopesTable,
			Columns: item.DopesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: dope.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.HustlerWeaponsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerWeaponsTable,
			Columns: []string{item.HustlerWeaponsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedHustlerWeaponsIDs(); len(nodes) > 0 && !iuo.mutation.HustlerWeaponsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerWeaponsTable,
			Columns: []string{item.HustlerWeaponsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.HustlerWeaponsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerWeaponsTable,
			Columns: []string{item.HustlerWeaponsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.HustlerClothesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerClothesTable,
			Columns: []string{item.HustlerClothesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedHustlerClothesIDs(); len(nodes) > 0 && !iuo.mutation.HustlerClothesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerClothesTable,
			Columns: []string{item.HustlerClothesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.HustlerClothesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerClothesTable,
			Columns: []string{item.HustlerClothesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.HustlerVehiclesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerVehiclesTable,
			Columns: []string{item.HustlerVehiclesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedHustlerVehiclesIDs(); len(nodes) > 0 && !iuo.mutation.HustlerVehiclesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerVehiclesTable,
			Columns: []string{item.HustlerVehiclesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.HustlerVehiclesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerVehiclesTable,
			Columns: []string{item.HustlerVehiclesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.HustlerWaistsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerWaistsTable,
			Columns: []string{item.HustlerWaistsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedHustlerWaistsIDs(); len(nodes) > 0 && !iuo.mutation.HustlerWaistsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerWaistsTable,
			Columns: []string{item.HustlerWaistsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.HustlerWaistsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerWaistsTable,
			Columns: []string{item.HustlerWaistsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.HustlerFeetCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerFeetTable,
			Columns: []string{item.HustlerFeetColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedHustlerFeetIDs(); len(nodes) > 0 && !iuo.mutation.HustlerFeetCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerFeetTable,
			Columns: []string{item.HustlerFeetColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.HustlerFeetIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerFeetTable,
			Columns: []string{item.HustlerFeetColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.HustlerHandsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerHandsTable,
			Columns: []string{item.HustlerHandsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedHustlerHandsIDs(); len(nodes) > 0 && !iuo.mutation.HustlerHandsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerHandsTable,
			Columns: []string{item.HustlerHandsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.HustlerHandsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerHandsTable,
			Columns: []string{item.HustlerHandsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.HustlerDrugsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerDrugsTable,
			Columns: []string{item.HustlerDrugsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedHustlerDrugsIDs(); len(nodes) > 0 && !iuo.mutation.HustlerDrugsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerDrugsTable,
			Columns: []string{item.HustlerDrugsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.HustlerDrugsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerDrugsTable,
			Columns: []string{item.HustlerDrugsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.HustlerNecksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerNecksTable,
			Columns: []string{item.HustlerNecksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedHustlerNecksIDs(); len(nodes) > 0 && !iuo.mutation.HustlerNecksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerNecksTable,
			Columns: []string{item.HustlerNecksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.HustlerNecksIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerNecksTable,
			Columns: []string{item.HustlerNecksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.HustlerRingsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerRingsTable,
			Columns: []string{item.HustlerRingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedHustlerRingsIDs(); len(nodes) > 0 && !iuo.mutation.HustlerRingsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerRingsTable,
			Columns: []string{item.HustlerRingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.HustlerRingsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerRingsTable,
			Columns: []string{item.HustlerRingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.HustlerAccessoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerAccessoriesTable,
			Columns: []string{item.HustlerAccessoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedHustlerAccessoriesIDs(); len(nodes) > 0 && !iuo.mutation.HustlerAccessoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerAccessoriesTable,
			Columns: []string{item.HustlerAccessoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.HustlerAccessoriesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.HustlerAccessoriesTable,
			Columns: []string{item.HustlerAccessoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: hustler.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.BaseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   item.BaseTable,
			Columns: []string{item.BaseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: item.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.BaseIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   item.BaseTable,
			Columns: []string{item.BaseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: item.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.DerivativeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.DerivativeTable,
			Columns: []string{item.DerivativeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: item.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedDerivativeIDs(); len(nodes) > 0 && !iuo.mutation.DerivativeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.DerivativeTable,
			Columns: []string{item.DerivativeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: item.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.DerivativeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   item.DerivativeTable,
			Columns: []string{item.DerivativeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: item.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.IndexCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   item.IndexTable,
			Columns: []string{item.IndexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: search.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.IndexIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   item.IndexTable,
			Columns: []string{item.IndexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeString,
					Column: search.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Item{config: iuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, iuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{item.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return nil, err
	}
	return _node, nil
}
