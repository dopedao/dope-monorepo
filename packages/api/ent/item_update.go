



// Code generated by entc, DO NOT EDIT.



package ent



import (
	"context"
	"errors"
	"fmt"
	"math"
	"strings"
	"time"
		"github.com/dopedao/dope-monorepo/packages/api/ent/predicate"
			"github.com/dopedao/dope-monorepo/packages/api/ent/schema"
			"github.com/dopedao/dope-monorepo/packages/api/ent/schema"
	"entgo.io/ent"
	"entgo.io/ent/dialect"
			"entgo.io/ent/dialect/sql"
			"entgo.io/ent/dialect/sql/sqlgraph"
			"entgo.io/ent/schema/field"

)


import (
		"github.com/dopedao/dope-monorepo/packages/api/ent/item"
		"github.com/dopedao/dope-monorepo/packages/api/ent/walletitems"
		"github.com/dopedao/dope-monorepo/packages/api/ent/dope"
		"github.com/dopedao/dope-monorepo/packages/api/ent/hustler"
		"github.com/dopedao/dope-monorepo/packages/api/ent/search"
)






// ItemUpdate is the builder for updating Item entities.
type ItemUpdate struct {
	config
	hooks []Hook
	mutation *ItemMutation
}

// Where appends a list predicates to the ItemUpdate builder.
func (iu *ItemUpdate) Where(ps ...predicate.Item) *ItemUpdate {
	iu.mutation.Where(ps...)
	return iu
}


	




	
	


	
	
	// SetCount sets the "count" field.
	func (iu *ItemUpdate) SetCount(i int) *ItemUpdate {
			iu.mutation.ResetCount()
		iu.mutation.SetCount(i)
		return iu
	}

	
	
		
		// SetNillableCount sets the "count" field if the given value is not nil.
		func (iu *ItemUpdate) SetNillableCount(i *int) *ItemUpdate {
			if i != nil {
				iu.SetCount(*i)
			}
			return iu
		}
	

	
		
		// AddCount adds i to the "count" field.
		func (iu *ItemUpdate) AddCount(i int) *ItemUpdate {
			iu.mutation.AddCount(i)
			return iu
		}
	

	
		
		// ClearCount clears the value of the "count" field.
		func (iu *ItemUpdate) ClearCount() *ItemUpdate {
			iu.mutation.ClearCount()
			return iu
		}
	

	
	
	// SetTier sets the "tier" field.
	func (iu *ItemUpdate) SetTier(i item.Tier) *ItemUpdate {
		iu.mutation.SetTier(i)
		return iu
	}

	
	
		
		// SetNillableTier sets the "tier" field if the given value is not nil.
		func (iu *ItemUpdate) SetNillableTier(i *item.Tier) *ItemUpdate {
			if i != nil {
				iu.SetTier(*i)
			}
			return iu
		}
	

	

	
		
		// ClearTier clears the value of the "tier" field.
		func (iu *ItemUpdate) ClearTier() *ItemUpdate {
			iu.mutation.ClearTier()
			return iu
		}
	

	
	
	// SetGreatness sets the "greatness" field.
	func (iu *ItemUpdate) SetGreatness(i int) *ItemUpdate {
			iu.mutation.ResetGreatness()
		iu.mutation.SetGreatness(i)
		return iu
	}

	
	
		
		// SetNillableGreatness sets the "greatness" field if the given value is not nil.
		func (iu *ItemUpdate) SetNillableGreatness(i *int) *ItemUpdate {
			if i != nil {
				iu.SetGreatness(*i)
			}
			return iu
		}
	

	
		
		// AddGreatness adds i to the "greatness" field.
		func (iu *ItemUpdate) AddGreatness(i int) *ItemUpdate {
			iu.mutation.AddGreatness(i)
			return iu
		}
	

	
		
		// ClearGreatness clears the value of the "greatness" field.
		func (iu *ItemUpdate) ClearGreatness() *ItemUpdate {
			iu.mutation.ClearGreatness()
			return iu
		}
	

	
	
	// SetRles sets the "rles" field.
	func (iu *ItemUpdate) SetRles(se schema.RLEs) *ItemUpdate {
		iu.mutation.SetRles(se)
		return iu
	}

	
	
		
		// SetNillableRles sets the "rles" field if the given value is not nil.
		func (iu *ItemUpdate) SetNillableRles(se *schema.RLEs) *ItemUpdate {
			if se != nil {
				iu.SetRles(*se)
			}
			return iu
		}
	

	

	
		
		// ClearRles clears the value of the "rles" field.
		func (iu *ItemUpdate) ClearRles() *ItemUpdate {
			iu.mutation.ClearRles()
			return iu
		}
	

	
	
	// SetSvg sets the "svg" field.
	func (iu *ItemUpdate) SetSvg(s string) *ItemUpdate {
		iu.mutation.SetSvg(s)
		return iu
	}

	
	
		
		// SetNillableSvg sets the "svg" field if the given value is not nil.
		func (iu *ItemUpdate) SetNillableSvg(s *string) *ItemUpdate {
			if s != nil {
				iu.SetSvg(*s)
			}
			return iu
		}
	

	

	
		
		// ClearSvg clears the value of the "svg" field.
		func (iu *ItemUpdate) ClearSvg() *ItemUpdate {
			iu.mutation.ClearSvg()
			return iu
		}
	

	
	
	// SetSprite sets the "sprite" field.
	func (iu *ItemUpdate) SetSprite(s schema.Sprites) *ItemUpdate {
		iu.mutation.SetSprite(s)
		return iu
	}

	
	
		
		// SetNillableSprite sets the "sprite" field if the given value is not nil.
		func (iu *ItemUpdate) SetNillableSprite(s *schema.Sprites) *ItemUpdate {
			if s != nil {
				iu.SetSprite(*s)
			}
			return iu
		}
	

	

	
		
		// ClearSprite clears the value of the "sprite" field.
		func (iu *ItemUpdate) ClearSprite() *ItemUpdate {
			iu.mutation.ClearSprite()
			return iu
		}
	



	
	
	
	
		// AddWalletIDs adds the "wallets" edge to the WalletItems entity by IDs.
		func (iu *ItemUpdate) AddWalletIDs(ids ... string) *ItemUpdate {
			iu.mutation.AddWalletIDs(ids ...)
			return iu
		}
	
	
	
	
	
	// AddWallets adds the "wallets" edges to the WalletItems entity.
	func (iu *ItemUpdate) AddWallets(w ...*WalletItems) *ItemUpdate {
		ids := make([]string, len(w))
			for i := range w {
				ids[i] = w[i].ID
			}
			return iu.AddWalletIDs(ids...)
	}

	
	
	
	
		// AddDopeIDs adds the "dopes" edge to the Dope entity by IDs.
		func (iu *ItemUpdate) AddDopeIDs(ids ... string) *ItemUpdate {
			iu.mutation.AddDopeIDs(ids ...)
			return iu
		}
	
	
	
	
	
	// AddDopes adds the "dopes" edges to the Dope entity.
	func (iu *ItemUpdate) AddDopes(d ...*Dope) *ItemUpdate {
		ids := make([]string, len(d))
			for i := range d {
				ids[i] = d[i].ID
			}
			return iu.AddDopeIDs(ids...)
	}

	
	
	
	
		// AddHustlerWeaponIDs adds the "hustler_weapons" edge to the Hustler entity by IDs.
		func (iu *ItemUpdate) AddHustlerWeaponIDs(ids ... string) *ItemUpdate {
			iu.mutation.AddHustlerWeaponIDs(ids ...)
			return iu
		}
	
	
	
	
	
	// AddHustlerWeapons adds the "hustler_weapons" edges to the Hustler entity.
	func (iu *ItemUpdate) AddHustlerWeapons(h ...*Hustler) *ItemUpdate {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.AddHustlerWeaponIDs(ids...)
	}

	
	
	
	
		// AddHustlerClotheIDs adds the "hustler_clothes" edge to the Hustler entity by IDs.
		func (iu *ItemUpdate) AddHustlerClotheIDs(ids ... string) *ItemUpdate {
			iu.mutation.AddHustlerClotheIDs(ids ...)
			return iu
		}
	
	
	
	
	
	// AddHustlerClothes adds the "hustler_clothes" edges to the Hustler entity.
	func (iu *ItemUpdate) AddHustlerClothes(h ...*Hustler) *ItemUpdate {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.AddHustlerClotheIDs(ids...)
	}

	
	
	
	
		// AddHustlerVehicleIDs adds the "hustler_vehicles" edge to the Hustler entity by IDs.
		func (iu *ItemUpdate) AddHustlerVehicleIDs(ids ... string) *ItemUpdate {
			iu.mutation.AddHustlerVehicleIDs(ids ...)
			return iu
		}
	
	
	
	
	
	// AddHustlerVehicles adds the "hustler_vehicles" edges to the Hustler entity.
	func (iu *ItemUpdate) AddHustlerVehicles(h ...*Hustler) *ItemUpdate {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.AddHustlerVehicleIDs(ids...)
	}

	
	
	
	
		// AddHustlerWaistIDs adds the "hustler_waists" edge to the Hustler entity by IDs.
		func (iu *ItemUpdate) AddHustlerWaistIDs(ids ... string) *ItemUpdate {
			iu.mutation.AddHustlerWaistIDs(ids ...)
			return iu
		}
	
	
	
	
	
	// AddHustlerWaists adds the "hustler_waists" edges to the Hustler entity.
	func (iu *ItemUpdate) AddHustlerWaists(h ...*Hustler) *ItemUpdate {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.AddHustlerWaistIDs(ids...)
	}

	
	
	
	
		// AddHustlerFeetIDs adds the "hustler_feet" edge to the Hustler entity by IDs.
		func (iu *ItemUpdate) AddHustlerFeetIDs(ids ... string) *ItemUpdate {
			iu.mutation.AddHustlerFeetIDs(ids ...)
			return iu
		}
	
	
	
	
	
	// AddHustlerFeet adds the "hustler_feet" edges to the Hustler entity.
	func (iu *ItemUpdate) AddHustlerFeet(h ...*Hustler) *ItemUpdate {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.AddHustlerFeetIDs(ids...)
	}

	
	
	
	
		// AddHustlerHandIDs adds the "hustler_hands" edge to the Hustler entity by IDs.
		func (iu *ItemUpdate) AddHustlerHandIDs(ids ... string) *ItemUpdate {
			iu.mutation.AddHustlerHandIDs(ids ...)
			return iu
		}
	
	
	
	
	
	// AddHustlerHands adds the "hustler_hands" edges to the Hustler entity.
	func (iu *ItemUpdate) AddHustlerHands(h ...*Hustler) *ItemUpdate {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.AddHustlerHandIDs(ids...)
	}

	
	
	
	
		// AddHustlerDrugIDs adds the "hustler_drugs" edge to the Hustler entity by IDs.
		func (iu *ItemUpdate) AddHustlerDrugIDs(ids ... string) *ItemUpdate {
			iu.mutation.AddHustlerDrugIDs(ids ...)
			return iu
		}
	
	
	
	
	
	// AddHustlerDrugs adds the "hustler_drugs" edges to the Hustler entity.
	func (iu *ItemUpdate) AddHustlerDrugs(h ...*Hustler) *ItemUpdate {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.AddHustlerDrugIDs(ids...)
	}

	
	
	
	
		// AddHustlerNeckIDs adds the "hustler_necks" edge to the Hustler entity by IDs.
		func (iu *ItemUpdate) AddHustlerNeckIDs(ids ... string) *ItemUpdate {
			iu.mutation.AddHustlerNeckIDs(ids ...)
			return iu
		}
	
	
	
	
	
	// AddHustlerNecks adds the "hustler_necks" edges to the Hustler entity.
	func (iu *ItemUpdate) AddHustlerNecks(h ...*Hustler) *ItemUpdate {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.AddHustlerNeckIDs(ids...)
	}

	
	
	
	
		// AddHustlerRingIDs adds the "hustler_rings" edge to the Hustler entity by IDs.
		func (iu *ItemUpdate) AddHustlerRingIDs(ids ... string) *ItemUpdate {
			iu.mutation.AddHustlerRingIDs(ids ...)
			return iu
		}
	
	
	
	
	
	// AddHustlerRings adds the "hustler_rings" edges to the Hustler entity.
	func (iu *ItemUpdate) AddHustlerRings(h ...*Hustler) *ItemUpdate {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.AddHustlerRingIDs(ids...)
	}

	
	
	
	
		// AddHustlerAccessoryIDs adds the "hustler_accessories" edge to the Hustler entity by IDs.
		func (iu *ItemUpdate) AddHustlerAccessoryIDs(ids ... string) *ItemUpdate {
			iu.mutation.AddHustlerAccessoryIDs(ids ...)
			return iu
		}
	
	
	
	
	
	// AddHustlerAccessories adds the "hustler_accessories" edges to the Hustler entity.
	func (iu *ItemUpdate) AddHustlerAccessories(h ...*Hustler) *ItemUpdate {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.AddHustlerAccessoryIDs(ids...)
	}

	
	
	
	
		// SetBaseID sets the "base" edge to the Item entity by ID.
		func (iu *ItemUpdate) SetBaseID(id string) *ItemUpdate {
			iu.mutation.SetBaseID(id)
			return iu
		}
	
	
		
		// SetNillableBaseID sets the "base" edge to the Item entity by ID if the given value is not nil.
		func (iu *ItemUpdate) SetNillableBaseID(id *string) *ItemUpdate {
			if id != nil {
				iu = iu.SetBaseID(*id)
			}
			return iu
		}
	
	
	
	
	// SetBase sets the "base" edge to the Item entity.
	func (iu *ItemUpdate) SetBase(i *Item) *ItemUpdate {
		return iu.SetBaseID(i.ID)
	}

	
	
	
	
		// AddDerivativeIDs adds the "derivative" edge to the Item entity by IDs.
		func (iu *ItemUpdate) AddDerivativeIDs(ids ... string) *ItemUpdate {
			iu.mutation.AddDerivativeIDs(ids ...)
			return iu
		}
	
	
	
	
	
	// AddDerivative adds the "derivative" edges to the Item entity.
	func (iu *ItemUpdate) AddDerivative(i ...*Item) *ItemUpdate {
		ids := make([]string, len(i))
			for j := range i {
				ids[j] = i[j].ID
			}
			return iu.AddDerivativeIDs(ids...)
	}

	
	
	
	
		// SetIndexID sets the "index" edge to the Search entity by ID.
		func (iu *ItemUpdate) SetIndexID(id string) *ItemUpdate {
			iu.mutation.SetIndexID(id)
			return iu
		}
	
	
		
		// SetNillableIndexID sets the "index" edge to the Search entity by ID if the given value is not nil.
		func (iu *ItemUpdate) SetNillableIndexID(id *string) *ItemUpdate {
			if id != nil {
				iu = iu.SetIndexID(*id)
			}
			return iu
		}
	
	
	
	
	// SetIndex sets the "index" edge to the Search entity.
	func (iu *ItemUpdate) SetIndex(s *Search) *ItemUpdate {
		return iu.SetIndexID(s.ID)
	}


// Mutation returns the ItemMutation object of the builder.
func (iu *ItemUpdate) Mutation() *ItemMutation {
	return iu.mutation
}





	





	
	// ClearWallets clears all "wallets" edges to the WalletItems entity.
	func (iu *ItemUpdate) ClearWallets() *ItemUpdate {
		iu.mutation.ClearWallets()
		return iu
	}
	
		
		
		
		
		// RemoveWalletIDs removes the "wallets" edge to WalletItems entities by IDs.
		func (iu *ItemUpdate) RemoveWalletIDs(ids ...string) *ItemUpdate {
			iu.mutation.RemoveWalletIDs(ids...)
			return iu
		}
		
		// RemoveWallets removes "wallets" edges to WalletItems entities.
		func (iu *ItemUpdate) RemoveWallets(w ...*WalletItems) *ItemUpdate {
			ids := make([]string, len(w))
			for i := range w {
				ids[i] = w[i].ID
			}
			return iu.RemoveWalletIDs(ids...)
		}
	

	
	// ClearDopes clears all "dopes" edges to the Dope entity.
	func (iu *ItemUpdate) ClearDopes() *ItemUpdate {
		iu.mutation.ClearDopes()
		return iu
	}
	
		
		
		
		
		// RemoveDopeIDs removes the "dopes" edge to Dope entities by IDs.
		func (iu *ItemUpdate) RemoveDopeIDs(ids ...string) *ItemUpdate {
			iu.mutation.RemoveDopeIDs(ids...)
			return iu
		}
		
		// RemoveDopes removes "dopes" edges to Dope entities.
		func (iu *ItemUpdate) RemoveDopes(d ...*Dope) *ItemUpdate {
			ids := make([]string, len(d))
			for i := range d {
				ids[i] = d[i].ID
			}
			return iu.RemoveDopeIDs(ids...)
		}
	

	
	// ClearHustlerWeapons clears all "hustler_weapons" edges to the Hustler entity.
	func (iu *ItemUpdate) ClearHustlerWeapons() *ItemUpdate {
		iu.mutation.ClearHustlerWeapons()
		return iu
	}
	
		
		
		
		
		// RemoveHustlerWeaponIDs removes the "hustler_weapons" edge to Hustler entities by IDs.
		func (iu *ItemUpdate) RemoveHustlerWeaponIDs(ids ...string) *ItemUpdate {
			iu.mutation.RemoveHustlerWeaponIDs(ids...)
			return iu
		}
		
		// RemoveHustlerWeapons removes "hustler_weapons" edges to Hustler entities.
		func (iu *ItemUpdate) RemoveHustlerWeapons(h ...*Hustler) *ItemUpdate {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.RemoveHustlerWeaponIDs(ids...)
		}
	

	
	// ClearHustlerClothes clears all "hustler_clothes" edges to the Hustler entity.
	func (iu *ItemUpdate) ClearHustlerClothes() *ItemUpdate {
		iu.mutation.ClearHustlerClothes()
		return iu
	}
	
		
		
		
		
		// RemoveHustlerClotheIDs removes the "hustler_clothes" edge to Hustler entities by IDs.
		func (iu *ItemUpdate) RemoveHustlerClotheIDs(ids ...string) *ItemUpdate {
			iu.mutation.RemoveHustlerClotheIDs(ids...)
			return iu
		}
		
		// RemoveHustlerClothes removes "hustler_clothes" edges to Hustler entities.
		func (iu *ItemUpdate) RemoveHustlerClothes(h ...*Hustler) *ItemUpdate {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.RemoveHustlerClotheIDs(ids...)
		}
	

	
	// ClearHustlerVehicles clears all "hustler_vehicles" edges to the Hustler entity.
	func (iu *ItemUpdate) ClearHustlerVehicles() *ItemUpdate {
		iu.mutation.ClearHustlerVehicles()
		return iu
	}
	
		
		
		
		
		// RemoveHustlerVehicleIDs removes the "hustler_vehicles" edge to Hustler entities by IDs.
		func (iu *ItemUpdate) RemoveHustlerVehicleIDs(ids ...string) *ItemUpdate {
			iu.mutation.RemoveHustlerVehicleIDs(ids...)
			return iu
		}
		
		// RemoveHustlerVehicles removes "hustler_vehicles" edges to Hustler entities.
		func (iu *ItemUpdate) RemoveHustlerVehicles(h ...*Hustler) *ItemUpdate {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.RemoveHustlerVehicleIDs(ids...)
		}
	

	
	// ClearHustlerWaists clears all "hustler_waists" edges to the Hustler entity.
	func (iu *ItemUpdate) ClearHustlerWaists() *ItemUpdate {
		iu.mutation.ClearHustlerWaists()
		return iu
	}
	
		
		
		
		
		// RemoveHustlerWaistIDs removes the "hustler_waists" edge to Hustler entities by IDs.
		func (iu *ItemUpdate) RemoveHustlerWaistIDs(ids ...string) *ItemUpdate {
			iu.mutation.RemoveHustlerWaistIDs(ids...)
			return iu
		}
		
		// RemoveHustlerWaists removes "hustler_waists" edges to Hustler entities.
		func (iu *ItemUpdate) RemoveHustlerWaists(h ...*Hustler) *ItemUpdate {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.RemoveHustlerWaistIDs(ids...)
		}
	

	
	// ClearHustlerFeet clears all "hustler_feet" edges to the Hustler entity.
	func (iu *ItemUpdate) ClearHustlerFeet() *ItemUpdate {
		iu.mutation.ClearHustlerFeet()
		return iu
	}
	
		
		
		
		
		// RemoveHustlerFeetIDs removes the "hustler_feet" edge to Hustler entities by IDs.
		func (iu *ItemUpdate) RemoveHustlerFeetIDs(ids ...string) *ItemUpdate {
			iu.mutation.RemoveHustlerFeetIDs(ids...)
			return iu
		}
		
		// RemoveHustlerFeet removes "hustler_feet" edges to Hustler entities.
		func (iu *ItemUpdate) RemoveHustlerFeet(h ...*Hustler) *ItemUpdate {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.RemoveHustlerFeetIDs(ids...)
		}
	

	
	// ClearHustlerHands clears all "hustler_hands" edges to the Hustler entity.
	func (iu *ItemUpdate) ClearHustlerHands() *ItemUpdate {
		iu.mutation.ClearHustlerHands()
		return iu
	}
	
		
		
		
		
		// RemoveHustlerHandIDs removes the "hustler_hands" edge to Hustler entities by IDs.
		func (iu *ItemUpdate) RemoveHustlerHandIDs(ids ...string) *ItemUpdate {
			iu.mutation.RemoveHustlerHandIDs(ids...)
			return iu
		}
		
		// RemoveHustlerHands removes "hustler_hands" edges to Hustler entities.
		func (iu *ItemUpdate) RemoveHustlerHands(h ...*Hustler) *ItemUpdate {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.RemoveHustlerHandIDs(ids...)
		}
	

	
	// ClearHustlerDrugs clears all "hustler_drugs" edges to the Hustler entity.
	func (iu *ItemUpdate) ClearHustlerDrugs() *ItemUpdate {
		iu.mutation.ClearHustlerDrugs()
		return iu
	}
	
		
		
		
		
		// RemoveHustlerDrugIDs removes the "hustler_drugs" edge to Hustler entities by IDs.
		func (iu *ItemUpdate) RemoveHustlerDrugIDs(ids ...string) *ItemUpdate {
			iu.mutation.RemoveHustlerDrugIDs(ids...)
			return iu
		}
		
		// RemoveHustlerDrugs removes "hustler_drugs" edges to Hustler entities.
		func (iu *ItemUpdate) RemoveHustlerDrugs(h ...*Hustler) *ItemUpdate {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.RemoveHustlerDrugIDs(ids...)
		}
	

	
	// ClearHustlerNecks clears all "hustler_necks" edges to the Hustler entity.
	func (iu *ItemUpdate) ClearHustlerNecks() *ItemUpdate {
		iu.mutation.ClearHustlerNecks()
		return iu
	}
	
		
		
		
		
		// RemoveHustlerNeckIDs removes the "hustler_necks" edge to Hustler entities by IDs.
		func (iu *ItemUpdate) RemoveHustlerNeckIDs(ids ...string) *ItemUpdate {
			iu.mutation.RemoveHustlerNeckIDs(ids...)
			return iu
		}
		
		// RemoveHustlerNecks removes "hustler_necks" edges to Hustler entities.
		func (iu *ItemUpdate) RemoveHustlerNecks(h ...*Hustler) *ItemUpdate {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.RemoveHustlerNeckIDs(ids...)
		}
	

	
	// ClearHustlerRings clears all "hustler_rings" edges to the Hustler entity.
	func (iu *ItemUpdate) ClearHustlerRings() *ItemUpdate {
		iu.mutation.ClearHustlerRings()
		return iu
	}
	
		
		
		
		
		// RemoveHustlerRingIDs removes the "hustler_rings" edge to Hustler entities by IDs.
		func (iu *ItemUpdate) RemoveHustlerRingIDs(ids ...string) *ItemUpdate {
			iu.mutation.RemoveHustlerRingIDs(ids...)
			return iu
		}
		
		// RemoveHustlerRings removes "hustler_rings" edges to Hustler entities.
		func (iu *ItemUpdate) RemoveHustlerRings(h ...*Hustler) *ItemUpdate {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.RemoveHustlerRingIDs(ids...)
		}
	

	
	// ClearHustlerAccessories clears all "hustler_accessories" edges to the Hustler entity.
	func (iu *ItemUpdate) ClearHustlerAccessories() *ItemUpdate {
		iu.mutation.ClearHustlerAccessories()
		return iu
	}
	
		
		
		
		
		// RemoveHustlerAccessoryIDs removes the "hustler_accessories" edge to Hustler entities by IDs.
		func (iu *ItemUpdate) RemoveHustlerAccessoryIDs(ids ...string) *ItemUpdate {
			iu.mutation.RemoveHustlerAccessoryIDs(ids...)
			return iu
		}
		
		// RemoveHustlerAccessories removes "hustler_accessories" edges to Hustler entities.
		func (iu *ItemUpdate) RemoveHustlerAccessories(h ...*Hustler) *ItemUpdate {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iu.RemoveHustlerAccessoryIDs(ids...)
		}
	

	
	// ClearBase clears the "base" edge to the Item entity.
	func (iu *ItemUpdate) ClearBase() *ItemUpdate {
		iu.mutation.ClearBase()
		return iu
	}
	

	
	// ClearDerivative clears all "derivative" edges to the Item entity.
	func (iu *ItemUpdate) ClearDerivative() *ItemUpdate {
		iu.mutation.ClearDerivative()
		return iu
	}
	
		
		
		
		
		// RemoveDerivativeIDs removes the "derivative" edge to Item entities by IDs.
		func (iu *ItemUpdate) RemoveDerivativeIDs(ids ...string) *ItemUpdate {
			iu.mutation.RemoveDerivativeIDs(ids...)
			return iu
		}
		
		// RemoveDerivative removes "derivative" edges to Item entities.
		func (iu *ItemUpdate) RemoveDerivative(i ...*Item) *ItemUpdate {
			ids := make([]string, len(i))
			for j := range i {
				ids[j] = i[j].ID
			}
			return iu.RemoveDerivativeIDs(ids...)
		}
	

	
	// ClearIndex clears the "index" edge to the Search entity.
	func (iu *ItemUpdate) ClearIndex() *ItemUpdate {
		iu.mutation.ClearIndex()
		return iu
	}
	




// Save executes the query and returns the number of nodes affected by the update operation.
func (iu *ItemUpdate) Save(ctx context.Context) (int, error) {
	var (
		err error
		affected int
	)
	if len(iu.hooks) == 0 {
			if err = iu.check(); err != nil {
				return 0, err
			}
		affected, err = iu.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*ItemMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
				if err = iu.check(); err != nil {
					return 0, err
				}
			iu.mutation = mutation
			affected, err = iu.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(iu.hooks) - 1; i >= 0; i-- {
			if iu.hooks[i] == nil {
				return 0, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = iu.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, iu.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (iu *ItemUpdate) SaveX(ctx context.Context) int {
	affected, err := iu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (iu *ItemUpdate) Exec(ctx context.Context) error {
	_, err := iu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (iu *ItemUpdate) ExecX(ctx context.Context) {
	if err := iu.Exec(ctx); err != nil {
		panic(err)
	}
}


	









	// check runs all checks and user-defined validators on the builder.
	func (iu *ItemUpdate) check() error {
				if v, ok := iu.mutation.Tier(); ok {
					if err := item.TierValidator(v); err != nil {
						return &ValidationError{Name: "tier", err: fmt.Errorf(`ent: validator failed for field "Item.tier": %w`, err)}
					}
				}
		return nil
	}






	
	






func (iu *ItemUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table: item.Table,
			Columns: item.Columns,
			ID: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: item.FieldID,
			},
		},
	}
	if ps := iu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
				if iu.mutation.NamePrefixCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeString,
						Column: item.FieldNamePrefix,
					})
				}
				if iu.mutation.NameSuffixCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeString,
						Column: item.FieldNameSuffix,
					})
				}
				if iu.mutation.SuffixCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeString,
						Column: item.FieldSuffix,
					})
				}
				if iu.mutation.AugmentedCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeBool,
						Column: item.FieldAugmented,
					})
				}
				if value, ok := iu.mutation.Count(); ok {
					_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
						Type: field.TypeInt,
						Value: value,
						Column: item.FieldCount,
					})
				}
					if value, ok := iu.mutation.AddedCount(); ok {
						_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
							Type: field.TypeInt,
							Value: value,
							Column: item.FieldCount,
						})
					}
				if iu.mutation.CountCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeInt,
						Column: item.FieldCount,
					})
				}
				if value, ok := iu.mutation.Tier(); ok {
					_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
						Type: field.TypeEnum,
						Value: value,
						Column: item.FieldTier,
					})
				}
				if iu.mutation.TierCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeEnum,
						Column: item.FieldTier,
					})
				}
				if value, ok := iu.mutation.Greatness(); ok {
					_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
						Type: field.TypeInt,
						Value: value,
						Column: item.FieldGreatness,
					})
				}
					if value, ok := iu.mutation.AddedGreatness(); ok {
						_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
							Type: field.TypeInt,
							Value: value,
							Column: item.FieldGreatness,
						})
					}
				if iu.mutation.GreatnessCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeInt,
						Column: item.FieldGreatness,
					})
				}
				if value, ok := iu.mutation.Rles(); ok {
					_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
						Type: field.TypeJSON,
						Value: value,
						Column: item.FieldRles,
					})
				}
				if iu.mutation.RlesCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeJSON,
						Column: item.FieldRles,
					})
				}
				if value, ok := iu.mutation.Svg(); ok {
					_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
						Type: field.TypeString,
						Value: value,
						Column: item.FieldSvg,
					})
				}
				if iu.mutation.SvgCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeString,
						Column: item.FieldSvg,
					})
				}
				if value, ok := iu.mutation.Sprite(); ok {
					_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
						Type: field.TypeJSON,
						Value: value,
						Column: item.FieldSprite,
					})
				}
				if iu.mutation.SpriteCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeJSON,
						Column: item.FieldSprite,
					})
				}
		if iu.mutation.WalletsCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.WalletsTable,
		Columns: []string{ item.WalletsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: walletitems.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iu.mutation.RemovedWalletsIDs(); len(nodes) > 0 && !iu.mutation.WalletsCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.WalletsTable,
		Columns: []string{ item.WalletsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: walletitems.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iu.mutation.WalletsIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.WalletsTable,
		Columns: []string{ item.WalletsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: walletitems.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iu.mutation.DopesCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2M,
		Inverse: true,
		Table: item.DopesTable,
		Columns: item.DopesPrimaryKey,
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: dope.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iu.mutation.RemovedDopesIDs(); len(nodes) > 0 && !iu.mutation.DopesCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2M,
		Inverse: true,
		Table: item.DopesTable,
		Columns: item.DopesPrimaryKey,
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: dope.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iu.mutation.DopesIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2M,
		Inverse: true,
		Table: item.DopesTable,
		Columns: item.DopesPrimaryKey,
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: dope.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iu.mutation.HustlerWeaponsCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerWeaponsTable,
		Columns: []string{ item.HustlerWeaponsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iu.mutation.RemovedHustlerWeaponsIDs(); len(nodes) > 0 && !iu.mutation.HustlerWeaponsCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerWeaponsTable,
		Columns: []string{ item.HustlerWeaponsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iu.mutation.HustlerWeaponsIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerWeaponsTable,
		Columns: []string{ item.HustlerWeaponsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iu.mutation.HustlerClothesCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerClothesTable,
		Columns: []string{ item.HustlerClothesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iu.mutation.RemovedHustlerClothesIDs(); len(nodes) > 0 && !iu.mutation.HustlerClothesCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerClothesTable,
		Columns: []string{ item.HustlerClothesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iu.mutation.HustlerClothesIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerClothesTable,
		Columns: []string{ item.HustlerClothesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iu.mutation.HustlerVehiclesCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerVehiclesTable,
		Columns: []string{ item.HustlerVehiclesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iu.mutation.RemovedHustlerVehiclesIDs(); len(nodes) > 0 && !iu.mutation.HustlerVehiclesCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerVehiclesTable,
		Columns: []string{ item.HustlerVehiclesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iu.mutation.HustlerVehiclesIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerVehiclesTable,
		Columns: []string{ item.HustlerVehiclesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iu.mutation.HustlerWaistsCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerWaistsTable,
		Columns: []string{ item.HustlerWaistsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iu.mutation.RemovedHustlerWaistsIDs(); len(nodes) > 0 && !iu.mutation.HustlerWaistsCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerWaistsTable,
		Columns: []string{ item.HustlerWaistsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iu.mutation.HustlerWaistsIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerWaistsTable,
		Columns: []string{ item.HustlerWaistsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iu.mutation.HustlerFeetCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerFeetTable,
		Columns: []string{ item.HustlerFeetColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iu.mutation.RemovedHustlerFeetIDs(); len(nodes) > 0 && !iu.mutation.HustlerFeetCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerFeetTable,
		Columns: []string{ item.HustlerFeetColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iu.mutation.HustlerFeetIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerFeetTable,
		Columns: []string{ item.HustlerFeetColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iu.mutation.HustlerHandsCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerHandsTable,
		Columns: []string{ item.HustlerHandsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iu.mutation.RemovedHustlerHandsIDs(); len(nodes) > 0 && !iu.mutation.HustlerHandsCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerHandsTable,
		Columns: []string{ item.HustlerHandsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iu.mutation.HustlerHandsIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerHandsTable,
		Columns: []string{ item.HustlerHandsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iu.mutation.HustlerDrugsCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerDrugsTable,
		Columns: []string{ item.HustlerDrugsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iu.mutation.RemovedHustlerDrugsIDs(); len(nodes) > 0 && !iu.mutation.HustlerDrugsCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerDrugsTable,
		Columns: []string{ item.HustlerDrugsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iu.mutation.HustlerDrugsIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerDrugsTable,
		Columns: []string{ item.HustlerDrugsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iu.mutation.HustlerNecksCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerNecksTable,
		Columns: []string{ item.HustlerNecksColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iu.mutation.RemovedHustlerNecksIDs(); len(nodes) > 0 && !iu.mutation.HustlerNecksCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerNecksTable,
		Columns: []string{ item.HustlerNecksColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iu.mutation.HustlerNecksIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerNecksTable,
		Columns: []string{ item.HustlerNecksColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iu.mutation.HustlerRingsCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerRingsTable,
		Columns: []string{ item.HustlerRingsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iu.mutation.RemovedHustlerRingsIDs(); len(nodes) > 0 && !iu.mutation.HustlerRingsCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerRingsTable,
		Columns: []string{ item.HustlerRingsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iu.mutation.HustlerRingsIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerRingsTable,
		Columns: []string{ item.HustlerRingsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iu.mutation.HustlerAccessoriesCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerAccessoriesTable,
		Columns: []string{ item.HustlerAccessoriesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iu.mutation.RemovedHustlerAccessoriesIDs(); len(nodes) > 0 && !iu.mutation.HustlerAccessoriesCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerAccessoriesTable,
		Columns: []string{ item.HustlerAccessoriesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iu.mutation.HustlerAccessoriesIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerAccessoriesTable,
		Columns: []string{ item.HustlerAccessoriesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iu.mutation.BaseCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: true,
		Table: item.BaseTable,
		Columns: []string{ item.BaseColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: item.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
		if nodes := iu.mutation.BaseIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: true,
		Table: item.BaseTable,
		Columns: []string{ item.BaseColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: item.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iu.mutation.DerivativeCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.DerivativeTable,
		Columns: []string{ item.DerivativeColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: item.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iu.mutation.RemovedDerivativeIDs(); len(nodes) > 0 && !iu.mutation.DerivativeCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.DerivativeTable,
		Columns: []string{ item.DerivativeColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: item.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iu.mutation.DerivativeIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.DerivativeTable,
		Columns: []string{ item.DerivativeColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: item.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iu.mutation.IndexCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2O,
		Inverse: false,
		Table: item.IndexTable,
		Columns: []string{ item.IndexColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: search.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
		if nodes := iu.mutation.IndexIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2O,
		Inverse: false,
		Table: item.IndexTable,
		Columns: []string{ item.IndexColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: search.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if n, err = sqlgraph.UpdateNodes(ctx, iu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{ item.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return 0, err
	}
	return n, nil
}







// ItemUpdateOne is the builder for updating a single Item entity.
type ItemUpdateOne struct {
	config
	fields []string
	hooks []Hook
	mutation *ItemMutation

}


	




	
	


	
	
	// SetCount sets the "count" field.
	func (iuo *ItemUpdateOne) SetCount(i int) *ItemUpdateOne {
			iuo.mutation.ResetCount()
		iuo.mutation.SetCount(i)
		return iuo
	}

	
	
		
		// SetNillableCount sets the "count" field if the given value is not nil.
		func (iuo *ItemUpdateOne) SetNillableCount(i *int) *ItemUpdateOne {
			if i != nil {
				iuo.SetCount(*i)
			}
			return iuo
		}
	

	
		
		// AddCount adds i to the "count" field.
		func (iuo *ItemUpdateOne) AddCount(i int) *ItemUpdateOne {
			iuo.mutation.AddCount(i)
			return iuo
		}
	

	
		
		// ClearCount clears the value of the "count" field.
		func (iuo *ItemUpdateOne) ClearCount() *ItemUpdateOne {
			iuo.mutation.ClearCount()
			return iuo
		}
	

	
	
	// SetTier sets the "tier" field.
	func (iuo *ItemUpdateOne) SetTier(i item.Tier) *ItemUpdateOne {
		iuo.mutation.SetTier(i)
		return iuo
	}

	
	
		
		// SetNillableTier sets the "tier" field if the given value is not nil.
		func (iuo *ItemUpdateOne) SetNillableTier(i *item.Tier) *ItemUpdateOne {
			if i != nil {
				iuo.SetTier(*i)
			}
			return iuo
		}
	

	

	
		
		// ClearTier clears the value of the "tier" field.
		func (iuo *ItemUpdateOne) ClearTier() *ItemUpdateOne {
			iuo.mutation.ClearTier()
			return iuo
		}
	

	
	
	// SetGreatness sets the "greatness" field.
	func (iuo *ItemUpdateOne) SetGreatness(i int) *ItemUpdateOne {
			iuo.mutation.ResetGreatness()
		iuo.mutation.SetGreatness(i)
		return iuo
	}

	
	
		
		// SetNillableGreatness sets the "greatness" field if the given value is not nil.
		func (iuo *ItemUpdateOne) SetNillableGreatness(i *int) *ItemUpdateOne {
			if i != nil {
				iuo.SetGreatness(*i)
			}
			return iuo
		}
	

	
		
		// AddGreatness adds i to the "greatness" field.
		func (iuo *ItemUpdateOne) AddGreatness(i int) *ItemUpdateOne {
			iuo.mutation.AddGreatness(i)
			return iuo
		}
	

	
		
		// ClearGreatness clears the value of the "greatness" field.
		func (iuo *ItemUpdateOne) ClearGreatness() *ItemUpdateOne {
			iuo.mutation.ClearGreatness()
			return iuo
		}
	

	
	
	// SetRles sets the "rles" field.
	func (iuo *ItemUpdateOne) SetRles(se schema.RLEs) *ItemUpdateOne {
		iuo.mutation.SetRles(se)
		return iuo
	}

	
	
		
		// SetNillableRles sets the "rles" field if the given value is not nil.
		func (iuo *ItemUpdateOne) SetNillableRles(se *schema.RLEs) *ItemUpdateOne {
			if se != nil {
				iuo.SetRles(*se)
			}
			return iuo
		}
	

	

	
		
		// ClearRles clears the value of the "rles" field.
		func (iuo *ItemUpdateOne) ClearRles() *ItemUpdateOne {
			iuo.mutation.ClearRles()
			return iuo
		}
	

	
	
	// SetSvg sets the "svg" field.
	func (iuo *ItemUpdateOne) SetSvg(s string) *ItemUpdateOne {
		iuo.mutation.SetSvg(s)
		return iuo
	}

	
	
		
		// SetNillableSvg sets the "svg" field if the given value is not nil.
		func (iuo *ItemUpdateOne) SetNillableSvg(s *string) *ItemUpdateOne {
			if s != nil {
				iuo.SetSvg(*s)
			}
			return iuo
		}
	

	

	
		
		// ClearSvg clears the value of the "svg" field.
		func (iuo *ItemUpdateOne) ClearSvg() *ItemUpdateOne {
			iuo.mutation.ClearSvg()
			return iuo
		}
	

	
	
	// SetSprite sets the "sprite" field.
	func (iuo *ItemUpdateOne) SetSprite(s schema.Sprites) *ItemUpdateOne {
		iuo.mutation.SetSprite(s)
		return iuo
	}

	
	
		
		// SetNillableSprite sets the "sprite" field if the given value is not nil.
		func (iuo *ItemUpdateOne) SetNillableSprite(s *schema.Sprites) *ItemUpdateOne {
			if s != nil {
				iuo.SetSprite(*s)
			}
			return iuo
		}
	

	

	
		
		// ClearSprite clears the value of the "sprite" field.
		func (iuo *ItemUpdateOne) ClearSprite() *ItemUpdateOne {
			iuo.mutation.ClearSprite()
			return iuo
		}
	



	
	
	
	
		// AddWalletIDs adds the "wallets" edge to the WalletItems entity by IDs.
		func (iuo *ItemUpdateOne) AddWalletIDs(ids ... string) *ItemUpdateOne {
			iuo.mutation.AddWalletIDs(ids ...)
			return iuo
		}
	
	
	
	
	
	// AddWallets adds the "wallets" edges to the WalletItems entity.
	func (iuo *ItemUpdateOne) AddWallets(w ...*WalletItems) *ItemUpdateOne {
		ids := make([]string, len(w))
			for i := range w {
				ids[i] = w[i].ID
			}
			return iuo.AddWalletIDs(ids...)
	}

	
	
	
	
		// AddDopeIDs adds the "dopes" edge to the Dope entity by IDs.
		func (iuo *ItemUpdateOne) AddDopeIDs(ids ... string) *ItemUpdateOne {
			iuo.mutation.AddDopeIDs(ids ...)
			return iuo
		}
	
	
	
	
	
	// AddDopes adds the "dopes" edges to the Dope entity.
	func (iuo *ItemUpdateOne) AddDopes(d ...*Dope) *ItemUpdateOne {
		ids := make([]string, len(d))
			for i := range d {
				ids[i] = d[i].ID
			}
			return iuo.AddDopeIDs(ids...)
	}

	
	
	
	
		// AddHustlerWeaponIDs adds the "hustler_weapons" edge to the Hustler entity by IDs.
		func (iuo *ItemUpdateOne) AddHustlerWeaponIDs(ids ... string) *ItemUpdateOne {
			iuo.mutation.AddHustlerWeaponIDs(ids ...)
			return iuo
		}
	
	
	
	
	
	// AddHustlerWeapons adds the "hustler_weapons" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) AddHustlerWeapons(h ...*Hustler) *ItemUpdateOne {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.AddHustlerWeaponIDs(ids...)
	}

	
	
	
	
		// AddHustlerClotheIDs adds the "hustler_clothes" edge to the Hustler entity by IDs.
		func (iuo *ItemUpdateOne) AddHustlerClotheIDs(ids ... string) *ItemUpdateOne {
			iuo.mutation.AddHustlerClotheIDs(ids ...)
			return iuo
		}
	
	
	
	
	
	// AddHustlerClothes adds the "hustler_clothes" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) AddHustlerClothes(h ...*Hustler) *ItemUpdateOne {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.AddHustlerClotheIDs(ids...)
	}

	
	
	
	
		// AddHustlerVehicleIDs adds the "hustler_vehicles" edge to the Hustler entity by IDs.
		func (iuo *ItemUpdateOne) AddHustlerVehicleIDs(ids ... string) *ItemUpdateOne {
			iuo.mutation.AddHustlerVehicleIDs(ids ...)
			return iuo
		}
	
	
	
	
	
	// AddHustlerVehicles adds the "hustler_vehicles" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) AddHustlerVehicles(h ...*Hustler) *ItemUpdateOne {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.AddHustlerVehicleIDs(ids...)
	}

	
	
	
	
		// AddHustlerWaistIDs adds the "hustler_waists" edge to the Hustler entity by IDs.
		func (iuo *ItemUpdateOne) AddHustlerWaistIDs(ids ... string) *ItemUpdateOne {
			iuo.mutation.AddHustlerWaistIDs(ids ...)
			return iuo
		}
	
	
	
	
	
	// AddHustlerWaists adds the "hustler_waists" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) AddHustlerWaists(h ...*Hustler) *ItemUpdateOne {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.AddHustlerWaistIDs(ids...)
	}

	
	
	
	
		// AddHustlerFeetIDs adds the "hustler_feet" edge to the Hustler entity by IDs.
		func (iuo *ItemUpdateOne) AddHustlerFeetIDs(ids ... string) *ItemUpdateOne {
			iuo.mutation.AddHustlerFeetIDs(ids ...)
			return iuo
		}
	
	
	
	
	
	// AddHustlerFeet adds the "hustler_feet" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) AddHustlerFeet(h ...*Hustler) *ItemUpdateOne {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.AddHustlerFeetIDs(ids...)
	}

	
	
	
	
		// AddHustlerHandIDs adds the "hustler_hands" edge to the Hustler entity by IDs.
		func (iuo *ItemUpdateOne) AddHustlerHandIDs(ids ... string) *ItemUpdateOne {
			iuo.mutation.AddHustlerHandIDs(ids ...)
			return iuo
		}
	
	
	
	
	
	// AddHustlerHands adds the "hustler_hands" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) AddHustlerHands(h ...*Hustler) *ItemUpdateOne {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.AddHustlerHandIDs(ids...)
	}

	
	
	
	
		// AddHustlerDrugIDs adds the "hustler_drugs" edge to the Hustler entity by IDs.
		func (iuo *ItemUpdateOne) AddHustlerDrugIDs(ids ... string) *ItemUpdateOne {
			iuo.mutation.AddHustlerDrugIDs(ids ...)
			return iuo
		}
	
	
	
	
	
	// AddHustlerDrugs adds the "hustler_drugs" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) AddHustlerDrugs(h ...*Hustler) *ItemUpdateOne {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.AddHustlerDrugIDs(ids...)
	}

	
	
	
	
		// AddHustlerNeckIDs adds the "hustler_necks" edge to the Hustler entity by IDs.
		func (iuo *ItemUpdateOne) AddHustlerNeckIDs(ids ... string) *ItemUpdateOne {
			iuo.mutation.AddHustlerNeckIDs(ids ...)
			return iuo
		}
	
	
	
	
	
	// AddHustlerNecks adds the "hustler_necks" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) AddHustlerNecks(h ...*Hustler) *ItemUpdateOne {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.AddHustlerNeckIDs(ids...)
	}

	
	
	
	
		// AddHustlerRingIDs adds the "hustler_rings" edge to the Hustler entity by IDs.
		func (iuo *ItemUpdateOne) AddHustlerRingIDs(ids ... string) *ItemUpdateOne {
			iuo.mutation.AddHustlerRingIDs(ids ...)
			return iuo
		}
	
	
	
	
	
	// AddHustlerRings adds the "hustler_rings" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) AddHustlerRings(h ...*Hustler) *ItemUpdateOne {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.AddHustlerRingIDs(ids...)
	}

	
	
	
	
		// AddHustlerAccessoryIDs adds the "hustler_accessories" edge to the Hustler entity by IDs.
		func (iuo *ItemUpdateOne) AddHustlerAccessoryIDs(ids ... string) *ItemUpdateOne {
			iuo.mutation.AddHustlerAccessoryIDs(ids ...)
			return iuo
		}
	
	
	
	
	
	// AddHustlerAccessories adds the "hustler_accessories" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) AddHustlerAccessories(h ...*Hustler) *ItemUpdateOne {
		ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.AddHustlerAccessoryIDs(ids...)
	}

	
	
	
	
		// SetBaseID sets the "base" edge to the Item entity by ID.
		func (iuo *ItemUpdateOne) SetBaseID(id string) *ItemUpdateOne {
			iuo.mutation.SetBaseID(id)
			return iuo
		}
	
	
		
		// SetNillableBaseID sets the "base" edge to the Item entity by ID if the given value is not nil.
		func (iuo *ItemUpdateOne) SetNillableBaseID(id *string) *ItemUpdateOne {
			if id != nil {
				iuo = iuo.SetBaseID(*id)
			}
			return iuo
		}
	
	
	
	
	// SetBase sets the "base" edge to the Item entity.
	func (iuo *ItemUpdateOne) SetBase(i *Item) *ItemUpdateOne {
		return iuo.SetBaseID(i.ID)
	}

	
	
	
	
		// AddDerivativeIDs adds the "derivative" edge to the Item entity by IDs.
		func (iuo *ItemUpdateOne) AddDerivativeIDs(ids ... string) *ItemUpdateOne {
			iuo.mutation.AddDerivativeIDs(ids ...)
			return iuo
		}
	
	
	
	
	
	// AddDerivative adds the "derivative" edges to the Item entity.
	func (iuo *ItemUpdateOne) AddDerivative(i ...*Item) *ItemUpdateOne {
		ids := make([]string, len(i))
			for j := range i {
				ids[j] = i[j].ID
			}
			return iuo.AddDerivativeIDs(ids...)
	}

	
	
	
	
		// SetIndexID sets the "index" edge to the Search entity by ID.
		func (iuo *ItemUpdateOne) SetIndexID(id string) *ItemUpdateOne {
			iuo.mutation.SetIndexID(id)
			return iuo
		}
	
	
		
		// SetNillableIndexID sets the "index" edge to the Search entity by ID if the given value is not nil.
		func (iuo *ItemUpdateOne) SetNillableIndexID(id *string) *ItemUpdateOne {
			if id != nil {
				iuo = iuo.SetIndexID(*id)
			}
			return iuo
		}
	
	
	
	
	// SetIndex sets the "index" edge to the Search entity.
	func (iuo *ItemUpdateOne) SetIndex(s *Search) *ItemUpdateOne {
		return iuo.SetIndexID(s.ID)
	}


// Mutation returns the ItemMutation object of the builder.
func (iuo *ItemUpdateOne) Mutation() *ItemMutation {
	return iuo.mutation
}






	





	
	// ClearWallets clears all "wallets" edges to the WalletItems entity.
	func (iuo *ItemUpdateOne) ClearWallets() *ItemUpdateOne {
		iuo.mutation.ClearWallets()
		return iuo
	}
	
		
		
		
		
		// RemoveWalletIDs removes the "wallets" edge to WalletItems entities by IDs.
		func (iuo *ItemUpdateOne) RemoveWalletIDs(ids ...string) *ItemUpdateOne {
			iuo.mutation.RemoveWalletIDs(ids...)
			return iuo
		}
		
		// RemoveWallets removes "wallets" edges to WalletItems entities.
		func (iuo *ItemUpdateOne) RemoveWallets(w ...*WalletItems) *ItemUpdateOne {
			ids := make([]string, len(w))
			for i := range w {
				ids[i] = w[i].ID
			}
			return iuo.RemoveWalletIDs(ids...)
		}
	

	
	// ClearDopes clears all "dopes" edges to the Dope entity.
	func (iuo *ItemUpdateOne) ClearDopes() *ItemUpdateOne {
		iuo.mutation.ClearDopes()
		return iuo
	}
	
		
		
		
		
		// RemoveDopeIDs removes the "dopes" edge to Dope entities by IDs.
		func (iuo *ItemUpdateOne) RemoveDopeIDs(ids ...string) *ItemUpdateOne {
			iuo.mutation.RemoveDopeIDs(ids...)
			return iuo
		}
		
		// RemoveDopes removes "dopes" edges to Dope entities.
		func (iuo *ItemUpdateOne) RemoveDopes(d ...*Dope) *ItemUpdateOne {
			ids := make([]string, len(d))
			for i := range d {
				ids[i] = d[i].ID
			}
			return iuo.RemoveDopeIDs(ids...)
		}
	

	
	// ClearHustlerWeapons clears all "hustler_weapons" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) ClearHustlerWeapons() *ItemUpdateOne {
		iuo.mutation.ClearHustlerWeapons()
		return iuo
	}
	
		
		
		
		
		// RemoveHustlerWeaponIDs removes the "hustler_weapons" edge to Hustler entities by IDs.
		func (iuo *ItemUpdateOne) RemoveHustlerWeaponIDs(ids ...string) *ItemUpdateOne {
			iuo.mutation.RemoveHustlerWeaponIDs(ids...)
			return iuo
		}
		
		// RemoveHustlerWeapons removes "hustler_weapons" edges to Hustler entities.
		func (iuo *ItemUpdateOne) RemoveHustlerWeapons(h ...*Hustler) *ItemUpdateOne {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.RemoveHustlerWeaponIDs(ids...)
		}
	

	
	// ClearHustlerClothes clears all "hustler_clothes" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) ClearHustlerClothes() *ItemUpdateOne {
		iuo.mutation.ClearHustlerClothes()
		return iuo
	}
	
		
		
		
		
		// RemoveHustlerClotheIDs removes the "hustler_clothes" edge to Hustler entities by IDs.
		func (iuo *ItemUpdateOne) RemoveHustlerClotheIDs(ids ...string) *ItemUpdateOne {
			iuo.mutation.RemoveHustlerClotheIDs(ids...)
			return iuo
		}
		
		// RemoveHustlerClothes removes "hustler_clothes" edges to Hustler entities.
		func (iuo *ItemUpdateOne) RemoveHustlerClothes(h ...*Hustler) *ItemUpdateOne {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.RemoveHustlerClotheIDs(ids...)
		}
	

	
	// ClearHustlerVehicles clears all "hustler_vehicles" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) ClearHustlerVehicles() *ItemUpdateOne {
		iuo.mutation.ClearHustlerVehicles()
		return iuo
	}
	
		
		
		
		
		// RemoveHustlerVehicleIDs removes the "hustler_vehicles" edge to Hustler entities by IDs.
		func (iuo *ItemUpdateOne) RemoveHustlerVehicleIDs(ids ...string) *ItemUpdateOne {
			iuo.mutation.RemoveHustlerVehicleIDs(ids...)
			return iuo
		}
		
		// RemoveHustlerVehicles removes "hustler_vehicles" edges to Hustler entities.
		func (iuo *ItemUpdateOne) RemoveHustlerVehicles(h ...*Hustler) *ItemUpdateOne {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.RemoveHustlerVehicleIDs(ids...)
		}
	

	
	// ClearHustlerWaists clears all "hustler_waists" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) ClearHustlerWaists() *ItemUpdateOne {
		iuo.mutation.ClearHustlerWaists()
		return iuo
	}
	
		
		
		
		
		// RemoveHustlerWaistIDs removes the "hustler_waists" edge to Hustler entities by IDs.
		func (iuo *ItemUpdateOne) RemoveHustlerWaistIDs(ids ...string) *ItemUpdateOne {
			iuo.mutation.RemoveHustlerWaistIDs(ids...)
			return iuo
		}
		
		// RemoveHustlerWaists removes "hustler_waists" edges to Hustler entities.
		func (iuo *ItemUpdateOne) RemoveHustlerWaists(h ...*Hustler) *ItemUpdateOne {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.RemoveHustlerWaistIDs(ids...)
		}
	

	
	// ClearHustlerFeet clears all "hustler_feet" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) ClearHustlerFeet() *ItemUpdateOne {
		iuo.mutation.ClearHustlerFeet()
		return iuo
	}
	
		
		
		
		
		// RemoveHustlerFeetIDs removes the "hustler_feet" edge to Hustler entities by IDs.
		func (iuo *ItemUpdateOne) RemoveHustlerFeetIDs(ids ...string) *ItemUpdateOne {
			iuo.mutation.RemoveHustlerFeetIDs(ids...)
			return iuo
		}
		
		// RemoveHustlerFeet removes "hustler_feet" edges to Hustler entities.
		func (iuo *ItemUpdateOne) RemoveHustlerFeet(h ...*Hustler) *ItemUpdateOne {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.RemoveHustlerFeetIDs(ids...)
		}
	

	
	// ClearHustlerHands clears all "hustler_hands" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) ClearHustlerHands() *ItemUpdateOne {
		iuo.mutation.ClearHustlerHands()
		return iuo
	}
	
		
		
		
		
		// RemoveHustlerHandIDs removes the "hustler_hands" edge to Hustler entities by IDs.
		func (iuo *ItemUpdateOne) RemoveHustlerHandIDs(ids ...string) *ItemUpdateOne {
			iuo.mutation.RemoveHustlerHandIDs(ids...)
			return iuo
		}
		
		// RemoveHustlerHands removes "hustler_hands" edges to Hustler entities.
		func (iuo *ItemUpdateOne) RemoveHustlerHands(h ...*Hustler) *ItemUpdateOne {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.RemoveHustlerHandIDs(ids...)
		}
	

	
	// ClearHustlerDrugs clears all "hustler_drugs" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) ClearHustlerDrugs() *ItemUpdateOne {
		iuo.mutation.ClearHustlerDrugs()
		return iuo
	}
	
		
		
		
		
		// RemoveHustlerDrugIDs removes the "hustler_drugs" edge to Hustler entities by IDs.
		func (iuo *ItemUpdateOne) RemoveHustlerDrugIDs(ids ...string) *ItemUpdateOne {
			iuo.mutation.RemoveHustlerDrugIDs(ids...)
			return iuo
		}
		
		// RemoveHustlerDrugs removes "hustler_drugs" edges to Hustler entities.
		func (iuo *ItemUpdateOne) RemoveHustlerDrugs(h ...*Hustler) *ItemUpdateOne {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.RemoveHustlerDrugIDs(ids...)
		}
	

	
	// ClearHustlerNecks clears all "hustler_necks" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) ClearHustlerNecks() *ItemUpdateOne {
		iuo.mutation.ClearHustlerNecks()
		return iuo
	}
	
		
		
		
		
		// RemoveHustlerNeckIDs removes the "hustler_necks" edge to Hustler entities by IDs.
		func (iuo *ItemUpdateOne) RemoveHustlerNeckIDs(ids ...string) *ItemUpdateOne {
			iuo.mutation.RemoveHustlerNeckIDs(ids...)
			return iuo
		}
		
		// RemoveHustlerNecks removes "hustler_necks" edges to Hustler entities.
		func (iuo *ItemUpdateOne) RemoveHustlerNecks(h ...*Hustler) *ItemUpdateOne {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.RemoveHustlerNeckIDs(ids...)
		}
	

	
	// ClearHustlerRings clears all "hustler_rings" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) ClearHustlerRings() *ItemUpdateOne {
		iuo.mutation.ClearHustlerRings()
		return iuo
	}
	
		
		
		
		
		// RemoveHustlerRingIDs removes the "hustler_rings" edge to Hustler entities by IDs.
		func (iuo *ItemUpdateOne) RemoveHustlerRingIDs(ids ...string) *ItemUpdateOne {
			iuo.mutation.RemoveHustlerRingIDs(ids...)
			return iuo
		}
		
		// RemoveHustlerRings removes "hustler_rings" edges to Hustler entities.
		func (iuo *ItemUpdateOne) RemoveHustlerRings(h ...*Hustler) *ItemUpdateOne {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.RemoveHustlerRingIDs(ids...)
		}
	

	
	// ClearHustlerAccessories clears all "hustler_accessories" edges to the Hustler entity.
	func (iuo *ItemUpdateOne) ClearHustlerAccessories() *ItemUpdateOne {
		iuo.mutation.ClearHustlerAccessories()
		return iuo
	}
	
		
		
		
		
		// RemoveHustlerAccessoryIDs removes the "hustler_accessories" edge to Hustler entities by IDs.
		func (iuo *ItemUpdateOne) RemoveHustlerAccessoryIDs(ids ...string) *ItemUpdateOne {
			iuo.mutation.RemoveHustlerAccessoryIDs(ids...)
			return iuo
		}
		
		// RemoveHustlerAccessories removes "hustler_accessories" edges to Hustler entities.
		func (iuo *ItemUpdateOne) RemoveHustlerAccessories(h ...*Hustler) *ItemUpdateOne {
			ids := make([]string, len(h))
			for i := range h {
				ids[i] = h[i].ID
			}
			return iuo.RemoveHustlerAccessoryIDs(ids...)
		}
	

	
	// ClearBase clears the "base" edge to the Item entity.
	func (iuo *ItemUpdateOne) ClearBase() *ItemUpdateOne {
		iuo.mutation.ClearBase()
		return iuo
	}
	

	
	// ClearDerivative clears all "derivative" edges to the Item entity.
	func (iuo *ItemUpdateOne) ClearDerivative() *ItemUpdateOne {
		iuo.mutation.ClearDerivative()
		return iuo
	}
	
		
		
		
		
		// RemoveDerivativeIDs removes the "derivative" edge to Item entities by IDs.
		func (iuo *ItemUpdateOne) RemoveDerivativeIDs(ids ...string) *ItemUpdateOne {
			iuo.mutation.RemoveDerivativeIDs(ids...)
			return iuo
		}
		
		// RemoveDerivative removes "derivative" edges to Item entities.
		func (iuo *ItemUpdateOne) RemoveDerivative(i ...*Item) *ItemUpdateOne {
			ids := make([]string, len(i))
			for j := range i {
				ids[j] = i[j].ID
			}
			return iuo.RemoveDerivativeIDs(ids...)
		}
	

	
	// ClearIndex clears the "index" edge to the Search entity.
	func (iuo *ItemUpdateOne) ClearIndex() *ItemUpdateOne {
		iuo.mutation.ClearIndex()
		return iuo
	}
	




// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (iuo *ItemUpdateOne) Select(field string, fields ...string) *ItemUpdateOne {
	iuo.fields = append([]string{field}, fields...)
	return iuo
}

// Save executes the query and returns the updated Item entity.
func (iuo *ItemUpdateOne ) Save(ctx context.Context) (*Item, error) {
	var (
		err error
		node *Item
	)
	if len(iuo.hooks) == 0 {
			if err = iuo.check(); err != nil {
				return nil, err
			}
		node, err = iuo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*ItemMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
				if err = iuo.check(); err != nil {
					return nil, err
				}
			iuo.mutation = mutation
			node, err = iuo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(iuo.hooks) - 1; i >= 0; i-- {
			if iuo.hooks[i] == nil {
				return nil, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = iuo.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, iuo.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (iuo *ItemUpdateOne) SaveX(ctx context.Context) *Item {
	node, err := iuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (iuo *ItemUpdateOne) Exec(ctx context.Context) error {
	_, err := iuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (iuo *ItemUpdateOne) ExecX(ctx context.Context) {
	if err := iuo.Exec(ctx); err != nil {
		panic(err)
	}
}


	









	// check runs all checks and user-defined validators on the builder.
	func (iuo *ItemUpdateOne) check() error {
				if v, ok := iuo.mutation.Tier(); ok {
					if err := item.TierValidator(v); err != nil {
						return &ValidationError{Name: "tier", err: fmt.Errorf(`ent: validator failed for field "Item.tier": %w`, err)}
					}
				}
		return nil
	}






	
	






func (iuo *ItemUpdateOne) sqlSave(ctx context.Context) (_node *Item, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table: item.Table,
			Columns: item.Columns,
			ID: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: item.FieldID,
			},
		},
	}
		id, ok := iuo.mutation.ID()
		if !ok {
			return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Item.id" for update`)}
		}
		_spec.Node.ID.Value = id
		if fields := iuo.fields; len(fields) > 0 {
			_spec.Node.Columns = make([]string, 0, len(fields))
			_spec.Node.Columns = append(_spec.Node.Columns, item.FieldID)
			for _, f := range fields {
				if !item.ValidColumn(f) {
					return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
				}
				if f != item.FieldID {
					_spec.Node.Columns = append(_spec.Node.Columns, f)
				}
			}
		}
	if ps := iuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
				if iuo.mutation.NamePrefixCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeString,
						Column: item.FieldNamePrefix,
					})
				}
				if iuo.mutation.NameSuffixCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeString,
						Column: item.FieldNameSuffix,
					})
				}
				if iuo.mutation.SuffixCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeString,
						Column: item.FieldSuffix,
					})
				}
				if iuo.mutation.AugmentedCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeBool,
						Column: item.FieldAugmented,
					})
				}
				if value, ok := iuo.mutation.Count(); ok {
					_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
						Type: field.TypeInt,
						Value: value,
						Column: item.FieldCount,
					})
				}
					if value, ok := iuo.mutation.AddedCount(); ok {
						_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
							Type: field.TypeInt,
							Value: value,
							Column: item.FieldCount,
						})
					}
				if iuo.mutation.CountCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeInt,
						Column: item.FieldCount,
					})
				}
				if value, ok := iuo.mutation.Tier(); ok {
					_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
						Type: field.TypeEnum,
						Value: value,
						Column: item.FieldTier,
					})
				}
				if iuo.mutation.TierCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeEnum,
						Column: item.FieldTier,
					})
				}
				if value, ok := iuo.mutation.Greatness(); ok {
					_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
						Type: field.TypeInt,
						Value: value,
						Column: item.FieldGreatness,
					})
				}
					if value, ok := iuo.mutation.AddedGreatness(); ok {
						_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
							Type: field.TypeInt,
							Value: value,
							Column: item.FieldGreatness,
						})
					}
				if iuo.mutation.GreatnessCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeInt,
						Column: item.FieldGreatness,
					})
				}
				if value, ok := iuo.mutation.Rles(); ok {
					_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
						Type: field.TypeJSON,
						Value: value,
						Column: item.FieldRles,
					})
				}
				if iuo.mutation.RlesCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeJSON,
						Column: item.FieldRles,
					})
				}
				if value, ok := iuo.mutation.Svg(); ok {
					_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
						Type: field.TypeString,
						Value: value,
						Column: item.FieldSvg,
					})
				}
				if iuo.mutation.SvgCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeString,
						Column: item.FieldSvg,
					})
				}
				if value, ok := iuo.mutation.Sprite(); ok {
					_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
						Type: field.TypeJSON,
						Value: value,
						Column: item.FieldSprite,
					})
				}
				if iuo.mutation.SpriteCleared() {
					_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.TypeJSON,
						Column: item.FieldSprite,
					})
				}
		if iuo.mutation.WalletsCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.WalletsTable,
		Columns: []string{ item.WalletsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: walletitems.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iuo.mutation.RemovedWalletsIDs(); len(nodes) > 0 && !iuo.mutation.WalletsCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.WalletsTable,
		Columns: []string{ item.WalletsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: walletitems.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iuo.mutation.WalletsIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.WalletsTable,
		Columns: []string{ item.WalletsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: walletitems.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iuo.mutation.DopesCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2M,
		Inverse: true,
		Table: item.DopesTable,
		Columns: item.DopesPrimaryKey,
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: dope.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iuo.mutation.RemovedDopesIDs(); len(nodes) > 0 && !iuo.mutation.DopesCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2M,
		Inverse: true,
		Table: item.DopesTable,
		Columns: item.DopesPrimaryKey,
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: dope.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iuo.mutation.DopesIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2M,
		Inverse: true,
		Table: item.DopesTable,
		Columns: item.DopesPrimaryKey,
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: dope.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iuo.mutation.HustlerWeaponsCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerWeaponsTable,
		Columns: []string{ item.HustlerWeaponsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iuo.mutation.RemovedHustlerWeaponsIDs(); len(nodes) > 0 && !iuo.mutation.HustlerWeaponsCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerWeaponsTable,
		Columns: []string{ item.HustlerWeaponsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iuo.mutation.HustlerWeaponsIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerWeaponsTable,
		Columns: []string{ item.HustlerWeaponsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iuo.mutation.HustlerClothesCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerClothesTable,
		Columns: []string{ item.HustlerClothesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iuo.mutation.RemovedHustlerClothesIDs(); len(nodes) > 0 && !iuo.mutation.HustlerClothesCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerClothesTable,
		Columns: []string{ item.HustlerClothesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iuo.mutation.HustlerClothesIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerClothesTable,
		Columns: []string{ item.HustlerClothesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iuo.mutation.HustlerVehiclesCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerVehiclesTable,
		Columns: []string{ item.HustlerVehiclesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iuo.mutation.RemovedHustlerVehiclesIDs(); len(nodes) > 0 && !iuo.mutation.HustlerVehiclesCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerVehiclesTable,
		Columns: []string{ item.HustlerVehiclesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iuo.mutation.HustlerVehiclesIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerVehiclesTable,
		Columns: []string{ item.HustlerVehiclesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iuo.mutation.HustlerWaistsCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerWaistsTable,
		Columns: []string{ item.HustlerWaistsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iuo.mutation.RemovedHustlerWaistsIDs(); len(nodes) > 0 && !iuo.mutation.HustlerWaistsCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerWaistsTable,
		Columns: []string{ item.HustlerWaistsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iuo.mutation.HustlerWaistsIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerWaistsTable,
		Columns: []string{ item.HustlerWaistsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iuo.mutation.HustlerFeetCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerFeetTable,
		Columns: []string{ item.HustlerFeetColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iuo.mutation.RemovedHustlerFeetIDs(); len(nodes) > 0 && !iuo.mutation.HustlerFeetCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerFeetTable,
		Columns: []string{ item.HustlerFeetColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iuo.mutation.HustlerFeetIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerFeetTable,
		Columns: []string{ item.HustlerFeetColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iuo.mutation.HustlerHandsCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerHandsTable,
		Columns: []string{ item.HustlerHandsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iuo.mutation.RemovedHustlerHandsIDs(); len(nodes) > 0 && !iuo.mutation.HustlerHandsCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerHandsTable,
		Columns: []string{ item.HustlerHandsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iuo.mutation.HustlerHandsIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerHandsTable,
		Columns: []string{ item.HustlerHandsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iuo.mutation.HustlerDrugsCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerDrugsTable,
		Columns: []string{ item.HustlerDrugsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iuo.mutation.RemovedHustlerDrugsIDs(); len(nodes) > 0 && !iuo.mutation.HustlerDrugsCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerDrugsTable,
		Columns: []string{ item.HustlerDrugsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iuo.mutation.HustlerDrugsIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerDrugsTable,
		Columns: []string{ item.HustlerDrugsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iuo.mutation.HustlerNecksCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerNecksTable,
		Columns: []string{ item.HustlerNecksColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iuo.mutation.RemovedHustlerNecksIDs(); len(nodes) > 0 && !iuo.mutation.HustlerNecksCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerNecksTable,
		Columns: []string{ item.HustlerNecksColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iuo.mutation.HustlerNecksIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerNecksTable,
		Columns: []string{ item.HustlerNecksColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iuo.mutation.HustlerRingsCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerRingsTable,
		Columns: []string{ item.HustlerRingsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iuo.mutation.RemovedHustlerRingsIDs(); len(nodes) > 0 && !iuo.mutation.HustlerRingsCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerRingsTable,
		Columns: []string{ item.HustlerRingsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iuo.mutation.HustlerRingsIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerRingsTable,
		Columns: []string{ item.HustlerRingsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iuo.mutation.HustlerAccessoriesCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerAccessoriesTable,
		Columns: []string{ item.HustlerAccessoriesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iuo.mutation.RemovedHustlerAccessoriesIDs(); len(nodes) > 0 && !iuo.mutation.HustlerAccessoriesCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerAccessoriesTable,
		Columns: []string{ item.HustlerAccessoriesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iuo.mutation.HustlerAccessoriesIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.HustlerAccessoriesTable,
		Columns: []string{ item.HustlerAccessoriesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: hustler.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iuo.mutation.BaseCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: true,
		Table: item.BaseTable,
		Columns: []string{ item.BaseColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: item.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
		if nodes := iuo.mutation.BaseIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: true,
		Table: item.BaseTable,
		Columns: []string{ item.BaseColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: item.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iuo.mutation.DerivativeCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.DerivativeTable,
		Columns: []string{ item.DerivativeColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: item.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := iuo.mutation.RemovedDerivativeIDs(); len(nodes) > 0 && !iuo.mutation.DerivativeCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.DerivativeTable,
		Columns: []string{ item.DerivativeColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: item.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := iuo.mutation.DerivativeIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: item.DerivativeTable,
		Columns: []string{ item.DerivativeColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: item.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if iuo.mutation.IndexCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2O,
		Inverse: false,
		Table: item.IndexTable,
		Columns: []string{ item.IndexColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: search.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
		if nodes := iuo.mutation.IndexIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2O,
		Inverse: false,
		Table: item.IndexTable,
		Columns: []string{ item.IndexColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeString,
				Column: search.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		_node = &Item{config: iuo.config}
		_spec.Assign = _node.assignValues
		_spec.ScanValues = _node.scanValues
		if err = sqlgraph.UpdateNode(ctx, iuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{ item.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return nil, err
	}
	return _node, nil
}



