// Code generated by entc, DO NOT EDIT.

package dope

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/dopedao/dope-monorepo/packages/api/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// Clothes applies equality check predicate on the "clothes" field. It's identical to ClothesEQ.
func Clothes(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldClothes), v))
	})
}

// Foot applies equality check predicate on the "foot" field. It's identical to FootEQ.
func Foot(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFoot), v))
	})
}

// Hand applies equality check predicate on the "hand" field. It's identical to HandEQ.
func Hand(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHand), v))
	})
}

// Neck applies equality check predicate on the "neck" field. It's identical to NeckEQ.
func Neck(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNeck), v))
	})
}

// Ring applies equality check predicate on the "ring" field. It's identical to RingEQ.
func Ring(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRing), v))
	})
}

// Waist applies equality check predicate on the "waist" field. It's identical to WaistEQ.
func Waist(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWaist), v))
	})
}

// Weapon applies equality check predicate on the "weapon" field. It's identical to WeaponEQ.
func Weapon(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWeapon), v))
	})
}

// Drugs applies equality check predicate on the "drugs" field. It's identical to DrugsEQ.
func Drugs(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDrugs), v))
	})
}

// Vehicle applies equality check predicate on the "vehicle" field. It's identical to VehicleEQ.
func Vehicle(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldVehicle), v))
	})
}

// Claimed applies equality check predicate on the "claimed" field. It's identical to ClaimedEQ.
func Claimed(v bool) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldClaimed), v))
	})
}

// Opened applies equality check predicate on the "opened" field. It's identical to OpenedEQ.
func Opened(v bool) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOpened), v))
	})
}

// ClothesEQ applies the EQ predicate on the "clothes" field.
func ClothesEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldClothes), v))
	})
}

// ClothesNEQ applies the NEQ predicate on the "clothes" field.
func ClothesNEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldClothes), v))
	})
}

// ClothesIn applies the In predicate on the "clothes" field.
func ClothesIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldClothes), v...))
	})
}

// ClothesNotIn applies the NotIn predicate on the "clothes" field.
func ClothesNotIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldClothes), v...))
	})
}

// ClothesGT applies the GT predicate on the "clothes" field.
func ClothesGT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldClothes), v))
	})
}

// ClothesGTE applies the GTE predicate on the "clothes" field.
func ClothesGTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldClothes), v))
	})
}

// ClothesLT applies the LT predicate on the "clothes" field.
func ClothesLT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldClothes), v))
	})
}

// ClothesLTE applies the LTE predicate on the "clothes" field.
func ClothesLTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldClothes), v))
	})
}

// ClothesContains applies the Contains predicate on the "clothes" field.
func ClothesContains(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldClothes), v))
	})
}

// ClothesHasPrefix applies the HasPrefix predicate on the "clothes" field.
func ClothesHasPrefix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldClothes), v))
	})
}

// ClothesHasSuffix applies the HasSuffix predicate on the "clothes" field.
func ClothesHasSuffix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldClothes), v))
	})
}

// ClothesEqualFold applies the EqualFold predicate on the "clothes" field.
func ClothesEqualFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldClothes), v))
	})
}

// ClothesContainsFold applies the ContainsFold predicate on the "clothes" field.
func ClothesContainsFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldClothes), v))
	})
}

// FootEQ applies the EQ predicate on the "foot" field.
func FootEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFoot), v))
	})
}

// FootNEQ applies the NEQ predicate on the "foot" field.
func FootNEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFoot), v))
	})
}

// FootIn applies the In predicate on the "foot" field.
func FootIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFoot), v...))
	})
}

// FootNotIn applies the NotIn predicate on the "foot" field.
func FootNotIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFoot), v...))
	})
}

// FootGT applies the GT predicate on the "foot" field.
func FootGT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFoot), v))
	})
}

// FootGTE applies the GTE predicate on the "foot" field.
func FootGTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFoot), v))
	})
}

// FootLT applies the LT predicate on the "foot" field.
func FootLT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFoot), v))
	})
}

// FootLTE applies the LTE predicate on the "foot" field.
func FootLTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFoot), v))
	})
}

// FootContains applies the Contains predicate on the "foot" field.
func FootContains(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldFoot), v))
	})
}

// FootHasPrefix applies the HasPrefix predicate on the "foot" field.
func FootHasPrefix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldFoot), v))
	})
}

// FootHasSuffix applies the HasSuffix predicate on the "foot" field.
func FootHasSuffix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldFoot), v))
	})
}

// FootEqualFold applies the EqualFold predicate on the "foot" field.
func FootEqualFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldFoot), v))
	})
}

// FootContainsFold applies the ContainsFold predicate on the "foot" field.
func FootContainsFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldFoot), v))
	})
}

// HandEQ applies the EQ predicate on the "hand" field.
func HandEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHand), v))
	})
}

// HandNEQ applies the NEQ predicate on the "hand" field.
func HandNEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldHand), v))
	})
}

// HandIn applies the In predicate on the "hand" field.
func HandIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldHand), v...))
	})
}

// HandNotIn applies the NotIn predicate on the "hand" field.
func HandNotIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldHand), v...))
	})
}

// HandGT applies the GT predicate on the "hand" field.
func HandGT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldHand), v))
	})
}

// HandGTE applies the GTE predicate on the "hand" field.
func HandGTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldHand), v))
	})
}

// HandLT applies the LT predicate on the "hand" field.
func HandLT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldHand), v))
	})
}

// HandLTE applies the LTE predicate on the "hand" field.
func HandLTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldHand), v))
	})
}

// HandContains applies the Contains predicate on the "hand" field.
func HandContains(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldHand), v))
	})
}

// HandHasPrefix applies the HasPrefix predicate on the "hand" field.
func HandHasPrefix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldHand), v))
	})
}

// HandHasSuffix applies the HasSuffix predicate on the "hand" field.
func HandHasSuffix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldHand), v))
	})
}

// HandEqualFold applies the EqualFold predicate on the "hand" field.
func HandEqualFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldHand), v))
	})
}

// HandContainsFold applies the ContainsFold predicate on the "hand" field.
func HandContainsFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldHand), v))
	})
}

// NeckEQ applies the EQ predicate on the "neck" field.
func NeckEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNeck), v))
	})
}

// NeckNEQ applies the NEQ predicate on the "neck" field.
func NeckNEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldNeck), v))
	})
}

// NeckIn applies the In predicate on the "neck" field.
func NeckIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldNeck), v...))
	})
}

// NeckNotIn applies the NotIn predicate on the "neck" field.
func NeckNotIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldNeck), v...))
	})
}

// NeckGT applies the GT predicate on the "neck" field.
func NeckGT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldNeck), v))
	})
}

// NeckGTE applies the GTE predicate on the "neck" field.
func NeckGTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldNeck), v))
	})
}

// NeckLT applies the LT predicate on the "neck" field.
func NeckLT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldNeck), v))
	})
}

// NeckLTE applies the LTE predicate on the "neck" field.
func NeckLTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldNeck), v))
	})
}

// NeckContains applies the Contains predicate on the "neck" field.
func NeckContains(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldNeck), v))
	})
}

// NeckHasPrefix applies the HasPrefix predicate on the "neck" field.
func NeckHasPrefix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldNeck), v))
	})
}

// NeckHasSuffix applies the HasSuffix predicate on the "neck" field.
func NeckHasSuffix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldNeck), v))
	})
}

// NeckEqualFold applies the EqualFold predicate on the "neck" field.
func NeckEqualFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldNeck), v))
	})
}

// NeckContainsFold applies the ContainsFold predicate on the "neck" field.
func NeckContainsFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldNeck), v))
	})
}

// RingEQ applies the EQ predicate on the "ring" field.
func RingEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRing), v))
	})
}

// RingNEQ applies the NEQ predicate on the "ring" field.
func RingNEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRing), v))
	})
}

// RingIn applies the In predicate on the "ring" field.
func RingIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRing), v...))
	})
}

// RingNotIn applies the NotIn predicate on the "ring" field.
func RingNotIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRing), v...))
	})
}

// RingGT applies the GT predicate on the "ring" field.
func RingGT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRing), v))
	})
}

// RingGTE applies the GTE predicate on the "ring" field.
func RingGTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRing), v))
	})
}

// RingLT applies the LT predicate on the "ring" field.
func RingLT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRing), v))
	})
}

// RingLTE applies the LTE predicate on the "ring" field.
func RingLTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRing), v))
	})
}

// RingContains applies the Contains predicate on the "ring" field.
func RingContains(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRing), v))
	})
}

// RingHasPrefix applies the HasPrefix predicate on the "ring" field.
func RingHasPrefix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRing), v))
	})
}

// RingHasSuffix applies the HasSuffix predicate on the "ring" field.
func RingHasSuffix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRing), v))
	})
}

// RingEqualFold applies the EqualFold predicate on the "ring" field.
func RingEqualFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRing), v))
	})
}

// RingContainsFold applies the ContainsFold predicate on the "ring" field.
func RingContainsFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRing), v))
	})
}

// WaistEQ applies the EQ predicate on the "waist" field.
func WaistEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWaist), v))
	})
}

// WaistNEQ applies the NEQ predicate on the "waist" field.
func WaistNEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWaist), v))
	})
}

// WaistIn applies the In predicate on the "waist" field.
func WaistIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldWaist), v...))
	})
}

// WaistNotIn applies the NotIn predicate on the "waist" field.
func WaistNotIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldWaist), v...))
	})
}

// WaistGT applies the GT predicate on the "waist" field.
func WaistGT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldWaist), v))
	})
}

// WaistGTE applies the GTE predicate on the "waist" field.
func WaistGTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldWaist), v))
	})
}

// WaistLT applies the LT predicate on the "waist" field.
func WaistLT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldWaist), v))
	})
}

// WaistLTE applies the LTE predicate on the "waist" field.
func WaistLTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldWaist), v))
	})
}

// WaistContains applies the Contains predicate on the "waist" field.
func WaistContains(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldWaist), v))
	})
}

// WaistHasPrefix applies the HasPrefix predicate on the "waist" field.
func WaistHasPrefix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldWaist), v))
	})
}

// WaistHasSuffix applies the HasSuffix predicate on the "waist" field.
func WaistHasSuffix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldWaist), v))
	})
}

// WaistEqualFold applies the EqualFold predicate on the "waist" field.
func WaistEqualFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldWaist), v))
	})
}

// WaistContainsFold applies the ContainsFold predicate on the "waist" field.
func WaistContainsFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldWaist), v))
	})
}

// WeaponEQ applies the EQ predicate on the "weapon" field.
func WeaponEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWeapon), v))
	})
}

// WeaponNEQ applies the NEQ predicate on the "weapon" field.
func WeaponNEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWeapon), v))
	})
}

// WeaponIn applies the In predicate on the "weapon" field.
func WeaponIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldWeapon), v...))
	})
}

// WeaponNotIn applies the NotIn predicate on the "weapon" field.
func WeaponNotIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldWeapon), v...))
	})
}

// WeaponGT applies the GT predicate on the "weapon" field.
func WeaponGT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldWeapon), v))
	})
}

// WeaponGTE applies the GTE predicate on the "weapon" field.
func WeaponGTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldWeapon), v))
	})
}

// WeaponLT applies the LT predicate on the "weapon" field.
func WeaponLT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldWeapon), v))
	})
}

// WeaponLTE applies the LTE predicate on the "weapon" field.
func WeaponLTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldWeapon), v))
	})
}

// WeaponContains applies the Contains predicate on the "weapon" field.
func WeaponContains(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldWeapon), v))
	})
}

// WeaponHasPrefix applies the HasPrefix predicate on the "weapon" field.
func WeaponHasPrefix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldWeapon), v))
	})
}

// WeaponHasSuffix applies the HasSuffix predicate on the "weapon" field.
func WeaponHasSuffix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldWeapon), v))
	})
}

// WeaponEqualFold applies the EqualFold predicate on the "weapon" field.
func WeaponEqualFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldWeapon), v))
	})
}

// WeaponContainsFold applies the ContainsFold predicate on the "weapon" field.
func WeaponContainsFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldWeapon), v))
	})
}

// DrugsEQ applies the EQ predicate on the "drugs" field.
func DrugsEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDrugs), v))
	})
}

// DrugsNEQ applies the NEQ predicate on the "drugs" field.
func DrugsNEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDrugs), v))
	})
}

// DrugsIn applies the In predicate on the "drugs" field.
func DrugsIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDrugs), v...))
	})
}

// DrugsNotIn applies the NotIn predicate on the "drugs" field.
func DrugsNotIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDrugs), v...))
	})
}

// DrugsGT applies the GT predicate on the "drugs" field.
func DrugsGT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDrugs), v))
	})
}

// DrugsGTE applies the GTE predicate on the "drugs" field.
func DrugsGTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDrugs), v))
	})
}

// DrugsLT applies the LT predicate on the "drugs" field.
func DrugsLT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDrugs), v))
	})
}

// DrugsLTE applies the LTE predicate on the "drugs" field.
func DrugsLTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDrugs), v))
	})
}

// DrugsContains applies the Contains predicate on the "drugs" field.
func DrugsContains(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldDrugs), v))
	})
}

// DrugsHasPrefix applies the HasPrefix predicate on the "drugs" field.
func DrugsHasPrefix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldDrugs), v))
	})
}

// DrugsHasSuffix applies the HasSuffix predicate on the "drugs" field.
func DrugsHasSuffix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldDrugs), v))
	})
}

// DrugsEqualFold applies the EqualFold predicate on the "drugs" field.
func DrugsEqualFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldDrugs), v))
	})
}

// DrugsContainsFold applies the ContainsFold predicate on the "drugs" field.
func DrugsContainsFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldDrugs), v))
	})
}

// VehicleEQ applies the EQ predicate on the "vehicle" field.
func VehicleEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldVehicle), v))
	})
}

// VehicleNEQ applies the NEQ predicate on the "vehicle" field.
func VehicleNEQ(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldVehicle), v))
	})
}

// VehicleIn applies the In predicate on the "vehicle" field.
func VehicleIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldVehicle), v...))
	})
}

// VehicleNotIn applies the NotIn predicate on the "vehicle" field.
func VehicleNotIn(vs ...string) predicate.Dope {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Dope(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldVehicle), v...))
	})
}

// VehicleGT applies the GT predicate on the "vehicle" field.
func VehicleGT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldVehicle), v))
	})
}

// VehicleGTE applies the GTE predicate on the "vehicle" field.
func VehicleGTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldVehicle), v))
	})
}

// VehicleLT applies the LT predicate on the "vehicle" field.
func VehicleLT(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldVehicle), v))
	})
}

// VehicleLTE applies the LTE predicate on the "vehicle" field.
func VehicleLTE(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldVehicle), v))
	})
}

// VehicleContains applies the Contains predicate on the "vehicle" field.
func VehicleContains(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldVehicle), v))
	})
}

// VehicleHasPrefix applies the HasPrefix predicate on the "vehicle" field.
func VehicleHasPrefix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldVehicle), v))
	})
}

// VehicleHasSuffix applies the HasSuffix predicate on the "vehicle" field.
func VehicleHasSuffix(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldVehicle), v))
	})
}

// VehicleEqualFold applies the EqualFold predicate on the "vehicle" field.
func VehicleEqualFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldVehicle), v))
	})
}

// VehicleContainsFold applies the ContainsFold predicate on the "vehicle" field.
func VehicleContainsFold(v string) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldVehicle), v))
	})
}

// ClaimedEQ applies the EQ predicate on the "claimed" field.
func ClaimedEQ(v bool) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldClaimed), v))
	})
}

// ClaimedNEQ applies the NEQ predicate on the "claimed" field.
func ClaimedNEQ(v bool) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldClaimed), v))
	})
}

// OpenedEQ applies the EQ predicate on the "opened" field.
func OpenedEQ(v bool) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOpened), v))
	})
}

// OpenedNEQ applies the NEQ predicate on the "opened" field.
func OpenedNEQ(v bool) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldOpened), v))
	})
}

// HasWallet applies the HasEdge predicate on the "wallet" edge.
func HasWallet() predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(WalletTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, WalletTable, WalletColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasWalletWith applies the HasEdge predicate on the "wallet" edge with a given conditions (other predicates).
func HasWalletWith(preds ...predicate.Wallet) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(WalletInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, WalletTable, WalletColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Dope) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Dope) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Dope) predicate.Dope {
	return predicate.Dope(func(s *sql.Selector) {
		p(s.Not())
	})
}
