// Code generated by entc, DO NOT EDIT.

package listing

import (
	"fmt"
	"io"
	"strconv"
)

const (
	// Label holds the string label denoting the listing type in the database.
	Label = "listing"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldActive holds the string denoting the active field in the database.
	FieldActive = "active"
	// FieldSource holds the string denoting the source field in the database.
	FieldSource = "source"
	// FieldOrder holds the string denoting the order field in the database.
	FieldOrder = "order"
	// EdgeDope holds the string denoting the dope edge name in mutations.
	EdgeDope = "dope"
	// EdgeDopeLastsales holds the string denoting the dope_lastsales edge name in mutations.
	EdgeDopeLastsales = "dope_lastsales"
	// EdgeInputs holds the string denoting the inputs edge name in mutations.
	EdgeInputs = "inputs"
	// EdgeOutputs holds the string denoting the outputs edge name in mutations.
	EdgeOutputs = "outputs"
	// Table holds the table name of the listing in the database.
	Table = "listings"
	// DopeTable is the table that holds the dope relation/edge.
	DopeTable = "listings"
	// DopeInverseTable is the table name for the Dope entity.
	// It exists in this package in order to avoid circular dependency with the "dope" package.
	DopeInverseTable = "dopes"
	// DopeColumn is the table column denoting the dope relation/edge.
	DopeColumn = "dope_listings"
	// DopeLastsalesTable is the table that holds the dope_lastsales relation/edge.
	DopeLastsalesTable = "dopes"
	// DopeLastsalesInverseTable is the table name for the Dope entity.
	// It exists in this package in order to avoid circular dependency with the "dope" package.
	DopeLastsalesInverseTable = "dopes"
	// DopeLastsalesColumn is the table column denoting the dope_lastsales relation/edge.
	DopeLastsalesColumn = "listing_dope_lastsales"
	// InputsTable is the table that holds the inputs relation/edge.
	InputsTable = "amounts"
	// InputsInverseTable is the table name for the Amount entity.
	// It exists in this package in order to avoid circular dependency with the "amount" package.
	InputsInverseTable = "amounts"
	// InputsColumn is the table column denoting the inputs relation/edge.
	InputsColumn = "listing_inputs"
	// OutputsTable is the table that holds the outputs relation/edge.
	OutputsTable = "amounts"
	// OutputsInverseTable is the table name for the Amount entity.
	// It exists in this package in order to avoid circular dependency with the "amount" package.
	OutputsInverseTable = "amounts"
	// OutputsColumn is the table column denoting the outputs relation/edge.
	OutputsColumn = "listing_outputs"
)

// Columns holds all SQL columns for listing fields.
var Columns = []string{
	FieldID,
	FieldActive,
	FieldSource,
	FieldOrder,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "listings"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"dope_listings",
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

// Source defines the type for the "source" enum field.
type Source string

// Source values.
const (
	SourceOPENSEA  Source = "OPENSEA"
	SourceSWAPMEET Source = "SWAPMEET"
)

func (s Source) String() string {
	return string(s)
}

// SourceValidator is a validator for the "source" field enum values. It is called by the builders before save.
func SourceValidator(s Source) error {
	switch s {
	case SourceOPENSEA, SourceSWAPMEET:
		return nil
	default:
		return fmt.Errorf("listing: invalid enum value for source field: %q", s)
	}
}

// MarshalGQL implements graphql.Marshaler interface.
func (s Source) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(s.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (s *Source) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("enum %T must be a string", val)
	}
	*s = Source(str)
	if err := SourceValidator(*s); err != nil {
		return fmt.Errorf("%s is not a valid Source", str)
	}
	return nil
}
