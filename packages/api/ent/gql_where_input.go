// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"

	"github.com/dopedao/dope-monorepo/packages/api/ent/asset"
	"github.com/dopedao/dope-monorepo/packages/api/ent/bodypart"
	"github.com/dopedao/dope-monorepo/packages/api/ent/dope"
	"github.com/dopedao/dope-monorepo/packages/api/ent/event"
	"github.com/dopedao/dope-monorepo/packages/api/ent/hustler"
	"github.com/dopedao/dope-monorepo/packages/api/ent/item"
	"github.com/dopedao/dope-monorepo/packages/api/ent/listing"
	"github.com/dopedao/dope-monorepo/packages/api/ent/paymenttoken"
	"github.com/dopedao/dope-monorepo/packages/api/ent/predicate"
	"github.com/dopedao/dope-monorepo/packages/api/ent/schema"
	"github.com/dopedao/dope-monorepo/packages/api/ent/syncstate"
	"github.com/dopedao/dope-monorepo/packages/api/ent/wallet"
	"github.com/dopedao/dope-monorepo/packages/api/ent/walletitems"
)

// AssetWhereInput represents a where input for filtering Asset queries.
type AssetWhereInput struct {
	Not *AssetWhereInput   `json:"not,omitempty"`
	Or  []*AssetWhereInput `json:"or,omitempty"`
	And []*AssetWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "type" field predicates.
	Type      *asset.Type  `json:"type,omitempty"`
	TypeNEQ   *asset.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []asset.Type `json:"typeIn,omitempty"`
	TypeNotIn []asset.Type `json:"typeNotIn,omitempty"`

	// "symbol" field predicates.
	Symbol             *string  `json:"symbol,omitempty"`
	SymbolNEQ          *string  `json:"symbolNEQ,omitempty"`
	SymbolIn           []string `json:"symbolIn,omitempty"`
	SymbolNotIn        []string `json:"symbolNotIn,omitempty"`
	SymbolGT           *string  `json:"symbolGT,omitempty"`
	SymbolGTE          *string  `json:"symbolGTE,omitempty"`
	SymbolLT           *string  `json:"symbolLT,omitempty"`
	SymbolLTE          *string  `json:"symbolLTE,omitempty"`
	SymbolContains     *string  `json:"symbolContains,omitempty"`
	SymbolHasPrefix    *string  `json:"symbolHasPrefix,omitempty"`
	SymbolHasSuffix    *string  `json:"symbolHasSuffix,omitempty"`
	SymbolEqualFold    *string  `json:"symbolEqualFold,omitempty"`
	SymbolContainsFold *string  `json:"symbolContainsFold,omitempty"`

	// "amount" field predicates.
	Amount      *schema.BigInt  `json:"amount,omitempty"`
	AmountNEQ   *schema.BigInt  `json:"amountNEQ,omitempty"`
	AmountIn    []schema.BigInt `json:"amountIn,omitempty"`
	AmountNotIn []schema.BigInt `json:"amountNotIn,omitempty"`
	AmountGT    *schema.BigInt  `json:"amountGT,omitempty"`
	AmountGTE   *schema.BigInt  `json:"amountGTE,omitempty"`
	AmountLT    *schema.BigInt  `json:"amountLT,omitempty"`
	AmountLTE   *schema.BigInt  `json:"amountLTE,omitempty"`

	// "assetId" field predicates.
	AssetId      *schema.BigInt  `json:"assetid,omitempty"`
	AssetIdNEQ   *schema.BigInt  `json:"assetidNEQ,omitempty"`
	AssetIdIn    []schema.BigInt `json:"assetidIn,omitempty"`
	AssetIdNotIn []schema.BigInt `json:"assetidNotIn,omitempty"`
	AssetIdGT    *schema.BigInt  `json:"assetidGT,omitempty"`
	AssetIdGTE   *schema.BigInt  `json:"assetidGTE,omitempty"`
	AssetIdLT    *schema.BigInt  `json:"assetidLT,omitempty"`
	AssetIdLTE   *schema.BigInt  `json:"assetidLTE,omitempty"`

	// "price" field predicates.
	Price      *float64  `json:"price,omitempty"`
	PriceNEQ   *float64  `json:"priceNEQ,omitempty"`
	PriceIn    []float64 `json:"priceIn,omitempty"`
	PriceNotIn []float64 `json:"priceNotIn,omitempty"`
	PriceGT    *float64  `json:"priceGT,omitempty"`
	PriceGTE   *float64  `json:"priceGTE,omitempty"`
	PriceLT    *float64  `json:"priceLT,omitempty"`
	PriceLTE   *float64  `json:"priceLTE,omitempty"`

	// "paymentToken" edge predicates.
	HasPaymentToken     *bool                     `json:"hasPaymentToken,omitempty"`
	HasPaymentTokenWith []*PaymentTokenWhereInput `json:"hasPaymentTokenWith,omitempty"`
}

// Filter applies the AssetWhereInput filter on the AssetQuery builder.
func (i *AssetWhereInput) Filter(q *AssetQuery) (*AssetQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering assets.
// An error is returned if the input is empty or invalid.
func (i *AssetWhereInput) P() (predicate.Asset, error) {
	var predicates []predicate.Asset
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, asset.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Asset, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, asset.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Asset, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, asset.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, asset.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, asset.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, asset.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, asset.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, asset.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, asset.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, asset.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, asset.IDLTE(*i.IDLTE))
	}
	if i.Address != nil {
		predicates = append(predicates, asset.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, asset.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, asset.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, asset.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, asset.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, asset.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, asset.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, asset.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, asset.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, asset.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, asset.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, asset.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, asset.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, asset.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, asset.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, asset.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, asset.TypeNotIn(i.TypeNotIn...))
	}
	if i.Symbol != nil {
		predicates = append(predicates, asset.SymbolEQ(*i.Symbol))
	}
	if i.SymbolNEQ != nil {
		predicates = append(predicates, asset.SymbolNEQ(*i.SymbolNEQ))
	}
	if len(i.SymbolIn) > 0 {
		predicates = append(predicates, asset.SymbolIn(i.SymbolIn...))
	}
	if len(i.SymbolNotIn) > 0 {
		predicates = append(predicates, asset.SymbolNotIn(i.SymbolNotIn...))
	}
	if i.SymbolGT != nil {
		predicates = append(predicates, asset.SymbolGT(*i.SymbolGT))
	}
	if i.SymbolGTE != nil {
		predicates = append(predicates, asset.SymbolGTE(*i.SymbolGTE))
	}
	if i.SymbolLT != nil {
		predicates = append(predicates, asset.SymbolLT(*i.SymbolLT))
	}
	if i.SymbolLTE != nil {
		predicates = append(predicates, asset.SymbolLTE(*i.SymbolLTE))
	}
	if i.SymbolContains != nil {
		predicates = append(predicates, asset.SymbolContains(*i.SymbolContains))
	}
	if i.SymbolHasPrefix != nil {
		predicates = append(predicates, asset.SymbolHasPrefix(*i.SymbolHasPrefix))
	}
	if i.SymbolHasSuffix != nil {
		predicates = append(predicates, asset.SymbolHasSuffix(*i.SymbolHasSuffix))
	}
	if i.SymbolEqualFold != nil {
		predicates = append(predicates, asset.SymbolEqualFold(*i.SymbolEqualFold))
	}
	if i.SymbolContainsFold != nil {
		predicates = append(predicates, asset.SymbolContainsFold(*i.SymbolContainsFold))
	}
	if i.Amount != nil {
		predicates = append(predicates, asset.AmountEQ(*i.Amount))
	}
	if i.AmountNEQ != nil {
		predicates = append(predicates, asset.AmountNEQ(*i.AmountNEQ))
	}
	if len(i.AmountIn) > 0 {
		predicates = append(predicates, asset.AmountIn(i.AmountIn...))
	}
	if len(i.AmountNotIn) > 0 {
		predicates = append(predicates, asset.AmountNotIn(i.AmountNotIn...))
	}
	if i.AmountGT != nil {
		predicates = append(predicates, asset.AmountGT(*i.AmountGT))
	}
	if i.AmountGTE != nil {
		predicates = append(predicates, asset.AmountGTE(*i.AmountGTE))
	}
	if i.AmountLT != nil {
		predicates = append(predicates, asset.AmountLT(*i.AmountLT))
	}
	if i.AmountLTE != nil {
		predicates = append(predicates, asset.AmountLTE(*i.AmountLTE))
	}
	if i.AssetId != nil {
		predicates = append(predicates, asset.AssetIdEQ(*i.AssetId))
	}
	if i.AssetIdNEQ != nil {
		predicates = append(predicates, asset.AssetIdNEQ(*i.AssetIdNEQ))
	}
	if len(i.AssetIdIn) > 0 {
		predicates = append(predicates, asset.AssetIdIn(i.AssetIdIn...))
	}
	if len(i.AssetIdNotIn) > 0 {
		predicates = append(predicates, asset.AssetIdNotIn(i.AssetIdNotIn...))
	}
	if i.AssetIdGT != nil {
		predicates = append(predicates, asset.AssetIdGT(*i.AssetIdGT))
	}
	if i.AssetIdGTE != nil {
		predicates = append(predicates, asset.AssetIdGTE(*i.AssetIdGTE))
	}
	if i.AssetIdLT != nil {
		predicates = append(predicates, asset.AssetIdLT(*i.AssetIdLT))
	}
	if i.AssetIdLTE != nil {
		predicates = append(predicates, asset.AssetIdLTE(*i.AssetIdLTE))
	}
	if i.Price != nil {
		predicates = append(predicates, asset.PriceEQ(*i.Price))
	}
	if i.PriceNEQ != nil {
		predicates = append(predicates, asset.PriceNEQ(*i.PriceNEQ))
	}
	if len(i.PriceIn) > 0 {
		predicates = append(predicates, asset.PriceIn(i.PriceIn...))
	}
	if len(i.PriceNotIn) > 0 {
		predicates = append(predicates, asset.PriceNotIn(i.PriceNotIn...))
	}
	if i.PriceGT != nil {
		predicates = append(predicates, asset.PriceGT(*i.PriceGT))
	}
	if i.PriceGTE != nil {
		predicates = append(predicates, asset.PriceGTE(*i.PriceGTE))
	}
	if i.PriceLT != nil {
		predicates = append(predicates, asset.PriceLT(*i.PriceLT))
	}
	if i.PriceLTE != nil {
		predicates = append(predicates, asset.PriceLTE(*i.PriceLTE))
	}

	if i.HasPaymentToken != nil {
		p := asset.HasPaymentToken()
		if !*i.HasPaymentToken {
			p = asset.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPaymentTokenWith) > 0 {
		with := make([]predicate.PaymentToken, 0, len(i.HasPaymentTokenWith))
		for _, w := range i.HasPaymentTokenWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, asset.HasPaymentTokenWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate AssetWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return asset.And(predicates...), nil
	}
}

// BodyPartWhereInput represents a where input for filtering BodyPart queries.
type BodyPartWhereInput struct {
	Not *BodyPartWhereInput   `json:"not,omitempty"`
	Or  []*BodyPartWhereInput `json:"or,omitempty"`
	And []*BodyPartWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type      *bodypart.Type  `json:"type,omitempty"`
	TypeNEQ   *bodypart.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []bodypart.Type `json:"typeIn,omitempty"`
	TypeNotIn []bodypart.Type `json:"typeNotIn,omitempty"`

	// "sex" field predicates.
	Sex      *bodypart.Sex  `json:"sex,omitempty"`
	SexNEQ   *bodypart.Sex  `json:"sexNEQ,omitempty"`
	SexIn    []bodypart.Sex `json:"sexIn,omitempty"`
	SexNotIn []bodypart.Sex `json:"sexNotIn,omitempty"`

	// "rle" field predicates.
	Rle             *string  `json:"rle,omitempty"`
	RleNEQ          *string  `json:"rleNEQ,omitempty"`
	RleIn           []string `json:"rleIn,omitempty"`
	RleNotIn        []string `json:"rleNotIn,omitempty"`
	RleGT           *string  `json:"rleGT,omitempty"`
	RleGTE          *string  `json:"rleGTE,omitempty"`
	RleLT           *string  `json:"rleLT,omitempty"`
	RleLTE          *string  `json:"rleLTE,omitempty"`
	RleContains     *string  `json:"rleContains,omitempty"`
	RleHasPrefix    *string  `json:"rleHasPrefix,omitempty"`
	RleHasSuffix    *string  `json:"rleHasSuffix,omitempty"`
	RleEqualFold    *string  `json:"rleEqualFold,omitempty"`
	RleContainsFold *string  `json:"rleContainsFold,omitempty"`

	// "hustler_bodies" edge predicates.
	HasHustlerBodies     *bool                `json:"hasHustlerBodies,omitempty"`
	HasHustlerBodiesWith []*HustlerWhereInput `json:"hasHustlerBodiesWith,omitempty"`

	// "hustler_hairs" edge predicates.
	HasHustlerHairs     *bool                `json:"hasHustlerHairs,omitempty"`
	HasHustlerHairsWith []*HustlerWhereInput `json:"hasHustlerHairsWith,omitempty"`

	// "hustler_beards" edge predicates.
	HasHustlerBeards     *bool                `json:"hasHustlerBeards,omitempty"`
	HasHustlerBeardsWith []*HustlerWhereInput `json:"hasHustlerBeardsWith,omitempty"`
}

// Filter applies the BodyPartWhereInput filter on the BodyPartQuery builder.
func (i *BodyPartWhereInput) Filter(q *BodyPartQuery) (*BodyPartQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering bodyparts.
// An error is returned if the input is empty or invalid.
func (i *BodyPartWhereInput) P() (predicate.BodyPart, error) {
	var predicates []predicate.BodyPart
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, bodypart.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.BodyPart, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, bodypart.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.BodyPart, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, bodypart.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, bodypart.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, bodypart.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, bodypart.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, bodypart.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, bodypart.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, bodypart.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, bodypart.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, bodypart.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, bodypart.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, bodypart.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, bodypart.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, bodypart.TypeNotIn(i.TypeNotIn...))
	}
	if i.Sex != nil {
		predicates = append(predicates, bodypart.SexEQ(*i.Sex))
	}
	if i.SexNEQ != nil {
		predicates = append(predicates, bodypart.SexNEQ(*i.SexNEQ))
	}
	if len(i.SexIn) > 0 {
		predicates = append(predicates, bodypart.SexIn(i.SexIn...))
	}
	if len(i.SexNotIn) > 0 {
		predicates = append(predicates, bodypart.SexNotIn(i.SexNotIn...))
	}
	if i.Rle != nil {
		predicates = append(predicates, bodypart.RleEQ(*i.Rle))
	}
	if i.RleNEQ != nil {
		predicates = append(predicates, bodypart.RleNEQ(*i.RleNEQ))
	}
	if len(i.RleIn) > 0 {
		predicates = append(predicates, bodypart.RleIn(i.RleIn...))
	}
	if len(i.RleNotIn) > 0 {
		predicates = append(predicates, bodypart.RleNotIn(i.RleNotIn...))
	}
	if i.RleGT != nil {
		predicates = append(predicates, bodypart.RleGT(*i.RleGT))
	}
	if i.RleGTE != nil {
		predicates = append(predicates, bodypart.RleGTE(*i.RleGTE))
	}
	if i.RleLT != nil {
		predicates = append(predicates, bodypart.RleLT(*i.RleLT))
	}
	if i.RleLTE != nil {
		predicates = append(predicates, bodypart.RleLTE(*i.RleLTE))
	}
	if i.RleContains != nil {
		predicates = append(predicates, bodypart.RleContains(*i.RleContains))
	}
	if i.RleHasPrefix != nil {
		predicates = append(predicates, bodypart.RleHasPrefix(*i.RleHasPrefix))
	}
	if i.RleHasSuffix != nil {
		predicates = append(predicates, bodypart.RleHasSuffix(*i.RleHasSuffix))
	}
	if i.RleEqualFold != nil {
		predicates = append(predicates, bodypart.RleEqualFold(*i.RleEqualFold))
	}
	if i.RleContainsFold != nil {
		predicates = append(predicates, bodypart.RleContainsFold(*i.RleContainsFold))
	}

	if i.HasHustlerBodies != nil {
		p := bodypart.HasHustlerBodies()
		if !*i.HasHustlerBodies {
			p = bodypart.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerBodiesWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerBodiesWith))
		for _, w := range i.HasHustlerBodiesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, bodypart.HasHustlerBodiesWith(with...))
	}
	if i.HasHustlerHairs != nil {
		p := bodypart.HasHustlerHairs()
		if !*i.HasHustlerHairs {
			p = bodypart.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerHairsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerHairsWith))
		for _, w := range i.HasHustlerHairsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, bodypart.HasHustlerHairsWith(with...))
	}
	if i.HasHustlerBeards != nil {
		p := bodypart.HasHustlerBeards()
		if !*i.HasHustlerBeards {
			p = bodypart.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerBeardsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerBeardsWith))
		for _, w := range i.HasHustlerBeardsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, bodypart.HasHustlerBeardsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate BodyPartWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return bodypart.And(predicates...), nil
	}
}

// DopeWhereInput represents a where input for filtering Dope queries.
type DopeWhereInput struct {
	Not *DopeWhereInput   `json:"not,omitempty"`
	Or  []*DopeWhereInput `json:"or,omitempty"`
	And []*DopeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "claimed" field predicates.
	Claimed    *bool `json:"claimed,omitempty"`
	ClaimedNEQ *bool `json:"claimedNEQ,omitempty"`

	// "opened" field predicates.
	Opened    *bool `json:"opened,omitempty"`
	OpenedNEQ *bool `json:"openedNEQ,omitempty"`

	// "score" field predicates.
	Score       *int  `json:"score,omitempty"`
	ScoreNEQ    *int  `json:"scoreNEQ,omitempty"`
	ScoreIn     []int `json:"scoreIn,omitempty"`
	ScoreNotIn  []int `json:"scoreNotIn,omitempty"`
	ScoreGT     *int  `json:"scoreGT,omitempty"`
	ScoreGTE    *int  `json:"scoreGTE,omitempty"`
	ScoreLT     *int  `json:"scoreLT,omitempty"`
	ScoreLTE    *int  `json:"scoreLTE,omitempty"`
	ScoreIsNil  bool  `json:"scoreIsNil,omitempty"`
	ScoreNotNil bool  `json:"scoreNotNil,omitempty"`

	// "rank" field predicates.
	Rank       *int  `json:"rank,omitempty"`
	RankNEQ    *int  `json:"rankNEQ,omitempty"`
	RankIn     []int `json:"rankIn,omitempty"`
	RankNotIn  []int `json:"rankNotIn,omitempty"`
	RankGT     *int  `json:"rankGT,omitempty"`
	RankGTE    *int  `json:"rankGTE,omitempty"`
	RankLT     *int  `json:"rankLT,omitempty"`
	RankLTE    *int  `json:"rankLTE,omitempty"`
	RankIsNil  bool  `json:"rankIsNil,omitempty"`
	RankNotNil bool  `json:"rankNotNil,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "wallet" edge predicates.
	HasWallet     *bool               `json:"hasWallet,omitempty"`
	HasWalletWith []*WalletWhereInput `json:"hasWalletWith,omitempty"`

	// "lastSale" edge predicates.
	HasLastSale     *bool                `json:"hasLastSale,omitempty"`
	HasLastSaleWith []*ListingWhereInput `json:"hasLastSaleWith,omitempty"`

	// "listings" edge predicates.
	HasListings     *bool                `json:"hasListings,omitempty"`
	HasListingsWith []*ListingWhereInput `json:"hasListingsWith,omitempty"`

	// "items" edge predicates.
	HasItems     *bool             `json:"hasItems,omitempty"`
	HasItemsWith []*ItemWhereInput `json:"hasItemsWith,omitempty"`
}

// Filter applies the DopeWhereInput filter on the DopeQuery builder.
func (i *DopeWhereInput) Filter(q *DopeQuery) (*DopeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering dopes.
// An error is returned if the input is empty or invalid.
func (i *DopeWhereInput) P() (predicate.Dope, error) {
	var predicates []predicate.Dope
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, dope.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Dope, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, dope.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Dope, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, dope.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, dope.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dope.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dope.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dope.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dope.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dope.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dope.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dope.IDLTE(*i.IDLTE))
	}
	if i.Claimed != nil {
		predicates = append(predicates, dope.ClaimedEQ(*i.Claimed))
	}
	if i.ClaimedNEQ != nil {
		predicates = append(predicates, dope.ClaimedNEQ(*i.ClaimedNEQ))
	}
	if i.Opened != nil {
		predicates = append(predicates, dope.OpenedEQ(*i.Opened))
	}
	if i.OpenedNEQ != nil {
		predicates = append(predicates, dope.OpenedNEQ(*i.OpenedNEQ))
	}
	if i.Score != nil {
		predicates = append(predicates, dope.ScoreEQ(*i.Score))
	}
	if i.ScoreNEQ != nil {
		predicates = append(predicates, dope.ScoreNEQ(*i.ScoreNEQ))
	}
	if len(i.ScoreIn) > 0 {
		predicates = append(predicates, dope.ScoreIn(i.ScoreIn...))
	}
	if len(i.ScoreNotIn) > 0 {
		predicates = append(predicates, dope.ScoreNotIn(i.ScoreNotIn...))
	}
	if i.ScoreGT != nil {
		predicates = append(predicates, dope.ScoreGT(*i.ScoreGT))
	}
	if i.ScoreGTE != nil {
		predicates = append(predicates, dope.ScoreGTE(*i.ScoreGTE))
	}
	if i.ScoreLT != nil {
		predicates = append(predicates, dope.ScoreLT(*i.ScoreLT))
	}
	if i.ScoreLTE != nil {
		predicates = append(predicates, dope.ScoreLTE(*i.ScoreLTE))
	}
	if i.ScoreIsNil {
		predicates = append(predicates, dope.ScoreIsNil())
	}
	if i.ScoreNotNil {
		predicates = append(predicates, dope.ScoreNotNil())
	}
	if i.Rank != nil {
		predicates = append(predicates, dope.RankEQ(*i.Rank))
	}
	if i.RankNEQ != nil {
		predicates = append(predicates, dope.RankNEQ(*i.RankNEQ))
	}
	if len(i.RankIn) > 0 {
		predicates = append(predicates, dope.RankIn(i.RankIn...))
	}
	if len(i.RankNotIn) > 0 {
		predicates = append(predicates, dope.RankNotIn(i.RankNotIn...))
	}
	if i.RankGT != nil {
		predicates = append(predicates, dope.RankGT(*i.RankGT))
	}
	if i.RankGTE != nil {
		predicates = append(predicates, dope.RankGTE(*i.RankGTE))
	}
	if i.RankLT != nil {
		predicates = append(predicates, dope.RankLT(*i.RankLT))
	}
	if i.RankLTE != nil {
		predicates = append(predicates, dope.RankLTE(*i.RankLTE))
	}
	if i.RankIsNil {
		predicates = append(predicates, dope.RankIsNil())
	}
	if i.RankNotNil {
		predicates = append(predicates, dope.RankNotNil())
	}
	if i.Order != nil {
		predicates = append(predicates, dope.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, dope.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, dope.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, dope.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, dope.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, dope.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, dope.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, dope.OrderLTE(*i.OrderLTE))
	}

	if i.HasWallet != nil {
		p := dope.HasWallet()
		if !*i.HasWallet {
			p = dope.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWalletWith) > 0 {
		with := make([]predicate.Wallet, 0, len(i.HasWalletWith))
		for _, w := range i.HasWalletWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, dope.HasWalletWith(with...))
	}
	if i.HasLastSale != nil {
		p := dope.HasLastSale()
		if !*i.HasLastSale {
			p = dope.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLastSaleWith) > 0 {
		with := make([]predicate.Listing, 0, len(i.HasLastSaleWith))
		for _, w := range i.HasLastSaleWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, dope.HasLastSaleWith(with...))
	}
	if i.HasListings != nil {
		p := dope.HasListings()
		if !*i.HasListings {
			p = dope.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasListingsWith) > 0 {
		with := make([]predicate.Listing, 0, len(i.HasListingsWith))
		for _, w := range i.HasListingsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, dope.HasListingsWith(with...))
	}
	if i.HasItems != nil {
		p := dope.HasItems()
		if !*i.HasItems {
			p = dope.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemsWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasItemsWith))
		for _, w := range i.HasItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, dope.HasItemsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate DopeWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return dope.And(predicates...), nil
	}
}

// EventWhereInput represents a where input for filtering Event queries.
type EventWhereInput struct {
	Not *EventWhereInput   `json:"not,omitempty"`
	Or  []*EventWhereInput `json:"or,omitempty"`
	And []*EventWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "index" field predicates.
	Index      *uint64  `json:"index,omitempty"`
	IndexNEQ   *uint64  `json:"indexNEQ,omitempty"`
	IndexIn    []uint64 `json:"indexIn,omitempty"`
	IndexNotIn []uint64 `json:"indexNotIn,omitempty"`
	IndexGT    *uint64  `json:"indexGT,omitempty"`
	IndexGTE   *uint64  `json:"indexGTE,omitempty"`
	IndexLT    *uint64  `json:"indexLT,omitempty"`
	IndexLTE   *uint64  `json:"indexLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`
}

// Filter applies the EventWhereInput filter on the EventQuery builder.
func (i *EventWhereInput) Filter(q *EventQuery) (*EventQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering events.
// An error is returned if the input is empty or invalid.
func (i *EventWhereInput) P() (predicate.Event, error) {
	var predicates []predicate.Event
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, event.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Event, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, event.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Event, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, event.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, event.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, event.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, event.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, event.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, event.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, event.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, event.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, event.IDLTE(*i.IDLTE))
	}
	if i.Index != nil {
		predicates = append(predicates, event.IndexEQ(*i.Index))
	}
	if i.IndexNEQ != nil {
		predicates = append(predicates, event.IndexNEQ(*i.IndexNEQ))
	}
	if len(i.IndexIn) > 0 {
		predicates = append(predicates, event.IndexIn(i.IndexIn...))
	}
	if len(i.IndexNotIn) > 0 {
		predicates = append(predicates, event.IndexNotIn(i.IndexNotIn...))
	}
	if i.IndexGT != nil {
		predicates = append(predicates, event.IndexGT(*i.IndexGT))
	}
	if i.IndexGTE != nil {
		predicates = append(predicates, event.IndexGTE(*i.IndexGTE))
	}
	if i.IndexLT != nil {
		predicates = append(predicates, event.IndexLT(*i.IndexLT))
	}
	if i.IndexLTE != nil {
		predicates = append(predicates, event.IndexLTE(*i.IndexLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, event.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, event.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, event.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, event.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, event.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, event.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, event.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, event.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, event.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, event.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, event.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, event.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, event.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, event.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, event.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, event.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate EventWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return event.And(predicates...), nil
	}
}

// HustlerWhereInput represents a where input for filtering Hustler queries.
type HustlerWhereInput struct {
	Not *HustlerWhereInput   `json:"not,omitempty"`
	Or  []*HustlerWhereInput `json:"or,omitempty"`
	And []*HustlerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type      *hustler.Type  `json:"type,omitempty"`
	TypeNEQ   *hustler.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []hustler.Type `json:"typeIn,omitempty"`
	TypeNotIn []hustler.Type `json:"typeNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        bool     `json:"titleIsNil,omitempty"`
	TitleNotNil       bool     `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "color" field predicates.
	Color             *string  `json:"color,omitempty"`
	ColorNEQ          *string  `json:"colorNEQ,omitempty"`
	ColorIn           []string `json:"colorIn,omitempty"`
	ColorNotIn        []string `json:"colorNotIn,omitempty"`
	ColorGT           *string  `json:"colorGT,omitempty"`
	ColorGTE          *string  `json:"colorGTE,omitempty"`
	ColorLT           *string  `json:"colorLT,omitempty"`
	ColorLTE          *string  `json:"colorLTE,omitempty"`
	ColorContains     *string  `json:"colorContains,omitempty"`
	ColorHasPrefix    *string  `json:"colorHasPrefix,omitempty"`
	ColorHasSuffix    *string  `json:"colorHasSuffix,omitempty"`
	ColorIsNil        bool     `json:"colorIsNil,omitempty"`
	ColorNotNil       bool     `json:"colorNotNil,omitempty"`
	ColorEqualFold    *string  `json:"colorEqualFold,omitempty"`
	ColorContainsFold *string  `json:"colorContainsFold,omitempty"`

	// "background" field predicates.
	Background             *string  `json:"background,omitempty"`
	BackgroundNEQ          *string  `json:"backgroundNEQ,omitempty"`
	BackgroundIn           []string `json:"backgroundIn,omitempty"`
	BackgroundNotIn        []string `json:"backgroundNotIn,omitempty"`
	BackgroundGT           *string  `json:"backgroundGT,omitempty"`
	BackgroundGTE          *string  `json:"backgroundGTE,omitempty"`
	BackgroundLT           *string  `json:"backgroundLT,omitempty"`
	BackgroundLTE          *string  `json:"backgroundLTE,omitempty"`
	BackgroundContains     *string  `json:"backgroundContains,omitempty"`
	BackgroundHasPrefix    *string  `json:"backgroundHasPrefix,omitempty"`
	BackgroundHasSuffix    *string  `json:"backgroundHasSuffix,omitempty"`
	BackgroundIsNil        bool     `json:"backgroundIsNil,omitempty"`
	BackgroundNotNil       bool     `json:"backgroundNotNil,omitempty"`
	BackgroundEqualFold    *string  `json:"backgroundEqualFold,omitempty"`
	BackgroundContainsFold *string  `json:"backgroundContainsFold,omitempty"`

	// "age" field predicates.
	Age      *uint64  `json:"age,omitempty"`
	AgeNEQ   *uint64  `json:"ageNEQ,omitempty"`
	AgeIn    []uint64 `json:"ageIn,omitempty"`
	AgeNotIn []uint64 `json:"ageNotIn,omitempty"`
	AgeGT    *uint64  `json:"ageGT,omitempty"`
	AgeGTE   *uint64  `json:"ageGTE,omitempty"`
	AgeLT    *uint64  `json:"ageLT,omitempty"`
	AgeLTE   *uint64  `json:"ageLTE,omitempty"`

	// "sex" field predicates.
	Sex      *hustler.Sex  `json:"sex,omitempty"`
	SexNEQ   *hustler.Sex  `json:"sexNEQ,omitempty"`
	SexIn    []hustler.Sex `json:"sexIn,omitempty"`
	SexNotIn []hustler.Sex `json:"sexNotIn,omitempty"`

	// "svg" field predicates.
	Svg             *string  `json:"svg,omitempty"`
	SvgNEQ          *string  `json:"svgNEQ,omitempty"`
	SvgIn           []string `json:"svgIn,omitempty"`
	SvgNotIn        []string `json:"svgNotIn,omitempty"`
	SvgGT           *string  `json:"svgGT,omitempty"`
	SvgGTE          *string  `json:"svgGTE,omitempty"`
	SvgLT           *string  `json:"svgLT,omitempty"`
	SvgLTE          *string  `json:"svgLTE,omitempty"`
	SvgContains     *string  `json:"svgContains,omitempty"`
	SvgHasPrefix    *string  `json:"svgHasPrefix,omitempty"`
	SvgHasSuffix    *string  `json:"svgHasSuffix,omitempty"`
	SvgIsNil        bool     `json:"svgIsNil,omitempty"`
	SvgNotNil       bool     `json:"svgNotNil,omitempty"`
	SvgEqualFold    *string  `json:"svgEqualFold,omitempty"`
	SvgContainsFold *string  `json:"svgContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "wallet" edge predicates.
	HasWallet     *bool               `json:"hasWallet,omitempty"`
	HasWalletWith []*WalletWhereInput `json:"hasWalletWith,omitempty"`

	// "weapon" edge predicates.
	HasWeapon     *bool             `json:"hasWeapon,omitempty"`
	HasWeaponWith []*ItemWhereInput `json:"hasWeaponWith,omitempty"`

	// "clothes" edge predicates.
	HasClothes     *bool             `json:"hasClothes,omitempty"`
	HasClothesWith []*ItemWhereInput `json:"hasClothesWith,omitempty"`

	// "vehicle" edge predicates.
	HasVehicle     *bool             `json:"hasVehicle,omitempty"`
	HasVehicleWith []*ItemWhereInput `json:"hasVehicleWith,omitempty"`

	// "waist" edge predicates.
	HasWaist     *bool             `json:"hasWaist,omitempty"`
	HasWaistWith []*ItemWhereInput `json:"hasWaistWith,omitempty"`

	// "foot" edge predicates.
	HasFoot     *bool             `json:"hasFoot,omitempty"`
	HasFootWith []*ItemWhereInput `json:"hasFootWith,omitempty"`

	// "hand" edge predicates.
	HasHand     *bool             `json:"hasHand,omitempty"`
	HasHandWith []*ItemWhereInput `json:"hasHandWith,omitempty"`

	// "drug" edge predicates.
	HasDrug     *bool             `json:"hasDrug,omitempty"`
	HasDrugWith []*ItemWhereInput `json:"hasDrugWith,omitempty"`

	// "neck" edge predicates.
	HasNeck     *bool             `json:"hasNeck,omitempty"`
	HasNeckWith []*ItemWhereInput `json:"hasNeckWith,omitempty"`

	// "ring" edge predicates.
	HasRing     *bool             `json:"hasRing,omitempty"`
	HasRingWith []*ItemWhereInput `json:"hasRingWith,omitempty"`

	// "accessory" edge predicates.
	HasAccessory     *bool             `json:"hasAccessory,omitempty"`
	HasAccessoryWith []*ItemWhereInput `json:"hasAccessoryWith,omitempty"`

	// "body" edge predicates.
	HasBody     *bool                 `json:"hasBody,omitempty"`
	HasBodyWith []*BodyPartWhereInput `json:"hasBodyWith,omitempty"`

	// "hair" edge predicates.
	HasHair     *bool                 `json:"hasHair,omitempty"`
	HasHairWith []*BodyPartWhereInput `json:"hasHairWith,omitempty"`

	// "beard" edge predicates.
	HasBeard     *bool                 `json:"hasBeard,omitempty"`
	HasBeardWith []*BodyPartWhereInput `json:"hasBeardWith,omitempty"`
}

// Filter applies the HustlerWhereInput filter on the HustlerQuery builder.
func (i *HustlerWhereInput) Filter(q *HustlerQuery) (*HustlerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering hustlers.
// An error is returned if the input is empty or invalid.
func (i *HustlerWhereInput) P() (predicate.Hustler, error) {
	var predicates []predicate.Hustler
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, hustler.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Hustler, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, hustler.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Hustler, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, hustler.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, hustler.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, hustler.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, hustler.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, hustler.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, hustler.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, hustler.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, hustler.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, hustler.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, hustler.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, hustler.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, hustler.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, hustler.TypeNotIn(i.TypeNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, hustler.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, hustler.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, hustler.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, hustler.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, hustler.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, hustler.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, hustler.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, hustler.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, hustler.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, hustler.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, hustler.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, hustler.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, hustler.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, hustler.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, hustler.NameContainsFold(*i.NameContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, hustler.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, hustler.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, hustler.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, hustler.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, hustler.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, hustler.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, hustler.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, hustler.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, hustler.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, hustler.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, hustler.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleIsNil {
		predicates = append(predicates, hustler.TitleIsNil())
	}
	if i.TitleNotNil {
		predicates = append(predicates, hustler.TitleNotNil())
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, hustler.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, hustler.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Color != nil {
		predicates = append(predicates, hustler.ColorEQ(*i.Color))
	}
	if i.ColorNEQ != nil {
		predicates = append(predicates, hustler.ColorNEQ(*i.ColorNEQ))
	}
	if len(i.ColorIn) > 0 {
		predicates = append(predicates, hustler.ColorIn(i.ColorIn...))
	}
	if len(i.ColorNotIn) > 0 {
		predicates = append(predicates, hustler.ColorNotIn(i.ColorNotIn...))
	}
	if i.ColorGT != nil {
		predicates = append(predicates, hustler.ColorGT(*i.ColorGT))
	}
	if i.ColorGTE != nil {
		predicates = append(predicates, hustler.ColorGTE(*i.ColorGTE))
	}
	if i.ColorLT != nil {
		predicates = append(predicates, hustler.ColorLT(*i.ColorLT))
	}
	if i.ColorLTE != nil {
		predicates = append(predicates, hustler.ColorLTE(*i.ColorLTE))
	}
	if i.ColorContains != nil {
		predicates = append(predicates, hustler.ColorContains(*i.ColorContains))
	}
	if i.ColorHasPrefix != nil {
		predicates = append(predicates, hustler.ColorHasPrefix(*i.ColorHasPrefix))
	}
	if i.ColorHasSuffix != nil {
		predicates = append(predicates, hustler.ColorHasSuffix(*i.ColorHasSuffix))
	}
	if i.ColorIsNil {
		predicates = append(predicates, hustler.ColorIsNil())
	}
	if i.ColorNotNil {
		predicates = append(predicates, hustler.ColorNotNil())
	}
	if i.ColorEqualFold != nil {
		predicates = append(predicates, hustler.ColorEqualFold(*i.ColorEqualFold))
	}
	if i.ColorContainsFold != nil {
		predicates = append(predicates, hustler.ColorContainsFold(*i.ColorContainsFold))
	}
	if i.Background != nil {
		predicates = append(predicates, hustler.BackgroundEQ(*i.Background))
	}
	if i.BackgroundNEQ != nil {
		predicates = append(predicates, hustler.BackgroundNEQ(*i.BackgroundNEQ))
	}
	if len(i.BackgroundIn) > 0 {
		predicates = append(predicates, hustler.BackgroundIn(i.BackgroundIn...))
	}
	if len(i.BackgroundNotIn) > 0 {
		predicates = append(predicates, hustler.BackgroundNotIn(i.BackgroundNotIn...))
	}
	if i.BackgroundGT != nil {
		predicates = append(predicates, hustler.BackgroundGT(*i.BackgroundGT))
	}
	if i.BackgroundGTE != nil {
		predicates = append(predicates, hustler.BackgroundGTE(*i.BackgroundGTE))
	}
	if i.BackgroundLT != nil {
		predicates = append(predicates, hustler.BackgroundLT(*i.BackgroundLT))
	}
	if i.BackgroundLTE != nil {
		predicates = append(predicates, hustler.BackgroundLTE(*i.BackgroundLTE))
	}
	if i.BackgroundContains != nil {
		predicates = append(predicates, hustler.BackgroundContains(*i.BackgroundContains))
	}
	if i.BackgroundHasPrefix != nil {
		predicates = append(predicates, hustler.BackgroundHasPrefix(*i.BackgroundHasPrefix))
	}
	if i.BackgroundHasSuffix != nil {
		predicates = append(predicates, hustler.BackgroundHasSuffix(*i.BackgroundHasSuffix))
	}
	if i.BackgroundIsNil {
		predicates = append(predicates, hustler.BackgroundIsNil())
	}
	if i.BackgroundNotNil {
		predicates = append(predicates, hustler.BackgroundNotNil())
	}
	if i.BackgroundEqualFold != nil {
		predicates = append(predicates, hustler.BackgroundEqualFold(*i.BackgroundEqualFold))
	}
	if i.BackgroundContainsFold != nil {
		predicates = append(predicates, hustler.BackgroundContainsFold(*i.BackgroundContainsFold))
	}
	if i.Age != nil {
		predicates = append(predicates, hustler.AgeEQ(*i.Age))
	}
	if i.AgeNEQ != nil {
		predicates = append(predicates, hustler.AgeNEQ(*i.AgeNEQ))
	}
	if len(i.AgeIn) > 0 {
		predicates = append(predicates, hustler.AgeIn(i.AgeIn...))
	}
	if len(i.AgeNotIn) > 0 {
		predicates = append(predicates, hustler.AgeNotIn(i.AgeNotIn...))
	}
	if i.AgeGT != nil {
		predicates = append(predicates, hustler.AgeGT(*i.AgeGT))
	}
	if i.AgeGTE != nil {
		predicates = append(predicates, hustler.AgeGTE(*i.AgeGTE))
	}
	if i.AgeLT != nil {
		predicates = append(predicates, hustler.AgeLT(*i.AgeLT))
	}
	if i.AgeLTE != nil {
		predicates = append(predicates, hustler.AgeLTE(*i.AgeLTE))
	}
	if i.Sex != nil {
		predicates = append(predicates, hustler.SexEQ(*i.Sex))
	}
	if i.SexNEQ != nil {
		predicates = append(predicates, hustler.SexNEQ(*i.SexNEQ))
	}
	if len(i.SexIn) > 0 {
		predicates = append(predicates, hustler.SexIn(i.SexIn...))
	}
	if len(i.SexNotIn) > 0 {
		predicates = append(predicates, hustler.SexNotIn(i.SexNotIn...))
	}
	if i.Svg != nil {
		predicates = append(predicates, hustler.SvgEQ(*i.Svg))
	}
	if i.SvgNEQ != nil {
		predicates = append(predicates, hustler.SvgNEQ(*i.SvgNEQ))
	}
	if len(i.SvgIn) > 0 {
		predicates = append(predicates, hustler.SvgIn(i.SvgIn...))
	}
	if len(i.SvgNotIn) > 0 {
		predicates = append(predicates, hustler.SvgNotIn(i.SvgNotIn...))
	}
	if i.SvgGT != nil {
		predicates = append(predicates, hustler.SvgGT(*i.SvgGT))
	}
	if i.SvgGTE != nil {
		predicates = append(predicates, hustler.SvgGTE(*i.SvgGTE))
	}
	if i.SvgLT != nil {
		predicates = append(predicates, hustler.SvgLT(*i.SvgLT))
	}
	if i.SvgLTE != nil {
		predicates = append(predicates, hustler.SvgLTE(*i.SvgLTE))
	}
	if i.SvgContains != nil {
		predicates = append(predicates, hustler.SvgContains(*i.SvgContains))
	}
	if i.SvgHasPrefix != nil {
		predicates = append(predicates, hustler.SvgHasPrefix(*i.SvgHasPrefix))
	}
	if i.SvgHasSuffix != nil {
		predicates = append(predicates, hustler.SvgHasSuffix(*i.SvgHasSuffix))
	}
	if i.SvgIsNil {
		predicates = append(predicates, hustler.SvgIsNil())
	}
	if i.SvgNotNil {
		predicates = append(predicates, hustler.SvgNotNil())
	}
	if i.SvgEqualFold != nil {
		predicates = append(predicates, hustler.SvgEqualFold(*i.SvgEqualFold))
	}
	if i.SvgContainsFold != nil {
		predicates = append(predicates, hustler.SvgContainsFold(*i.SvgContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, hustler.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, hustler.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, hustler.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, hustler.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, hustler.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, hustler.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, hustler.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, hustler.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasWallet != nil {
		p := hustler.HasWallet()
		if !*i.HasWallet {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWalletWith) > 0 {
		with := make([]predicate.Wallet, 0, len(i.HasWalletWith))
		for _, w := range i.HasWalletWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasWalletWith(with...))
	}
	if i.HasWeapon != nil {
		p := hustler.HasWeapon()
		if !*i.HasWeapon {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWeaponWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasWeaponWith))
		for _, w := range i.HasWeaponWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasWeaponWith(with...))
	}
	if i.HasClothes != nil {
		p := hustler.HasClothes()
		if !*i.HasClothes {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClothesWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasClothesWith))
		for _, w := range i.HasClothesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasClothesWith(with...))
	}
	if i.HasVehicle != nil {
		p := hustler.HasVehicle()
		if !*i.HasVehicle {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVehicleWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasVehicleWith))
		for _, w := range i.HasVehicleWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasVehicleWith(with...))
	}
	if i.HasWaist != nil {
		p := hustler.HasWaist()
		if !*i.HasWaist {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWaistWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasWaistWith))
		for _, w := range i.HasWaistWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasWaistWith(with...))
	}
	if i.HasFoot != nil {
		p := hustler.HasFoot()
		if !*i.HasFoot {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFootWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasFootWith))
		for _, w := range i.HasFootWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasFootWith(with...))
	}
	if i.HasHand != nil {
		p := hustler.HasHand()
		if !*i.HasHand {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHandWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasHandWith))
		for _, w := range i.HasHandWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasHandWith(with...))
	}
	if i.HasDrug != nil {
		p := hustler.HasDrug()
		if !*i.HasDrug {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDrugWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasDrugWith))
		for _, w := range i.HasDrugWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasDrugWith(with...))
	}
	if i.HasNeck != nil {
		p := hustler.HasNeck()
		if !*i.HasNeck {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNeckWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasNeckWith))
		for _, w := range i.HasNeckWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasNeckWith(with...))
	}
	if i.HasRing != nil {
		p := hustler.HasRing()
		if !*i.HasRing {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRingWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasRingWith))
		for _, w := range i.HasRingWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasRingWith(with...))
	}
	if i.HasAccessory != nil {
		p := hustler.HasAccessory()
		if !*i.HasAccessory {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccessoryWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasAccessoryWith))
		for _, w := range i.HasAccessoryWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasAccessoryWith(with...))
	}
	if i.HasBody != nil {
		p := hustler.HasBody()
		if !*i.HasBody {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBodyWith) > 0 {
		with := make([]predicate.BodyPart, 0, len(i.HasBodyWith))
		for _, w := range i.HasBodyWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasBodyWith(with...))
	}
	if i.HasHair != nil {
		p := hustler.HasHair()
		if !*i.HasHair {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHairWith) > 0 {
		with := make([]predicate.BodyPart, 0, len(i.HasHairWith))
		for _, w := range i.HasHairWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasHairWith(with...))
	}
	if i.HasBeard != nil {
		p := hustler.HasBeard()
		if !*i.HasBeard {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBeardWith) > 0 {
		with := make([]predicate.BodyPart, 0, len(i.HasBeardWith))
		for _, w := range i.HasBeardWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasBeardWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate HustlerWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return hustler.And(predicates...), nil
	}
}

// ItemWhereInput represents a where input for filtering Item queries.
type ItemWhereInput struct {
	Not *ItemWhereInput   `json:"not,omitempty"`
	Or  []*ItemWhereInput `json:"or,omitempty"`
	And []*ItemWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type      *item.Type  `json:"type,omitempty"`
	TypeNEQ   *item.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []item.Type `json:"typeIn,omitempty"`
	TypeNotIn []item.Type `json:"typeNotIn,omitempty"`

	// "name_prefix" field predicates.
	NamePrefix             *string  `json:"namePrefix,omitempty"`
	NamePrefixNEQ          *string  `json:"namePrefixNEQ,omitempty"`
	NamePrefixIn           []string `json:"namePrefixIn,omitempty"`
	NamePrefixNotIn        []string `json:"namePrefixNotIn,omitempty"`
	NamePrefixGT           *string  `json:"namePrefixGT,omitempty"`
	NamePrefixGTE          *string  `json:"namePrefixGTE,omitempty"`
	NamePrefixLT           *string  `json:"namePrefixLT,omitempty"`
	NamePrefixLTE          *string  `json:"namePrefixLTE,omitempty"`
	NamePrefixContains     *string  `json:"namePrefixContains,omitempty"`
	NamePrefixHasPrefix    *string  `json:"namePrefixHasPrefix,omitempty"`
	NamePrefixHasSuffix    *string  `json:"namePrefixHasSuffix,omitempty"`
	NamePrefixIsNil        bool     `json:"namePrefixIsNil,omitempty"`
	NamePrefixNotNil       bool     `json:"namePrefixNotNil,omitempty"`
	NamePrefixEqualFold    *string  `json:"namePrefixEqualFold,omitempty"`
	NamePrefixContainsFold *string  `json:"namePrefixContainsFold,omitempty"`

	// "name_suffix" field predicates.
	NameSuffix             *string  `json:"nameSuffix,omitempty"`
	NameSuffixNEQ          *string  `json:"nameSuffixNEQ,omitempty"`
	NameSuffixIn           []string `json:"nameSuffixIn,omitempty"`
	NameSuffixNotIn        []string `json:"nameSuffixNotIn,omitempty"`
	NameSuffixGT           *string  `json:"nameSuffixGT,omitempty"`
	NameSuffixGTE          *string  `json:"nameSuffixGTE,omitempty"`
	NameSuffixLT           *string  `json:"nameSuffixLT,omitempty"`
	NameSuffixLTE          *string  `json:"nameSuffixLTE,omitempty"`
	NameSuffixContains     *string  `json:"nameSuffixContains,omitempty"`
	NameSuffixHasPrefix    *string  `json:"nameSuffixHasPrefix,omitempty"`
	NameSuffixHasSuffix    *string  `json:"nameSuffixHasSuffix,omitempty"`
	NameSuffixIsNil        bool     `json:"nameSuffixIsNil,omitempty"`
	NameSuffixNotNil       bool     `json:"nameSuffixNotNil,omitempty"`
	NameSuffixEqualFold    *string  `json:"nameSuffixEqualFold,omitempty"`
	NameSuffixContainsFold *string  `json:"nameSuffixContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "suffix" field predicates.
	Suffix             *string  `json:"suffix,omitempty"`
	SuffixNEQ          *string  `json:"suffixNEQ,omitempty"`
	SuffixIn           []string `json:"suffixIn,omitempty"`
	SuffixNotIn        []string `json:"suffixNotIn,omitempty"`
	SuffixGT           *string  `json:"suffixGT,omitempty"`
	SuffixGTE          *string  `json:"suffixGTE,omitempty"`
	SuffixLT           *string  `json:"suffixLT,omitempty"`
	SuffixLTE          *string  `json:"suffixLTE,omitempty"`
	SuffixContains     *string  `json:"suffixContains,omitempty"`
	SuffixHasPrefix    *string  `json:"suffixHasPrefix,omitempty"`
	SuffixHasSuffix    *string  `json:"suffixHasSuffix,omitempty"`
	SuffixIsNil        bool     `json:"suffixIsNil,omitempty"`
	SuffixNotNil       bool     `json:"suffixNotNil,omitempty"`
	SuffixEqualFold    *string  `json:"suffixEqualFold,omitempty"`
	SuffixContainsFold *string  `json:"suffixContainsFold,omitempty"`

	// "augmented" field predicates.
	Augmented       *bool `json:"augmented,omitempty"`
	AugmentedNEQ    *bool `json:"augmentedNEQ,omitempty"`
	AugmentedIsNil  bool  `json:"augmentedIsNil,omitempty"`
	AugmentedNotNil bool  `json:"augmentedNotNil,omitempty"`

	// "count" field predicates.
	Count       *int  `json:"count,omitempty"`
	CountNEQ    *int  `json:"countNEQ,omitempty"`
	CountIn     []int `json:"countIn,omitempty"`
	CountNotIn  []int `json:"countNotIn,omitempty"`
	CountGT     *int  `json:"countGT,omitempty"`
	CountGTE    *int  `json:"countGTE,omitempty"`
	CountLT     *int  `json:"countLT,omitempty"`
	CountLTE    *int  `json:"countLTE,omitempty"`
	CountIsNil  bool  `json:"countIsNil,omitempty"`
	CountNotNil bool  `json:"countNotNil,omitempty"`

	// "tier" field predicates.
	Tier       *item.Tier  `json:"tier,omitempty"`
	TierNEQ    *item.Tier  `json:"tierNEQ,omitempty"`
	TierIn     []item.Tier `json:"tierIn,omitempty"`
	TierNotIn  []item.Tier `json:"tierNotIn,omitempty"`
	TierIsNil  bool        `json:"tierIsNil,omitempty"`
	TierNotNil bool        `json:"tierNotNil,omitempty"`

	// "greatness" field predicates.
	Greatness       *int  `json:"greatness,omitempty"`
	GreatnessNEQ    *int  `json:"greatnessNEQ,omitempty"`
	GreatnessIn     []int `json:"greatnessIn,omitempty"`
	GreatnessNotIn  []int `json:"greatnessNotIn,omitempty"`
	GreatnessGT     *int  `json:"greatnessGT,omitempty"`
	GreatnessGTE    *int  `json:"greatnessGTE,omitempty"`
	GreatnessLT     *int  `json:"greatnessLT,omitempty"`
	GreatnessLTE    *int  `json:"greatnessLTE,omitempty"`
	GreatnessIsNil  bool  `json:"greatnessIsNil,omitempty"`
	GreatnessNotNil bool  `json:"greatnessNotNil,omitempty"`

	// "svg" field predicates.
	Svg             *string  `json:"svg,omitempty"`
	SvgNEQ          *string  `json:"svgNEQ,omitempty"`
	SvgIn           []string `json:"svgIn,omitempty"`
	SvgNotIn        []string `json:"svgNotIn,omitempty"`
	SvgGT           *string  `json:"svgGT,omitempty"`
	SvgGTE          *string  `json:"svgGTE,omitempty"`
	SvgLT           *string  `json:"svgLT,omitempty"`
	SvgLTE          *string  `json:"svgLTE,omitempty"`
	SvgContains     *string  `json:"svgContains,omitempty"`
	SvgHasPrefix    *string  `json:"svgHasPrefix,omitempty"`
	SvgHasSuffix    *string  `json:"svgHasSuffix,omitempty"`
	SvgIsNil        bool     `json:"svgIsNil,omitempty"`
	SvgNotNil       bool     `json:"svgNotNil,omitempty"`
	SvgEqualFold    *string  `json:"svgEqualFold,omitempty"`
	SvgContainsFold *string  `json:"svgContainsFold,omitempty"`

	// "wallets" edge predicates.
	HasWallets     *bool                    `json:"hasWallets,omitempty"`
	HasWalletsWith []*WalletItemsWhereInput `json:"hasWalletsWith,omitempty"`

	// "dopes" edge predicates.
	HasDopes     *bool             `json:"hasDopes,omitempty"`
	HasDopesWith []*DopeWhereInput `json:"hasDopesWith,omitempty"`

	// "hustler_weapons" edge predicates.
	HasHustlerWeapons     *bool                `json:"hasHustlerWeapons,omitempty"`
	HasHustlerWeaponsWith []*HustlerWhereInput `json:"hasHustlerWeaponsWith,omitempty"`

	// "hustler_clothes" edge predicates.
	HasHustlerClothes     *bool                `json:"hasHustlerClothes,omitempty"`
	HasHustlerClothesWith []*HustlerWhereInput `json:"hasHustlerClothesWith,omitempty"`

	// "hustler_vehicles" edge predicates.
	HasHustlerVehicles     *bool                `json:"hasHustlerVehicles,omitempty"`
	HasHustlerVehiclesWith []*HustlerWhereInput `json:"hasHustlerVehiclesWith,omitempty"`

	// "hustler_waists" edge predicates.
	HasHustlerWaists     *bool                `json:"hasHustlerWaists,omitempty"`
	HasHustlerWaistsWith []*HustlerWhereInput `json:"hasHustlerWaistsWith,omitempty"`

	// "hustler_feet" edge predicates.
	HasHustlerFeet     *bool                `json:"hasHustlerFeet,omitempty"`
	HasHustlerFeetWith []*HustlerWhereInput `json:"hasHustlerFeetWith,omitempty"`

	// "hustler_hands" edge predicates.
	HasHustlerHands     *bool                `json:"hasHustlerHands,omitempty"`
	HasHustlerHandsWith []*HustlerWhereInput `json:"hasHustlerHandsWith,omitempty"`

	// "hustler_drugs" edge predicates.
	HasHustlerDrugs     *bool                `json:"hasHustlerDrugs,omitempty"`
	HasHustlerDrugsWith []*HustlerWhereInput `json:"hasHustlerDrugsWith,omitempty"`

	// "hustler_necks" edge predicates.
	HasHustlerNecks     *bool                `json:"hasHustlerNecks,omitempty"`
	HasHustlerNecksWith []*HustlerWhereInput `json:"hasHustlerNecksWith,omitempty"`

	// "hustler_rings" edge predicates.
	HasHustlerRings     *bool                `json:"hasHustlerRings,omitempty"`
	HasHustlerRingsWith []*HustlerWhereInput `json:"hasHustlerRingsWith,omitempty"`

	// "hustler_accessories" edge predicates.
	HasHustlerAccessories     *bool                `json:"hasHustlerAccessories,omitempty"`
	HasHustlerAccessoriesWith []*HustlerWhereInput `json:"hasHustlerAccessoriesWith,omitempty"`

	// "base" edge predicates.
	HasBase     *bool             `json:"hasBase,omitempty"`
	HasBaseWith []*ItemWhereInput `json:"hasBaseWith,omitempty"`

	// "derivative" edge predicates.
	HasDerivative     *bool             `json:"hasDerivative,omitempty"`
	HasDerivativeWith []*ItemWhereInput `json:"hasDerivativeWith,omitempty"`
}

// Filter applies the ItemWhereInput filter on the ItemQuery builder.
func (i *ItemWhereInput) Filter(q *ItemQuery) (*ItemQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering items.
// An error is returned if the input is empty or invalid.
func (i *ItemWhereInput) P() (predicate.Item, error) {
	var predicates []predicate.Item
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, item.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Item, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, item.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Item, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, item.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, item.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, item.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, item.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, item.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, item.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, item.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, item.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, item.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, item.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, item.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, item.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, item.TypeNotIn(i.TypeNotIn...))
	}
	if i.NamePrefix != nil {
		predicates = append(predicates, item.NamePrefixEQ(*i.NamePrefix))
	}
	if i.NamePrefixNEQ != nil {
		predicates = append(predicates, item.NamePrefixNEQ(*i.NamePrefixNEQ))
	}
	if len(i.NamePrefixIn) > 0 {
		predicates = append(predicates, item.NamePrefixIn(i.NamePrefixIn...))
	}
	if len(i.NamePrefixNotIn) > 0 {
		predicates = append(predicates, item.NamePrefixNotIn(i.NamePrefixNotIn...))
	}
	if i.NamePrefixGT != nil {
		predicates = append(predicates, item.NamePrefixGT(*i.NamePrefixGT))
	}
	if i.NamePrefixGTE != nil {
		predicates = append(predicates, item.NamePrefixGTE(*i.NamePrefixGTE))
	}
	if i.NamePrefixLT != nil {
		predicates = append(predicates, item.NamePrefixLT(*i.NamePrefixLT))
	}
	if i.NamePrefixLTE != nil {
		predicates = append(predicates, item.NamePrefixLTE(*i.NamePrefixLTE))
	}
	if i.NamePrefixContains != nil {
		predicates = append(predicates, item.NamePrefixContains(*i.NamePrefixContains))
	}
	if i.NamePrefixHasPrefix != nil {
		predicates = append(predicates, item.NamePrefixHasPrefix(*i.NamePrefixHasPrefix))
	}
	if i.NamePrefixHasSuffix != nil {
		predicates = append(predicates, item.NamePrefixHasSuffix(*i.NamePrefixHasSuffix))
	}
	if i.NamePrefixIsNil {
		predicates = append(predicates, item.NamePrefixIsNil())
	}
	if i.NamePrefixNotNil {
		predicates = append(predicates, item.NamePrefixNotNil())
	}
	if i.NamePrefixEqualFold != nil {
		predicates = append(predicates, item.NamePrefixEqualFold(*i.NamePrefixEqualFold))
	}
	if i.NamePrefixContainsFold != nil {
		predicates = append(predicates, item.NamePrefixContainsFold(*i.NamePrefixContainsFold))
	}
	if i.NameSuffix != nil {
		predicates = append(predicates, item.NameSuffixEQ(*i.NameSuffix))
	}
	if i.NameSuffixNEQ != nil {
		predicates = append(predicates, item.NameSuffixNEQ(*i.NameSuffixNEQ))
	}
	if len(i.NameSuffixIn) > 0 {
		predicates = append(predicates, item.NameSuffixIn(i.NameSuffixIn...))
	}
	if len(i.NameSuffixNotIn) > 0 {
		predicates = append(predicates, item.NameSuffixNotIn(i.NameSuffixNotIn...))
	}
	if i.NameSuffixGT != nil {
		predicates = append(predicates, item.NameSuffixGT(*i.NameSuffixGT))
	}
	if i.NameSuffixGTE != nil {
		predicates = append(predicates, item.NameSuffixGTE(*i.NameSuffixGTE))
	}
	if i.NameSuffixLT != nil {
		predicates = append(predicates, item.NameSuffixLT(*i.NameSuffixLT))
	}
	if i.NameSuffixLTE != nil {
		predicates = append(predicates, item.NameSuffixLTE(*i.NameSuffixLTE))
	}
	if i.NameSuffixContains != nil {
		predicates = append(predicates, item.NameSuffixContains(*i.NameSuffixContains))
	}
	if i.NameSuffixHasPrefix != nil {
		predicates = append(predicates, item.NameSuffixHasPrefix(*i.NameSuffixHasPrefix))
	}
	if i.NameSuffixHasSuffix != nil {
		predicates = append(predicates, item.NameSuffixHasSuffix(*i.NameSuffixHasSuffix))
	}
	if i.NameSuffixIsNil {
		predicates = append(predicates, item.NameSuffixIsNil())
	}
	if i.NameSuffixNotNil {
		predicates = append(predicates, item.NameSuffixNotNil())
	}
	if i.NameSuffixEqualFold != nil {
		predicates = append(predicates, item.NameSuffixEqualFold(*i.NameSuffixEqualFold))
	}
	if i.NameSuffixContainsFold != nil {
		predicates = append(predicates, item.NameSuffixContainsFold(*i.NameSuffixContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, item.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, item.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, item.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, item.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, item.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, item.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, item.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, item.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, item.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, item.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, item.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, item.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, item.NameContainsFold(*i.NameContainsFold))
	}
	if i.Suffix != nil {
		predicates = append(predicates, item.SuffixEQ(*i.Suffix))
	}
	if i.SuffixNEQ != nil {
		predicates = append(predicates, item.SuffixNEQ(*i.SuffixNEQ))
	}
	if len(i.SuffixIn) > 0 {
		predicates = append(predicates, item.SuffixIn(i.SuffixIn...))
	}
	if len(i.SuffixNotIn) > 0 {
		predicates = append(predicates, item.SuffixNotIn(i.SuffixNotIn...))
	}
	if i.SuffixGT != nil {
		predicates = append(predicates, item.SuffixGT(*i.SuffixGT))
	}
	if i.SuffixGTE != nil {
		predicates = append(predicates, item.SuffixGTE(*i.SuffixGTE))
	}
	if i.SuffixLT != nil {
		predicates = append(predicates, item.SuffixLT(*i.SuffixLT))
	}
	if i.SuffixLTE != nil {
		predicates = append(predicates, item.SuffixLTE(*i.SuffixLTE))
	}
	if i.SuffixContains != nil {
		predicates = append(predicates, item.SuffixContains(*i.SuffixContains))
	}
	if i.SuffixHasPrefix != nil {
		predicates = append(predicates, item.SuffixHasPrefix(*i.SuffixHasPrefix))
	}
	if i.SuffixHasSuffix != nil {
		predicates = append(predicates, item.SuffixHasSuffix(*i.SuffixHasSuffix))
	}
	if i.SuffixIsNil {
		predicates = append(predicates, item.SuffixIsNil())
	}
	if i.SuffixNotNil {
		predicates = append(predicates, item.SuffixNotNil())
	}
	if i.SuffixEqualFold != nil {
		predicates = append(predicates, item.SuffixEqualFold(*i.SuffixEqualFold))
	}
	if i.SuffixContainsFold != nil {
		predicates = append(predicates, item.SuffixContainsFold(*i.SuffixContainsFold))
	}
	if i.Augmented != nil {
		predicates = append(predicates, item.AugmentedEQ(*i.Augmented))
	}
	if i.AugmentedNEQ != nil {
		predicates = append(predicates, item.AugmentedNEQ(*i.AugmentedNEQ))
	}
	if i.AugmentedIsNil {
		predicates = append(predicates, item.AugmentedIsNil())
	}
	if i.AugmentedNotNil {
		predicates = append(predicates, item.AugmentedNotNil())
	}
	if i.Count != nil {
		predicates = append(predicates, item.CountEQ(*i.Count))
	}
	if i.CountNEQ != nil {
		predicates = append(predicates, item.CountNEQ(*i.CountNEQ))
	}
	if len(i.CountIn) > 0 {
		predicates = append(predicates, item.CountIn(i.CountIn...))
	}
	if len(i.CountNotIn) > 0 {
		predicates = append(predicates, item.CountNotIn(i.CountNotIn...))
	}
	if i.CountGT != nil {
		predicates = append(predicates, item.CountGT(*i.CountGT))
	}
	if i.CountGTE != nil {
		predicates = append(predicates, item.CountGTE(*i.CountGTE))
	}
	if i.CountLT != nil {
		predicates = append(predicates, item.CountLT(*i.CountLT))
	}
	if i.CountLTE != nil {
		predicates = append(predicates, item.CountLTE(*i.CountLTE))
	}
	if i.CountIsNil {
		predicates = append(predicates, item.CountIsNil())
	}
	if i.CountNotNil {
		predicates = append(predicates, item.CountNotNil())
	}
	if i.Tier != nil {
		predicates = append(predicates, item.TierEQ(*i.Tier))
	}
	if i.TierNEQ != nil {
		predicates = append(predicates, item.TierNEQ(*i.TierNEQ))
	}
	if len(i.TierIn) > 0 {
		predicates = append(predicates, item.TierIn(i.TierIn...))
	}
	if len(i.TierNotIn) > 0 {
		predicates = append(predicates, item.TierNotIn(i.TierNotIn...))
	}
	if i.TierIsNil {
		predicates = append(predicates, item.TierIsNil())
	}
	if i.TierNotNil {
		predicates = append(predicates, item.TierNotNil())
	}
	if i.Greatness != nil {
		predicates = append(predicates, item.GreatnessEQ(*i.Greatness))
	}
	if i.GreatnessNEQ != nil {
		predicates = append(predicates, item.GreatnessNEQ(*i.GreatnessNEQ))
	}
	if len(i.GreatnessIn) > 0 {
		predicates = append(predicates, item.GreatnessIn(i.GreatnessIn...))
	}
	if len(i.GreatnessNotIn) > 0 {
		predicates = append(predicates, item.GreatnessNotIn(i.GreatnessNotIn...))
	}
	if i.GreatnessGT != nil {
		predicates = append(predicates, item.GreatnessGT(*i.GreatnessGT))
	}
	if i.GreatnessGTE != nil {
		predicates = append(predicates, item.GreatnessGTE(*i.GreatnessGTE))
	}
	if i.GreatnessLT != nil {
		predicates = append(predicates, item.GreatnessLT(*i.GreatnessLT))
	}
	if i.GreatnessLTE != nil {
		predicates = append(predicates, item.GreatnessLTE(*i.GreatnessLTE))
	}
	if i.GreatnessIsNil {
		predicates = append(predicates, item.GreatnessIsNil())
	}
	if i.GreatnessNotNil {
		predicates = append(predicates, item.GreatnessNotNil())
	}
	if i.Svg != nil {
		predicates = append(predicates, item.SvgEQ(*i.Svg))
	}
	if i.SvgNEQ != nil {
		predicates = append(predicates, item.SvgNEQ(*i.SvgNEQ))
	}
	if len(i.SvgIn) > 0 {
		predicates = append(predicates, item.SvgIn(i.SvgIn...))
	}
	if len(i.SvgNotIn) > 0 {
		predicates = append(predicates, item.SvgNotIn(i.SvgNotIn...))
	}
	if i.SvgGT != nil {
		predicates = append(predicates, item.SvgGT(*i.SvgGT))
	}
	if i.SvgGTE != nil {
		predicates = append(predicates, item.SvgGTE(*i.SvgGTE))
	}
	if i.SvgLT != nil {
		predicates = append(predicates, item.SvgLT(*i.SvgLT))
	}
	if i.SvgLTE != nil {
		predicates = append(predicates, item.SvgLTE(*i.SvgLTE))
	}
	if i.SvgContains != nil {
		predicates = append(predicates, item.SvgContains(*i.SvgContains))
	}
	if i.SvgHasPrefix != nil {
		predicates = append(predicates, item.SvgHasPrefix(*i.SvgHasPrefix))
	}
	if i.SvgHasSuffix != nil {
		predicates = append(predicates, item.SvgHasSuffix(*i.SvgHasSuffix))
	}
	if i.SvgIsNil {
		predicates = append(predicates, item.SvgIsNil())
	}
	if i.SvgNotNil {
		predicates = append(predicates, item.SvgNotNil())
	}
	if i.SvgEqualFold != nil {
		predicates = append(predicates, item.SvgEqualFold(*i.SvgEqualFold))
	}
	if i.SvgContainsFold != nil {
		predicates = append(predicates, item.SvgContainsFold(*i.SvgContainsFold))
	}

	if i.HasWallets != nil {
		p := item.HasWallets()
		if !*i.HasWallets {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWalletsWith) > 0 {
		with := make([]predicate.WalletItems, 0, len(i.HasWalletsWith))
		for _, w := range i.HasWalletsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasWalletsWith(with...))
	}
	if i.HasDopes != nil {
		p := item.HasDopes()
		if !*i.HasDopes {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDopesWith) > 0 {
		with := make([]predicate.Dope, 0, len(i.HasDopesWith))
		for _, w := range i.HasDopesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasDopesWith(with...))
	}
	if i.HasHustlerWeapons != nil {
		p := item.HasHustlerWeapons()
		if !*i.HasHustlerWeapons {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerWeaponsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerWeaponsWith))
		for _, w := range i.HasHustlerWeaponsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerWeaponsWith(with...))
	}
	if i.HasHustlerClothes != nil {
		p := item.HasHustlerClothes()
		if !*i.HasHustlerClothes {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerClothesWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerClothesWith))
		for _, w := range i.HasHustlerClothesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerClothesWith(with...))
	}
	if i.HasHustlerVehicles != nil {
		p := item.HasHustlerVehicles()
		if !*i.HasHustlerVehicles {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerVehiclesWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerVehiclesWith))
		for _, w := range i.HasHustlerVehiclesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerVehiclesWith(with...))
	}
	if i.HasHustlerWaists != nil {
		p := item.HasHustlerWaists()
		if !*i.HasHustlerWaists {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerWaistsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerWaistsWith))
		for _, w := range i.HasHustlerWaistsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerWaistsWith(with...))
	}
	if i.HasHustlerFeet != nil {
		p := item.HasHustlerFeet()
		if !*i.HasHustlerFeet {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerFeetWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerFeetWith))
		for _, w := range i.HasHustlerFeetWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerFeetWith(with...))
	}
	if i.HasHustlerHands != nil {
		p := item.HasHustlerHands()
		if !*i.HasHustlerHands {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerHandsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerHandsWith))
		for _, w := range i.HasHustlerHandsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerHandsWith(with...))
	}
	if i.HasHustlerDrugs != nil {
		p := item.HasHustlerDrugs()
		if !*i.HasHustlerDrugs {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerDrugsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerDrugsWith))
		for _, w := range i.HasHustlerDrugsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerDrugsWith(with...))
	}
	if i.HasHustlerNecks != nil {
		p := item.HasHustlerNecks()
		if !*i.HasHustlerNecks {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerNecksWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerNecksWith))
		for _, w := range i.HasHustlerNecksWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerNecksWith(with...))
	}
	if i.HasHustlerRings != nil {
		p := item.HasHustlerRings()
		if !*i.HasHustlerRings {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerRingsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerRingsWith))
		for _, w := range i.HasHustlerRingsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerRingsWith(with...))
	}
	if i.HasHustlerAccessories != nil {
		p := item.HasHustlerAccessories()
		if !*i.HasHustlerAccessories {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerAccessoriesWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerAccessoriesWith))
		for _, w := range i.HasHustlerAccessoriesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerAccessoriesWith(with...))
	}
	if i.HasBase != nil {
		p := item.HasBase()
		if !*i.HasBase {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBaseWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasBaseWith))
		for _, w := range i.HasBaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasBaseWith(with...))
	}
	if i.HasDerivative != nil {
		p := item.HasDerivative()
		if !*i.HasDerivative {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDerivativeWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasDerivativeWith))
		for _, w := range i.HasDerivativeWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasDerivativeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate ItemWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return item.And(predicates...), nil
	}
}

// ListingWhereInput represents a where input for filtering Listing queries.
type ListingWhereInput struct {
	Not *ListingWhereInput   `json:"not,omitempty"`
	Or  []*ListingWhereInput `json:"or,omitempty"`
	And []*ListingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "source" field predicates.
	Source      *listing.Source  `json:"source,omitempty"`
	SourceNEQ   *listing.Source  `json:"sourceNEQ,omitempty"`
	SourceIn    []listing.Source `json:"sourceIn,omitempty"`
	SourceNotIn []listing.Source `json:"sourceNotIn,omitempty"`

	// "dope" edge predicates.
	HasDope     *bool             `json:"hasDope,omitempty"`
	HasDopeWith []*DopeWhereInput `json:"hasDopeWith,omitempty"`

	// "dope_lastsales" edge predicates.
	HasDopeLastsales     *bool             `json:"hasDopeLastsales,omitempty"`
	HasDopeLastsalesWith []*DopeWhereInput `json:"hasDopeLastsalesWith,omitempty"`

	// "inputs" edge predicates.
	HasInputs     *bool              `json:"hasInputs,omitempty"`
	HasInputsWith []*AssetWhereInput `json:"hasInputsWith,omitempty"`

	// "outputs" edge predicates.
	HasOutputs     *bool              `json:"hasOutputs,omitempty"`
	HasOutputsWith []*AssetWhereInput `json:"hasOutputsWith,omitempty"`
}

// Filter applies the ListingWhereInput filter on the ListingQuery builder.
func (i *ListingWhereInput) Filter(q *ListingQuery) (*ListingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering listings.
// An error is returned if the input is empty or invalid.
func (i *ListingWhereInput) P() (predicate.Listing, error) {
	var predicates []predicate.Listing
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, listing.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Listing, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, listing.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Listing, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, listing.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, listing.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, listing.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, listing.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, listing.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, listing.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, listing.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, listing.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, listing.IDLTE(*i.IDLTE))
	}
	if i.Active != nil {
		predicates = append(predicates, listing.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, listing.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.Source != nil {
		predicates = append(predicates, listing.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, listing.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, listing.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, listing.SourceNotIn(i.SourceNotIn...))
	}

	if i.HasDope != nil {
		p := listing.HasDope()
		if !*i.HasDope {
			p = listing.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDopeWith) > 0 {
		with := make([]predicate.Dope, 0, len(i.HasDopeWith))
		for _, w := range i.HasDopeWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, listing.HasDopeWith(with...))
	}
	if i.HasDopeLastsales != nil {
		p := listing.HasDopeLastsales()
		if !*i.HasDopeLastsales {
			p = listing.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDopeLastsalesWith) > 0 {
		with := make([]predicate.Dope, 0, len(i.HasDopeLastsalesWith))
		for _, w := range i.HasDopeLastsalesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, listing.HasDopeLastsalesWith(with...))
	}
	if i.HasInputs != nil {
		p := listing.HasInputs()
		if !*i.HasInputs {
			p = listing.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInputsWith) > 0 {
		with := make([]predicate.Asset, 0, len(i.HasInputsWith))
		for _, w := range i.HasInputsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, listing.HasInputsWith(with...))
	}
	if i.HasOutputs != nil {
		p := listing.HasOutputs()
		if !*i.HasOutputs {
			p = listing.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOutputsWith) > 0 {
		with := make([]predicate.Asset, 0, len(i.HasOutputsWith))
		for _, w := range i.HasOutputsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, listing.HasOutputsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate ListingWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return listing.And(predicates...), nil
	}
}

// PaymentTokenWhereInput represents a where input for filtering PaymentToken queries.
type PaymentTokenWhereInput struct {
	Not *PaymentTokenWhereInput   `json:"not,omitempty"`
	Or  []*PaymentTokenWhereInput `json:"or,omitempty"`
	And []*PaymentTokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "symbol" field predicates.
	Symbol             *string  `json:"symbol,omitempty"`
	SymbolNEQ          *string  `json:"symbolNEQ,omitempty"`
	SymbolIn           []string `json:"symbolIn,omitempty"`
	SymbolNotIn        []string `json:"symbolNotIn,omitempty"`
	SymbolGT           *string  `json:"symbolGT,omitempty"`
	SymbolGTE          *string  `json:"symbolGTE,omitempty"`
	SymbolLT           *string  `json:"symbolLT,omitempty"`
	SymbolLTE          *string  `json:"symbolLTE,omitempty"`
	SymbolContains     *string  `json:"symbolContains,omitempty"`
	SymbolHasPrefix    *string  `json:"symbolHasPrefix,omitempty"`
	SymbolHasSuffix    *string  `json:"symbolHasSuffix,omitempty"`
	SymbolEqualFold    *string  `json:"symbolEqualFold,omitempty"`
	SymbolContainsFold *string  `json:"symbolContainsFold,omitempty"`

	// "price" field predicates.
	Price      *float64  `json:"price,omitempty"`
	PriceNEQ   *float64  `json:"priceNEQ,omitempty"`
	PriceIn    []float64 `json:"priceIn,omitempty"`
	PriceNotIn []float64 `json:"priceNotIn,omitempty"`
	PriceGT    *float64  `json:"priceGT,omitempty"`
	PriceGTE   *float64  `json:"priceGTE,omitempty"`
	PriceLT    *float64  `json:"priceLT,omitempty"`
	PriceLTE   *float64  `json:"priceLTE,omitempty"`

	// "asset" edge predicates.
	HasAsset     *bool              `json:"hasAsset,omitempty"`
	HasAssetWith []*AssetWhereInput `json:"hasAssetWith,omitempty"`
}

// Filter applies the PaymentTokenWhereInput filter on the PaymentTokenQuery builder.
func (i *PaymentTokenWhereInput) Filter(q *PaymentTokenQuery) (*PaymentTokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering paymenttokens.
// An error is returned if the input is empty or invalid.
func (i *PaymentTokenWhereInput) P() (predicate.PaymentToken, error) {
	var predicates []predicate.PaymentToken
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, paymenttoken.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PaymentToken, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, paymenttoken.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PaymentToken, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, paymenttoken.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, paymenttoken.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, paymenttoken.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, paymenttoken.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, paymenttoken.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, paymenttoken.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, paymenttoken.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, paymenttoken.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, paymenttoken.IDLTE(*i.IDLTE))
	}
	if i.Address != nil {
		predicates = append(predicates, paymenttoken.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, paymenttoken.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, paymenttoken.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, paymenttoken.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, paymenttoken.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, paymenttoken.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, paymenttoken.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, paymenttoken.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, paymenttoken.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, paymenttoken.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, paymenttoken.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, paymenttoken.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, paymenttoken.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, paymenttoken.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, paymenttoken.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, paymenttoken.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, paymenttoken.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, paymenttoken.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, paymenttoken.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, paymenttoken.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, paymenttoken.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, paymenttoken.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, paymenttoken.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, paymenttoken.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, paymenttoken.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, paymenttoken.TypeContainsFold(*i.TypeContainsFold))
	}
	if i.Symbol != nil {
		predicates = append(predicates, paymenttoken.SymbolEQ(*i.Symbol))
	}
	if i.SymbolNEQ != nil {
		predicates = append(predicates, paymenttoken.SymbolNEQ(*i.SymbolNEQ))
	}
	if len(i.SymbolIn) > 0 {
		predicates = append(predicates, paymenttoken.SymbolIn(i.SymbolIn...))
	}
	if len(i.SymbolNotIn) > 0 {
		predicates = append(predicates, paymenttoken.SymbolNotIn(i.SymbolNotIn...))
	}
	if i.SymbolGT != nil {
		predicates = append(predicates, paymenttoken.SymbolGT(*i.SymbolGT))
	}
	if i.SymbolGTE != nil {
		predicates = append(predicates, paymenttoken.SymbolGTE(*i.SymbolGTE))
	}
	if i.SymbolLT != nil {
		predicates = append(predicates, paymenttoken.SymbolLT(*i.SymbolLT))
	}
	if i.SymbolLTE != nil {
		predicates = append(predicates, paymenttoken.SymbolLTE(*i.SymbolLTE))
	}
	if i.SymbolContains != nil {
		predicates = append(predicates, paymenttoken.SymbolContains(*i.SymbolContains))
	}
	if i.SymbolHasPrefix != nil {
		predicates = append(predicates, paymenttoken.SymbolHasPrefix(*i.SymbolHasPrefix))
	}
	if i.SymbolHasSuffix != nil {
		predicates = append(predicates, paymenttoken.SymbolHasSuffix(*i.SymbolHasSuffix))
	}
	if i.SymbolEqualFold != nil {
		predicates = append(predicates, paymenttoken.SymbolEqualFold(*i.SymbolEqualFold))
	}
	if i.SymbolContainsFold != nil {
		predicates = append(predicates, paymenttoken.SymbolContainsFold(*i.SymbolContainsFold))
	}
	if i.Price != nil {
		predicates = append(predicates, paymenttoken.PriceEQ(*i.Price))
	}
	if i.PriceNEQ != nil {
		predicates = append(predicates, paymenttoken.PriceNEQ(*i.PriceNEQ))
	}
	if len(i.PriceIn) > 0 {
		predicates = append(predicates, paymenttoken.PriceIn(i.PriceIn...))
	}
	if len(i.PriceNotIn) > 0 {
		predicates = append(predicates, paymenttoken.PriceNotIn(i.PriceNotIn...))
	}
	if i.PriceGT != nil {
		predicates = append(predicates, paymenttoken.PriceGT(*i.PriceGT))
	}
	if i.PriceGTE != nil {
		predicates = append(predicates, paymenttoken.PriceGTE(*i.PriceGTE))
	}
	if i.PriceLT != nil {
		predicates = append(predicates, paymenttoken.PriceLT(*i.PriceLT))
	}
	if i.PriceLTE != nil {
		predicates = append(predicates, paymenttoken.PriceLTE(*i.PriceLTE))
	}

	if i.HasAsset != nil {
		p := paymenttoken.HasAsset()
		if !*i.HasAsset {
			p = paymenttoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssetWith) > 0 {
		with := make([]predicate.Asset, 0, len(i.HasAssetWith))
		for _, w := range i.HasAssetWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, paymenttoken.HasAssetWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate PaymentTokenWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return paymenttoken.And(predicates...), nil
	}
}

// SyncStateWhereInput represents a where input for filtering SyncState queries.
type SyncStateWhereInput struct {
	Not *SyncStateWhereInput   `json:"not,omitempty"`
	Or  []*SyncStateWhereInput `json:"or,omitempty"`
	And []*SyncStateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "start_block" field predicates.
	StartBlock      *uint64  `json:"startBlock,omitempty"`
	StartBlockNEQ   *uint64  `json:"startBlockNEQ,omitempty"`
	StartBlockIn    []uint64 `json:"startBlockIn,omitempty"`
	StartBlockNotIn []uint64 `json:"startBlockNotIn,omitempty"`
	StartBlockGT    *uint64  `json:"startBlockGT,omitempty"`
	StartBlockGTE   *uint64  `json:"startBlockGTE,omitempty"`
	StartBlockLT    *uint64  `json:"startBlockLT,omitempty"`
	StartBlockLTE   *uint64  `json:"startBlockLTE,omitempty"`
}

// Filter applies the SyncStateWhereInput filter on the SyncStateQuery builder.
func (i *SyncStateWhereInput) Filter(q *SyncStateQuery) (*SyncStateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering syncstates.
// An error is returned if the input is empty or invalid.
func (i *SyncStateWhereInput) P() (predicate.SyncState, error) {
	var predicates []predicate.SyncState
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, syncstate.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SyncState, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, syncstate.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SyncState, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, syncstate.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, syncstate.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, syncstate.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, syncstate.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, syncstate.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, syncstate.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, syncstate.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, syncstate.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, syncstate.IDLTE(*i.IDLTE))
	}
	if i.StartBlock != nil {
		predicates = append(predicates, syncstate.StartBlockEQ(*i.StartBlock))
	}
	if i.StartBlockNEQ != nil {
		predicates = append(predicates, syncstate.StartBlockNEQ(*i.StartBlockNEQ))
	}
	if len(i.StartBlockIn) > 0 {
		predicates = append(predicates, syncstate.StartBlockIn(i.StartBlockIn...))
	}
	if len(i.StartBlockNotIn) > 0 {
		predicates = append(predicates, syncstate.StartBlockNotIn(i.StartBlockNotIn...))
	}
	if i.StartBlockGT != nil {
		predicates = append(predicates, syncstate.StartBlockGT(*i.StartBlockGT))
	}
	if i.StartBlockGTE != nil {
		predicates = append(predicates, syncstate.StartBlockGTE(*i.StartBlockGTE))
	}
	if i.StartBlockLT != nil {
		predicates = append(predicates, syncstate.StartBlockLT(*i.StartBlockLT))
	}
	if i.StartBlockLTE != nil {
		predicates = append(predicates, syncstate.StartBlockLTE(*i.StartBlockLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate SyncStateWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return syncstate.And(predicates...), nil
	}
}

// WalletWhereInput represents a where input for filtering Wallet queries.
type WalletWhereInput struct {
	Not *WalletWhereInput   `json:"not,omitempty"`
	Or  []*WalletWhereInput `json:"or,omitempty"`
	And []*WalletWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "paper" field predicates.
	Paper      *schema.BigInt  `json:"paper,omitempty"`
	PaperNEQ   *schema.BigInt  `json:"paperNEQ,omitempty"`
	PaperIn    []schema.BigInt `json:"paperIn,omitempty"`
	PaperNotIn []schema.BigInt `json:"paperNotIn,omitempty"`
	PaperGT    *schema.BigInt  `json:"paperGT,omitempty"`
	PaperGTE   *schema.BigInt  `json:"paperGTE,omitempty"`
	PaperLT    *schema.BigInt  `json:"paperLT,omitempty"`
	PaperLTE   *schema.BigInt  `json:"paperLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "dopes" edge predicates.
	HasDopes     *bool             `json:"hasDopes,omitempty"`
	HasDopesWith []*DopeWhereInput `json:"hasDopesWith,omitempty"`

	// "items" edge predicates.
	HasItems     *bool                    `json:"hasItems,omitempty"`
	HasItemsWith []*WalletItemsWhereInput `json:"hasItemsWith,omitempty"`

	// "hustlers" edge predicates.
	HasHustlers     *bool                `json:"hasHustlers,omitempty"`
	HasHustlersWith []*HustlerWhereInput `json:"hasHustlersWith,omitempty"`
}

// Filter applies the WalletWhereInput filter on the WalletQuery builder.
func (i *WalletWhereInput) Filter(q *WalletQuery) (*WalletQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering wallets.
// An error is returned if the input is empty or invalid.
func (i *WalletWhereInput) P() (predicate.Wallet, error) {
	var predicates []predicate.Wallet
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, wallet.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Wallet, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, wallet.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Wallet, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, wallet.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, wallet.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, wallet.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, wallet.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, wallet.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, wallet.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, wallet.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, wallet.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, wallet.IDLTE(*i.IDLTE))
	}
	if i.Paper != nil {
		predicates = append(predicates, wallet.PaperEQ(*i.Paper))
	}
	if i.PaperNEQ != nil {
		predicates = append(predicates, wallet.PaperNEQ(*i.PaperNEQ))
	}
	if len(i.PaperIn) > 0 {
		predicates = append(predicates, wallet.PaperIn(i.PaperIn...))
	}
	if len(i.PaperNotIn) > 0 {
		predicates = append(predicates, wallet.PaperNotIn(i.PaperNotIn...))
	}
	if i.PaperGT != nil {
		predicates = append(predicates, wallet.PaperGT(*i.PaperGT))
	}
	if i.PaperGTE != nil {
		predicates = append(predicates, wallet.PaperGTE(*i.PaperGTE))
	}
	if i.PaperLT != nil {
		predicates = append(predicates, wallet.PaperLT(*i.PaperLT))
	}
	if i.PaperLTE != nil {
		predicates = append(predicates, wallet.PaperLTE(*i.PaperLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, wallet.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, wallet.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, wallet.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, wallet.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, wallet.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, wallet.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, wallet.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, wallet.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasDopes != nil {
		p := wallet.HasDopes()
		if !*i.HasDopes {
			p = wallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDopesWith) > 0 {
		with := make([]predicate.Dope, 0, len(i.HasDopesWith))
		for _, w := range i.HasDopesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, wallet.HasDopesWith(with...))
	}
	if i.HasItems != nil {
		p := wallet.HasItems()
		if !*i.HasItems {
			p = wallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemsWith) > 0 {
		with := make([]predicate.WalletItems, 0, len(i.HasItemsWith))
		for _, w := range i.HasItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, wallet.HasItemsWith(with...))
	}
	if i.HasHustlers != nil {
		p := wallet.HasHustlers()
		if !*i.HasHustlers {
			p = wallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlersWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlersWith))
		for _, w := range i.HasHustlersWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, wallet.HasHustlersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate WalletWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return wallet.And(predicates...), nil
	}
}

// WalletItemsWhereInput represents a where input for filtering WalletItems queries.
type WalletItemsWhereInput struct {
	Not *WalletItemsWhereInput   `json:"not,omitempty"`
	Or  []*WalletItemsWhereInput `json:"or,omitempty"`
	And []*WalletItemsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "balance" field predicates.
	Balance      *schema.BigInt  `json:"balance,omitempty"`
	BalanceNEQ   *schema.BigInt  `json:"balanceNEQ,omitempty"`
	BalanceIn    []schema.BigInt `json:"balanceIn,omitempty"`
	BalanceNotIn []schema.BigInt `json:"balanceNotIn,omitempty"`
	BalanceGT    *schema.BigInt  `json:"balanceGT,omitempty"`
	BalanceGTE   *schema.BigInt  `json:"balanceGTE,omitempty"`
	BalanceLT    *schema.BigInt  `json:"balanceLT,omitempty"`
	BalanceLTE   *schema.BigInt  `json:"balanceLTE,omitempty"`

	// "wallet" edge predicates.
	HasWallet     *bool               `json:"hasWallet,omitempty"`
	HasWalletWith []*WalletWhereInput `json:"hasWalletWith,omitempty"`

	// "item" edge predicates.
	HasItem     *bool             `json:"hasItem,omitempty"`
	HasItemWith []*ItemWhereInput `json:"hasItemWith,omitempty"`
}

// Filter applies the WalletItemsWhereInput filter on the WalletItemsQuery builder.
func (i *WalletItemsWhereInput) Filter(q *WalletItemsQuery) (*WalletItemsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering walletitemsslice.
// An error is returned if the input is empty or invalid.
func (i *WalletItemsWhereInput) P() (predicate.WalletItems, error) {
	var predicates []predicate.WalletItems
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, walletitems.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.WalletItems, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, walletitems.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.WalletItems, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, walletitems.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, walletitems.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, walletitems.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, walletitems.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, walletitems.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, walletitems.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, walletitems.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, walletitems.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, walletitems.IDLTE(*i.IDLTE))
	}
	if i.Balance != nil {
		predicates = append(predicates, walletitems.BalanceEQ(*i.Balance))
	}
	if i.BalanceNEQ != nil {
		predicates = append(predicates, walletitems.BalanceNEQ(*i.BalanceNEQ))
	}
	if len(i.BalanceIn) > 0 {
		predicates = append(predicates, walletitems.BalanceIn(i.BalanceIn...))
	}
	if len(i.BalanceNotIn) > 0 {
		predicates = append(predicates, walletitems.BalanceNotIn(i.BalanceNotIn...))
	}
	if i.BalanceGT != nil {
		predicates = append(predicates, walletitems.BalanceGT(*i.BalanceGT))
	}
	if i.BalanceGTE != nil {
		predicates = append(predicates, walletitems.BalanceGTE(*i.BalanceGTE))
	}
	if i.BalanceLT != nil {
		predicates = append(predicates, walletitems.BalanceLT(*i.BalanceLT))
	}
	if i.BalanceLTE != nil {
		predicates = append(predicates, walletitems.BalanceLTE(*i.BalanceLTE))
	}

	if i.HasWallet != nil {
		p := walletitems.HasWallet()
		if !*i.HasWallet {
			p = walletitems.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWalletWith) > 0 {
		with := make([]predicate.Wallet, 0, len(i.HasWalletWith))
		for _, w := range i.HasWalletWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, walletitems.HasWalletWith(with...))
	}
	if i.HasItem != nil {
		p := walletitems.HasItem()
		if !*i.HasItem {
			p = walletitems.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasItemWith))
		for _, w := range i.HasItemWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, walletitems.HasItemWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate WalletItemsWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return walletitems.And(predicates...), nil
	}
}
