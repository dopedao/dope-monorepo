// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"

	"github.com/dopedao/dope-monorepo/packages/api/ent/bodypart"
	"github.com/dopedao/dope-monorepo/packages/api/ent/dope"
	"github.com/dopedao/dope-monorepo/packages/api/ent/hustler"
	"github.com/dopedao/dope-monorepo/packages/api/ent/item"
	"github.com/dopedao/dope-monorepo/packages/api/ent/predicate"
	"github.com/dopedao/dope-monorepo/packages/api/ent/schema"
	"github.com/dopedao/dope-monorepo/packages/api/ent/syncstate"
	"github.com/dopedao/dope-monorepo/packages/api/ent/wallet"
	"github.com/dopedao/dope-monorepo/packages/api/ent/walletitems"
)

// BodyPartWhereInput represents a where input for filtering BodyPart queries.
type BodyPartWhereInput struct {
	Not *BodyPartWhereInput   `json:"not,omitempty"`
	Or  []*BodyPartWhereInput `json:"or,omitempty"`
	And []*BodyPartWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type      *bodypart.Type  `json:"type,omitempty"`
	TypeNEQ   *bodypart.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []bodypart.Type `json:"typeIn,omitempty"`
	TypeNotIn []bodypart.Type `json:"typeNotIn,omitempty"`

	// "sex" field predicates.
	Sex      *bodypart.Sex  `json:"sex,omitempty"`
	SexNEQ   *bodypart.Sex  `json:"sexNEQ,omitempty"`
	SexIn    []bodypart.Sex `json:"sexIn,omitempty"`
	SexNotIn []bodypart.Sex `json:"sexNotIn,omitempty"`

	// "rle" field predicates.
	Rle             *string  `json:"rle,omitempty"`
	RleNEQ          *string  `json:"rleNEQ,omitempty"`
	RleIn           []string `json:"rleIn,omitempty"`
	RleNotIn        []string `json:"rleNotIn,omitempty"`
	RleGT           *string  `json:"rleGT,omitempty"`
	RleGTE          *string  `json:"rleGTE,omitempty"`
	RleLT           *string  `json:"rleLT,omitempty"`
	RleLTE          *string  `json:"rleLTE,omitempty"`
	RleContains     *string  `json:"rleContains,omitempty"`
	RleHasPrefix    *string  `json:"rleHasPrefix,omitempty"`
	RleHasSuffix    *string  `json:"rleHasSuffix,omitempty"`
	RleEqualFold    *string  `json:"rleEqualFold,omitempty"`
	RleContainsFold *string  `json:"rleContainsFold,omitempty"`

	// "hustler_bodies" edge predicates.
	HasHustlerBodies     *bool                `json:"hasHustlerBodies,omitempty"`
	HasHustlerBodiesWith []*HustlerWhereInput `json:"hasHustlerBodiesWith,omitempty"`

	// "hustler_hairs" edge predicates.
	HasHustlerHairs     *bool                `json:"hasHustlerHairs,omitempty"`
	HasHustlerHairsWith []*HustlerWhereInput `json:"hasHustlerHairsWith,omitempty"`

	// "hustler_beards" edge predicates.
	HasHustlerBeards     *bool                `json:"hasHustlerBeards,omitempty"`
	HasHustlerBeardsWith []*HustlerWhereInput `json:"hasHustlerBeardsWith,omitempty"`
}

// Filter applies the BodyPartWhereInput filter on the BodyPartQuery builder.
func (i *BodyPartWhereInput) Filter(q *BodyPartQuery) (*BodyPartQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering bodyparts.
// An error is returned if the input is empty or invalid.
func (i *BodyPartWhereInput) P() (predicate.BodyPart, error) {
	var predicates []predicate.BodyPart
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, bodypart.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.BodyPart, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, bodypart.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.BodyPart, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, bodypart.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, bodypart.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, bodypart.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, bodypart.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, bodypart.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, bodypart.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, bodypart.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, bodypart.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, bodypart.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, bodypart.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, bodypart.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, bodypart.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, bodypart.TypeNotIn(i.TypeNotIn...))
	}
	if i.Sex != nil {
		predicates = append(predicates, bodypart.SexEQ(*i.Sex))
	}
	if i.SexNEQ != nil {
		predicates = append(predicates, bodypart.SexNEQ(*i.SexNEQ))
	}
	if len(i.SexIn) > 0 {
		predicates = append(predicates, bodypart.SexIn(i.SexIn...))
	}
	if len(i.SexNotIn) > 0 {
		predicates = append(predicates, bodypart.SexNotIn(i.SexNotIn...))
	}
	if i.Rle != nil {
		predicates = append(predicates, bodypart.RleEQ(*i.Rle))
	}
	if i.RleNEQ != nil {
		predicates = append(predicates, bodypart.RleNEQ(*i.RleNEQ))
	}
	if len(i.RleIn) > 0 {
		predicates = append(predicates, bodypart.RleIn(i.RleIn...))
	}
	if len(i.RleNotIn) > 0 {
		predicates = append(predicates, bodypart.RleNotIn(i.RleNotIn...))
	}
	if i.RleGT != nil {
		predicates = append(predicates, bodypart.RleGT(*i.RleGT))
	}
	if i.RleGTE != nil {
		predicates = append(predicates, bodypart.RleGTE(*i.RleGTE))
	}
	if i.RleLT != nil {
		predicates = append(predicates, bodypart.RleLT(*i.RleLT))
	}
	if i.RleLTE != nil {
		predicates = append(predicates, bodypart.RleLTE(*i.RleLTE))
	}
	if i.RleContains != nil {
		predicates = append(predicates, bodypart.RleContains(*i.RleContains))
	}
	if i.RleHasPrefix != nil {
		predicates = append(predicates, bodypart.RleHasPrefix(*i.RleHasPrefix))
	}
	if i.RleHasSuffix != nil {
		predicates = append(predicates, bodypart.RleHasSuffix(*i.RleHasSuffix))
	}
	if i.RleEqualFold != nil {
		predicates = append(predicates, bodypart.RleEqualFold(*i.RleEqualFold))
	}
	if i.RleContainsFold != nil {
		predicates = append(predicates, bodypart.RleContainsFold(*i.RleContainsFold))
	}

	if i.HasHustlerBodies != nil {
		p := bodypart.HasHustlerBodies()
		if !*i.HasHustlerBodies {
			p = bodypart.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerBodiesWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerBodiesWith))
		for _, w := range i.HasHustlerBodiesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, bodypart.HasHustlerBodiesWith(with...))
	}
	if i.HasHustlerHairs != nil {
		p := bodypart.HasHustlerHairs()
		if !*i.HasHustlerHairs {
			p = bodypart.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerHairsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerHairsWith))
		for _, w := range i.HasHustlerHairsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, bodypart.HasHustlerHairsWith(with...))
	}
	if i.HasHustlerBeards != nil {
		p := bodypart.HasHustlerBeards()
		if !*i.HasHustlerBeards {
			p = bodypart.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerBeardsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerBeardsWith))
		for _, w := range i.HasHustlerBeardsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, bodypart.HasHustlerBeardsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate BodyPartWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return bodypart.And(predicates...), nil
	}
}

// DopeWhereInput represents a where input for filtering Dope queries.
type DopeWhereInput struct {
	Not *DopeWhereInput   `json:"not,omitempty"`
	Or  []*DopeWhereInput `json:"or,omitempty"`
	And []*DopeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "claimed" field predicates.
	Claimed    *bool `json:"claimed,omitempty"`
	ClaimedNEQ *bool `json:"claimedNEQ,omitempty"`

	// "opened" field predicates.
	Opened    *bool `json:"opened,omitempty"`
	OpenedNEQ *bool `json:"openedNEQ,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "wallet" edge predicates.
	HasWallet     *bool               `json:"hasWallet,omitempty"`
	HasWalletWith []*WalletWhereInput `json:"hasWalletWith,omitempty"`

	// "items" edge predicates.
	HasItems     *bool             `json:"hasItems,omitempty"`
	HasItemsWith []*ItemWhereInput `json:"hasItemsWith,omitempty"`
}

// Filter applies the DopeWhereInput filter on the DopeQuery builder.
func (i *DopeWhereInput) Filter(q *DopeQuery) (*DopeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering dopes.
// An error is returned if the input is empty or invalid.
func (i *DopeWhereInput) P() (predicate.Dope, error) {
	var predicates []predicate.Dope
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, dope.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Dope, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, dope.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Dope, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, dope.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, dope.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dope.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dope.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dope.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dope.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dope.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dope.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dope.IDLTE(*i.IDLTE))
	}
	if i.Claimed != nil {
		predicates = append(predicates, dope.ClaimedEQ(*i.Claimed))
	}
	if i.ClaimedNEQ != nil {
		predicates = append(predicates, dope.ClaimedNEQ(*i.ClaimedNEQ))
	}
	if i.Opened != nil {
		predicates = append(predicates, dope.OpenedEQ(*i.Opened))
	}
	if i.OpenedNEQ != nil {
		predicates = append(predicates, dope.OpenedNEQ(*i.OpenedNEQ))
	}
	if i.Order != nil {
		predicates = append(predicates, dope.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, dope.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, dope.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, dope.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, dope.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, dope.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, dope.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, dope.OrderLTE(*i.OrderLTE))
	}

	if i.HasWallet != nil {
		p := dope.HasWallet()
		if !*i.HasWallet {
			p = dope.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWalletWith) > 0 {
		with := make([]predicate.Wallet, 0, len(i.HasWalletWith))
		for _, w := range i.HasWalletWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, dope.HasWalletWith(with...))
	}
	if i.HasItems != nil {
		p := dope.HasItems()
		if !*i.HasItems {
			p = dope.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemsWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasItemsWith))
		for _, w := range i.HasItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, dope.HasItemsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate DopeWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return dope.And(predicates...), nil
	}
}

// HustlerWhereInput represents a where input for filtering Hustler queries.
type HustlerWhereInput struct {
	Not *HustlerWhereInput   `json:"not,omitempty"`
	Or  []*HustlerWhereInput `json:"or,omitempty"`
	And []*HustlerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type      *hustler.Type  `json:"type,omitempty"`
	TypeNEQ   *hustler.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []hustler.Type `json:"typeIn,omitempty"`
	TypeNotIn []hustler.Type `json:"typeNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        bool     `json:"titleIsNil,omitempty"`
	TitleNotNil       bool     `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "color" field predicates.
	Color             *string  `json:"color,omitempty"`
	ColorNEQ          *string  `json:"colorNEQ,omitempty"`
	ColorIn           []string `json:"colorIn,omitempty"`
	ColorNotIn        []string `json:"colorNotIn,omitempty"`
	ColorGT           *string  `json:"colorGT,omitempty"`
	ColorGTE          *string  `json:"colorGTE,omitempty"`
	ColorLT           *string  `json:"colorLT,omitempty"`
	ColorLTE          *string  `json:"colorLTE,omitempty"`
	ColorContains     *string  `json:"colorContains,omitempty"`
	ColorHasPrefix    *string  `json:"colorHasPrefix,omitempty"`
	ColorHasSuffix    *string  `json:"colorHasSuffix,omitempty"`
	ColorIsNil        bool     `json:"colorIsNil,omitempty"`
	ColorNotNil       bool     `json:"colorNotNil,omitempty"`
	ColorEqualFold    *string  `json:"colorEqualFold,omitempty"`
	ColorContainsFold *string  `json:"colorContainsFold,omitempty"`

	// "background" field predicates.
	Background             *string  `json:"background,omitempty"`
	BackgroundNEQ          *string  `json:"backgroundNEQ,omitempty"`
	BackgroundIn           []string `json:"backgroundIn,omitempty"`
	BackgroundNotIn        []string `json:"backgroundNotIn,omitempty"`
	BackgroundGT           *string  `json:"backgroundGT,omitempty"`
	BackgroundGTE          *string  `json:"backgroundGTE,omitempty"`
	BackgroundLT           *string  `json:"backgroundLT,omitempty"`
	BackgroundLTE          *string  `json:"backgroundLTE,omitempty"`
	BackgroundContains     *string  `json:"backgroundContains,omitempty"`
	BackgroundHasPrefix    *string  `json:"backgroundHasPrefix,omitempty"`
	BackgroundHasSuffix    *string  `json:"backgroundHasSuffix,omitempty"`
	BackgroundIsNil        bool     `json:"backgroundIsNil,omitempty"`
	BackgroundNotNil       bool     `json:"backgroundNotNil,omitempty"`
	BackgroundEqualFold    *string  `json:"backgroundEqualFold,omitempty"`
	BackgroundContainsFold *string  `json:"backgroundContainsFold,omitempty"`

	// "age" field predicates.
	Age      *uint64  `json:"age,omitempty"`
	AgeNEQ   *uint64  `json:"ageNEQ,omitempty"`
	AgeIn    []uint64 `json:"ageIn,omitempty"`
	AgeNotIn []uint64 `json:"ageNotIn,omitempty"`
	AgeGT    *uint64  `json:"ageGT,omitempty"`
	AgeGTE   *uint64  `json:"ageGTE,omitempty"`
	AgeLT    *uint64  `json:"ageLT,omitempty"`
	AgeLTE   *uint64  `json:"ageLTE,omitempty"`

	// "sex" field predicates.
	Sex      *hustler.Sex  `json:"sex,omitempty"`
	SexNEQ   *hustler.Sex  `json:"sexNEQ,omitempty"`
	SexIn    []hustler.Sex `json:"sexIn,omitempty"`
	SexNotIn []hustler.Sex `json:"sexNotIn,omitempty"`

	// "svg" field predicates.
	Svg             *string  `json:"svg,omitempty"`
	SvgNEQ          *string  `json:"svgNEQ,omitempty"`
	SvgIn           []string `json:"svgIn,omitempty"`
	SvgNotIn        []string `json:"svgNotIn,omitempty"`
	SvgGT           *string  `json:"svgGT,omitempty"`
	SvgGTE          *string  `json:"svgGTE,omitempty"`
	SvgLT           *string  `json:"svgLT,omitempty"`
	SvgLTE          *string  `json:"svgLTE,omitempty"`
	SvgContains     *string  `json:"svgContains,omitempty"`
	SvgHasPrefix    *string  `json:"svgHasPrefix,omitempty"`
	SvgHasSuffix    *string  `json:"svgHasSuffix,omitempty"`
	SvgIsNil        bool     `json:"svgIsNil,omitempty"`
	SvgNotNil       bool     `json:"svgNotNil,omitempty"`
	SvgEqualFold    *string  `json:"svgEqualFold,omitempty"`
	SvgContainsFold *string  `json:"svgContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "wallet" edge predicates.
	HasWallet     *bool               `json:"hasWallet,omitempty"`
	HasWalletWith []*WalletWhereInput `json:"hasWalletWith,omitempty"`

	// "weapon" edge predicates.
	HasWeapon     *bool             `json:"hasWeapon,omitempty"`
	HasWeaponWith []*ItemWhereInput `json:"hasWeaponWith,omitempty"`

	// "clothes" edge predicates.
	HasClothes     *bool             `json:"hasClothes,omitempty"`
	HasClothesWith []*ItemWhereInput `json:"hasClothesWith,omitempty"`

	// "vehicle" edge predicates.
	HasVehicle     *bool             `json:"hasVehicle,omitempty"`
	HasVehicleWith []*ItemWhereInput `json:"hasVehicleWith,omitempty"`

	// "waist" edge predicates.
	HasWaist     *bool             `json:"hasWaist,omitempty"`
	HasWaistWith []*ItemWhereInput `json:"hasWaistWith,omitempty"`

	// "foot" edge predicates.
	HasFoot     *bool             `json:"hasFoot,omitempty"`
	HasFootWith []*ItemWhereInput `json:"hasFootWith,omitempty"`

	// "hand" edge predicates.
	HasHand     *bool             `json:"hasHand,omitempty"`
	HasHandWith []*ItemWhereInput `json:"hasHandWith,omitempty"`

	// "drug" edge predicates.
	HasDrug     *bool             `json:"hasDrug,omitempty"`
	HasDrugWith []*ItemWhereInput `json:"hasDrugWith,omitempty"`

	// "neck" edge predicates.
	HasNeck     *bool             `json:"hasNeck,omitempty"`
	HasNeckWith []*ItemWhereInput `json:"hasNeckWith,omitempty"`

	// "ring" edge predicates.
	HasRing     *bool             `json:"hasRing,omitempty"`
	HasRingWith []*ItemWhereInput `json:"hasRingWith,omitempty"`

	// "accessory" edge predicates.
	HasAccessory     *bool             `json:"hasAccessory,omitempty"`
	HasAccessoryWith []*ItemWhereInput `json:"hasAccessoryWith,omitempty"`

	// "body" edge predicates.
	HasBody     *bool                 `json:"hasBody,omitempty"`
	HasBodyWith []*BodyPartWhereInput `json:"hasBodyWith,omitempty"`

	// "hair" edge predicates.
	HasHair     *bool                 `json:"hasHair,omitempty"`
	HasHairWith []*BodyPartWhereInput `json:"hasHairWith,omitempty"`

	// "beard" edge predicates.
	HasBeard     *bool                 `json:"hasBeard,omitempty"`
	HasBeardWith []*BodyPartWhereInput `json:"hasBeardWith,omitempty"`
}

// Filter applies the HustlerWhereInput filter on the HustlerQuery builder.
func (i *HustlerWhereInput) Filter(q *HustlerQuery) (*HustlerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering hustlers.
// An error is returned if the input is empty or invalid.
func (i *HustlerWhereInput) P() (predicate.Hustler, error) {
	var predicates []predicate.Hustler
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, hustler.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Hustler, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, hustler.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Hustler, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, hustler.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, hustler.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, hustler.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, hustler.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, hustler.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, hustler.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, hustler.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, hustler.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, hustler.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, hustler.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, hustler.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, hustler.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, hustler.TypeNotIn(i.TypeNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, hustler.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, hustler.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, hustler.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, hustler.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, hustler.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, hustler.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, hustler.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, hustler.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, hustler.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, hustler.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, hustler.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, hustler.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, hustler.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, hustler.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, hustler.NameContainsFold(*i.NameContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, hustler.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, hustler.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, hustler.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, hustler.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, hustler.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, hustler.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, hustler.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, hustler.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, hustler.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, hustler.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, hustler.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleIsNil {
		predicates = append(predicates, hustler.TitleIsNil())
	}
	if i.TitleNotNil {
		predicates = append(predicates, hustler.TitleNotNil())
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, hustler.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, hustler.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Color != nil {
		predicates = append(predicates, hustler.ColorEQ(*i.Color))
	}
	if i.ColorNEQ != nil {
		predicates = append(predicates, hustler.ColorNEQ(*i.ColorNEQ))
	}
	if len(i.ColorIn) > 0 {
		predicates = append(predicates, hustler.ColorIn(i.ColorIn...))
	}
	if len(i.ColorNotIn) > 0 {
		predicates = append(predicates, hustler.ColorNotIn(i.ColorNotIn...))
	}
	if i.ColorGT != nil {
		predicates = append(predicates, hustler.ColorGT(*i.ColorGT))
	}
	if i.ColorGTE != nil {
		predicates = append(predicates, hustler.ColorGTE(*i.ColorGTE))
	}
	if i.ColorLT != nil {
		predicates = append(predicates, hustler.ColorLT(*i.ColorLT))
	}
	if i.ColorLTE != nil {
		predicates = append(predicates, hustler.ColorLTE(*i.ColorLTE))
	}
	if i.ColorContains != nil {
		predicates = append(predicates, hustler.ColorContains(*i.ColorContains))
	}
	if i.ColorHasPrefix != nil {
		predicates = append(predicates, hustler.ColorHasPrefix(*i.ColorHasPrefix))
	}
	if i.ColorHasSuffix != nil {
		predicates = append(predicates, hustler.ColorHasSuffix(*i.ColorHasSuffix))
	}
	if i.ColorIsNil {
		predicates = append(predicates, hustler.ColorIsNil())
	}
	if i.ColorNotNil {
		predicates = append(predicates, hustler.ColorNotNil())
	}
	if i.ColorEqualFold != nil {
		predicates = append(predicates, hustler.ColorEqualFold(*i.ColorEqualFold))
	}
	if i.ColorContainsFold != nil {
		predicates = append(predicates, hustler.ColorContainsFold(*i.ColorContainsFold))
	}
	if i.Background != nil {
		predicates = append(predicates, hustler.BackgroundEQ(*i.Background))
	}
	if i.BackgroundNEQ != nil {
		predicates = append(predicates, hustler.BackgroundNEQ(*i.BackgroundNEQ))
	}
	if len(i.BackgroundIn) > 0 {
		predicates = append(predicates, hustler.BackgroundIn(i.BackgroundIn...))
	}
	if len(i.BackgroundNotIn) > 0 {
		predicates = append(predicates, hustler.BackgroundNotIn(i.BackgroundNotIn...))
	}
	if i.BackgroundGT != nil {
		predicates = append(predicates, hustler.BackgroundGT(*i.BackgroundGT))
	}
	if i.BackgroundGTE != nil {
		predicates = append(predicates, hustler.BackgroundGTE(*i.BackgroundGTE))
	}
	if i.BackgroundLT != nil {
		predicates = append(predicates, hustler.BackgroundLT(*i.BackgroundLT))
	}
	if i.BackgroundLTE != nil {
		predicates = append(predicates, hustler.BackgroundLTE(*i.BackgroundLTE))
	}
	if i.BackgroundContains != nil {
		predicates = append(predicates, hustler.BackgroundContains(*i.BackgroundContains))
	}
	if i.BackgroundHasPrefix != nil {
		predicates = append(predicates, hustler.BackgroundHasPrefix(*i.BackgroundHasPrefix))
	}
	if i.BackgroundHasSuffix != nil {
		predicates = append(predicates, hustler.BackgroundHasSuffix(*i.BackgroundHasSuffix))
	}
	if i.BackgroundIsNil {
		predicates = append(predicates, hustler.BackgroundIsNil())
	}
	if i.BackgroundNotNil {
		predicates = append(predicates, hustler.BackgroundNotNil())
	}
	if i.BackgroundEqualFold != nil {
		predicates = append(predicates, hustler.BackgroundEqualFold(*i.BackgroundEqualFold))
	}
	if i.BackgroundContainsFold != nil {
		predicates = append(predicates, hustler.BackgroundContainsFold(*i.BackgroundContainsFold))
	}
	if i.Age != nil {
		predicates = append(predicates, hustler.AgeEQ(*i.Age))
	}
	if i.AgeNEQ != nil {
		predicates = append(predicates, hustler.AgeNEQ(*i.AgeNEQ))
	}
	if len(i.AgeIn) > 0 {
		predicates = append(predicates, hustler.AgeIn(i.AgeIn...))
	}
	if len(i.AgeNotIn) > 0 {
		predicates = append(predicates, hustler.AgeNotIn(i.AgeNotIn...))
	}
	if i.AgeGT != nil {
		predicates = append(predicates, hustler.AgeGT(*i.AgeGT))
	}
	if i.AgeGTE != nil {
		predicates = append(predicates, hustler.AgeGTE(*i.AgeGTE))
	}
	if i.AgeLT != nil {
		predicates = append(predicates, hustler.AgeLT(*i.AgeLT))
	}
	if i.AgeLTE != nil {
		predicates = append(predicates, hustler.AgeLTE(*i.AgeLTE))
	}
	if i.Sex != nil {
		predicates = append(predicates, hustler.SexEQ(*i.Sex))
	}
	if i.SexNEQ != nil {
		predicates = append(predicates, hustler.SexNEQ(*i.SexNEQ))
	}
	if len(i.SexIn) > 0 {
		predicates = append(predicates, hustler.SexIn(i.SexIn...))
	}
	if len(i.SexNotIn) > 0 {
		predicates = append(predicates, hustler.SexNotIn(i.SexNotIn...))
	}
	if i.Svg != nil {
		predicates = append(predicates, hustler.SvgEQ(*i.Svg))
	}
	if i.SvgNEQ != nil {
		predicates = append(predicates, hustler.SvgNEQ(*i.SvgNEQ))
	}
	if len(i.SvgIn) > 0 {
		predicates = append(predicates, hustler.SvgIn(i.SvgIn...))
	}
	if len(i.SvgNotIn) > 0 {
		predicates = append(predicates, hustler.SvgNotIn(i.SvgNotIn...))
	}
	if i.SvgGT != nil {
		predicates = append(predicates, hustler.SvgGT(*i.SvgGT))
	}
	if i.SvgGTE != nil {
		predicates = append(predicates, hustler.SvgGTE(*i.SvgGTE))
	}
	if i.SvgLT != nil {
		predicates = append(predicates, hustler.SvgLT(*i.SvgLT))
	}
	if i.SvgLTE != nil {
		predicates = append(predicates, hustler.SvgLTE(*i.SvgLTE))
	}
	if i.SvgContains != nil {
		predicates = append(predicates, hustler.SvgContains(*i.SvgContains))
	}
	if i.SvgHasPrefix != nil {
		predicates = append(predicates, hustler.SvgHasPrefix(*i.SvgHasPrefix))
	}
	if i.SvgHasSuffix != nil {
		predicates = append(predicates, hustler.SvgHasSuffix(*i.SvgHasSuffix))
	}
	if i.SvgIsNil {
		predicates = append(predicates, hustler.SvgIsNil())
	}
	if i.SvgNotNil {
		predicates = append(predicates, hustler.SvgNotNil())
	}
	if i.SvgEqualFold != nil {
		predicates = append(predicates, hustler.SvgEqualFold(*i.SvgEqualFold))
	}
	if i.SvgContainsFold != nil {
		predicates = append(predicates, hustler.SvgContainsFold(*i.SvgContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, hustler.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, hustler.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, hustler.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, hustler.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, hustler.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, hustler.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, hustler.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, hustler.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasWallet != nil {
		p := hustler.HasWallet()
		if !*i.HasWallet {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWalletWith) > 0 {
		with := make([]predicate.Wallet, 0, len(i.HasWalletWith))
		for _, w := range i.HasWalletWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasWalletWith(with...))
	}
	if i.HasWeapon != nil {
		p := hustler.HasWeapon()
		if !*i.HasWeapon {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWeaponWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasWeaponWith))
		for _, w := range i.HasWeaponWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasWeaponWith(with...))
	}
	if i.HasClothes != nil {
		p := hustler.HasClothes()
		if !*i.HasClothes {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClothesWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasClothesWith))
		for _, w := range i.HasClothesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasClothesWith(with...))
	}
	if i.HasVehicle != nil {
		p := hustler.HasVehicle()
		if !*i.HasVehicle {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVehicleWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasVehicleWith))
		for _, w := range i.HasVehicleWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasVehicleWith(with...))
	}
	if i.HasWaist != nil {
		p := hustler.HasWaist()
		if !*i.HasWaist {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWaistWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasWaistWith))
		for _, w := range i.HasWaistWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasWaistWith(with...))
	}
	if i.HasFoot != nil {
		p := hustler.HasFoot()
		if !*i.HasFoot {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFootWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasFootWith))
		for _, w := range i.HasFootWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasFootWith(with...))
	}
	if i.HasHand != nil {
		p := hustler.HasHand()
		if !*i.HasHand {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHandWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasHandWith))
		for _, w := range i.HasHandWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasHandWith(with...))
	}
	if i.HasDrug != nil {
		p := hustler.HasDrug()
		if !*i.HasDrug {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDrugWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasDrugWith))
		for _, w := range i.HasDrugWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasDrugWith(with...))
	}
	if i.HasNeck != nil {
		p := hustler.HasNeck()
		if !*i.HasNeck {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNeckWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasNeckWith))
		for _, w := range i.HasNeckWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasNeckWith(with...))
	}
	if i.HasRing != nil {
		p := hustler.HasRing()
		if !*i.HasRing {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRingWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasRingWith))
		for _, w := range i.HasRingWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasRingWith(with...))
	}
	if i.HasAccessory != nil {
		p := hustler.HasAccessory()
		if !*i.HasAccessory {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccessoryWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasAccessoryWith))
		for _, w := range i.HasAccessoryWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasAccessoryWith(with...))
	}
	if i.HasBody != nil {
		p := hustler.HasBody()
		if !*i.HasBody {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBodyWith) > 0 {
		with := make([]predicate.BodyPart, 0, len(i.HasBodyWith))
		for _, w := range i.HasBodyWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasBodyWith(with...))
	}
	if i.HasHair != nil {
		p := hustler.HasHair()
		if !*i.HasHair {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHairWith) > 0 {
		with := make([]predicate.BodyPart, 0, len(i.HasHairWith))
		for _, w := range i.HasHairWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasHairWith(with...))
	}
	if i.HasBeard != nil {
		p := hustler.HasBeard()
		if !*i.HasBeard {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBeardWith) > 0 {
		with := make([]predicate.BodyPart, 0, len(i.HasBeardWith))
		for _, w := range i.HasBeardWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasBeardWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate HustlerWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return hustler.And(predicates...), nil
	}
}

// ItemWhereInput represents a where input for filtering Item queries.
type ItemWhereInput struct {
	Not *ItemWhereInput   `json:"not,omitempty"`
	Or  []*ItemWhereInput `json:"or,omitempty"`
	And []*ItemWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type      *item.Type  `json:"type,omitempty"`
	TypeNEQ   *item.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []item.Type `json:"typeIn,omitempty"`
	TypeNotIn []item.Type `json:"typeNotIn,omitempty"`

	// "name_prefix" field predicates.
	NamePrefix             *string  `json:"namePrefix,omitempty"`
	NamePrefixNEQ          *string  `json:"namePrefixNEQ,omitempty"`
	NamePrefixIn           []string `json:"namePrefixIn,omitempty"`
	NamePrefixNotIn        []string `json:"namePrefixNotIn,omitempty"`
	NamePrefixGT           *string  `json:"namePrefixGT,omitempty"`
	NamePrefixGTE          *string  `json:"namePrefixGTE,omitempty"`
	NamePrefixLT           *string  `json:"namePrefixLT,omitempty"`
	NamePrefixLTE          *string  `json:"namePrefixLTE,omitempty"`
	NamePrefixContains     *string  `json:"namePrefixContains,omitempty"`
	NamePrefixHasPrefix    *string  `json:"namePrefixHasPrefix,omitempty"`
	NamePrefixHasSuffix    *string  `json:"namePrefixHasSuffix,omitempty"`
	NamePrefixIsNil        bool     `json:"namePrefixIsNil,omitempty"`
	NamePrefixNotNil       bool     `json:"namePrefixNotNil,omitempty"`
	NamePrefixEqualFold    *string  `json:"namePrefixEqualFold,omitempty"`
	NamePrefixContainsFold *string  `json:"namePrefixContainsFold,omitempty"`

	// "name_suffix" field predicates.
	NameSuffix             *string  `json:"nameSuffix,omitempty"`
	NameSuffixNEQ          *string  `json:"nameSuffixNEQ,omitempty"`
	NameSuffixIn           []string `json:"nameSuffixIn,omitempty"`
	NameSuffixNotIn        []string `json:"nameSuffixNotIn,omitempty"`
	NameSuffixGT           *string  `json:"nameSuffixGT,omitempty"`
	NameSuffixGTE          *string  `json:"nameSuffixGTE,omitempty"`
	NameSuffixLT           *string  `json:"nameSuffixLT,omitempty"`
	NameSuffixLTE          *string  `json:"nameSuffixLTE,omitempty"`
	NameSuffixContains     *string  `json:"nameSuffixContains,omitempty"`
	NameSuffixHasPrefix    *string  `json:"nameSuffixHasPrefix,omitempty"`
	NameSuffixHasSuffix    *string  `json:"nameSuffixHasSuffix,omitempty"`
	NameSuffixIsNil        bool     `json:"nameSuffixIsNil,omitempty"`
	NameSuffixNotNil       bool     `json:"nameSuffixNotNil,omitempty"`
	NameSuffixEqualFold    *string  `json:"nameSuffixEqualFold,omitempty"`
	NameSuffixContainsFold *string  `json:"nameSuffixContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "suffix" field predicates.
	Suffix             *string  `json:"suffix,omitempty"`
	SuffixNEQ          *string  `json:"suffixNEQ,omitempty"`
	SuffixIn           []string `json:"suffixIn,omitempty"`
	SuffixNotIn        []string `json:"suffixNotIn,omitempty"`
	SuffixGT           *string  `json:"suffixGT,omitempty"`
	SuffixGTE          *string  `json:"suffixGTE,omitempty"`
	SuffixLT           *string  `json:"suffixLT,omitempty"`
	SuffixLTE          *string  `json:"suffixLTE,omitempty"`
	SuffixContains     *string  `json:"suffixContains,omitempty"`
	SuffixHasPrefix    *string  `json:"suffixHasPrefix,omitempty"`
	SuffixHasSuffix    *string  `json:"suffixHasSuffix,omitempty"`
	SuffixIsNil        bool     `json:"suffixIsNil,omitempty"`
	SuffixNotNil       bool     `json:"suffixNotNil,omitempty"`
	SuffixEqualFold    *string  `json:"suffixEqualFold,omitempty"`
	SuffixContainsFold *string  `json:"suffixContainsFold,omitempty"`

	// "augmented" field predicates.
	Augmented       *bool `json:"augmented,omitempty"`
	AugmentedNEQ    *bool `json:"augmentedNEQ,omitempty"`
	AugmentedIsNil  bool  `json:"augmentedIsNil,omitempty"`
	AugmentedNotNil bool  `json:"augmentedNotNil,omitempty"`

	// "svg" field predicates.
	Svg             *string  `json:"svg,omitempty"`
	SvgNEQ          *string  `json:"svgNEQ,omitempty"`
	SvgIn           []string `json:"svgIn,omitempty"`
	SvgNotIn        []string `json:"svgNotIn,omitempty"`
	SvgGT           *string  `json:"svgGT,omitempty"`
	SvgGTE          *string  `json:"svgGTE,omitempty"`
	SvgLT           *string  `json:"svgLT,omitempty"`
	SvgLTE          *string  `json:"svgLTE,omitempty"`
	SvgContains     *string  `json:"svgContains,omitempty"`
	SvgHasPrefix    *string  `json:"svgHasPrefix,omitempty"`
	SvgHasSuffix    *string  `json:"svgHasSuffix,omitempty"`
	SvgIsNil        bool     `json:"svgIsNil,omitempty"`
	SvgNotNil       bool     `json:"svgNotNil,omitempty"`
	SvgEqualFold    *string  `json:"svgEqualFold,omitempty"`
	SvgContainsFold *string  `json:"svgContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "wallets" edge predicates.
	HasWallets     *bool                    `json:"hasWallets,omitempty"`
	HasWalletsWith []*WalletItemsWhereInput `json:"hasWalletsWith,omitempty"`

	// "dopes" edge predicates.
	HasDopes     *bool             `json:"hasDopes,omitempty"`
	HasDopesWith []*DopeWhereInput `json:"hasDopesWith,omitempty"`

	// "hustler_weapons" edge predicates.
	HasHustlerWeapons     *bool                `json:"hasHustlerWeapons,omitempty"`
	HasHustlerWeaponsWith []*HustlerWhereInput `json:"hasHustlerWeaponsWith,omitempty"`

	// "hustler_clothes" edge predicates.
	HasHustlerClothes     *bool                `json:"hasHustlerClothes,omitempty"`
	HasHustlerClothesWith []*HustlerWhereInput `json:"hasHustlerClothesWith,omitempty"`

	// "hustler_vehicles" edge predicates.
	HasHustlerVehicles     *bool                `json:"hasHustlerVehicles,omitempty"`
	HasHustlerVehiclesWith []*HustlerWhereInput `json:"hasHustlerVehiclesWith,omitempty"`

	// "hustler_waists" edge predicates.
	HasHustlerWaists     *bool                `json:"hasHustlerWaists,omitempty"`
	HasHustlerWaistsWith []*HustlerWhereInput `json:"hasHustlerWaistsWith,omitempty"`

	// "hustler_feet" edge predicates.
	HasHustlerFeet     *bool                `json:"hasHustlerFeet,omitempty"`
	HasHustlerFeetWith []*HustlerWhereInput `json:"hasHustlerFeetWith,omitempty"`

	// "hustler_hands" edge predicates.
	HasHustlerHands     *bool                `json:"hasHustlerHands,omitempty"`
	HasHustlerHandsWith []*HustlerWhereInput `json:"hasHustlerHandsWith,omitempty"`

	// "hustler_drugs" edge predicates.
	HasHustlerDrugs     *bool                `json:"hasHustlerDrugs,omitempty"`
	HasHustlerDrugsWith []*HustlerWhereInput `json:"hasHustlerDrugsWith,omitempty"`

	// "hustler_necks" edge predicates.
	HasHustlerNecks     *bool                `json:"hasHustlerNecks,omitempty"`
	HasHustlerNecksWith []*HustlerWhereInput `json:"hasHustlerNecksWith,omitempty"`

	// "hustler_rings" edge predicates.
	HasHustlerRings     *bool                `json:"hasHustlerRings,omitempty"`
	HasHustlerRingsWith []*HustlerWhereInput `json:"hasHustlerRingsWith,omitempty"`

	// "hustler_accessories" edge predicates.
	HasHustlerAccessories     *bool                `json:"hasHustlerAccessories,omitempty"`
	HasHustlerAccessoriesWith []*HustlerWhereInput `json:"hasHustlerAccessoriesWith,omitempty"`

	// "base" edge predicates.
	HasBase     *bool             `json:"hasBase,omitempty"`
	HasBaseWith []*ItemWhereInput `json:"hasBaseWith,omitempty"`

	// "derivative" edge predicates.
	HasDerivative     *bool             `json:"hasDerivative,omitempty"`
	HasDerivativeWith []*ItemWhereInput `json:"hasDerivativeWith,omitempty"`
}

// Filter applies the ItemWhereInput filter on the ItemQuery builder.
func (i *ItemWhereInput) Filter(q *ItemQuery) (*ItemQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering items.
// An error is returned if the input is empty or invalid.
func (i *ItemWhereInput) P() (predicate.Item, error) {
	var predicates []predicate.Item
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, item.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Item, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, item.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Item, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, item.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, item.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, item.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, item.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, item.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, item.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, item.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, item.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, item.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, item.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, item.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, item.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, item.TypeNotIn(i.TypeNotIn...))
	}
	if i.NamePrefix != nil {
		predicates = append(predicates, item.NamePrefixEQ(*i.NamePrefix))
	}
	if i.NamePrefixNEQ != nil {
		predicates = append(predicates, item.NamePrefixNEQ(*i.NamePrefixNEQ))
	}
	if len(i.NamePrefixIn) > 0 {
		predicates = append(predicates, item.NamePrefixIn(i.NamePrefixIn...))
	}
	if len(i.NamePrefixNotIn) > 0 {
		predicates = append(predicates, item.NamePrefixNotIn(i.NamePrefixNotIn...))
	}
	if i.NamePrefixGT != nil {
		predicates = append(predicates, item.NamePrefixGT(*i.NamePrefixGT))
	}
	if i.NamePrefixGTE != nil {
		predicates = append(predicates, item.NamePrefixGTE(*i.NamePrefixGTE))
	}
	if i.NamePrefixLT != nil {
		predicates = append(predicates, item.NamePrefixLT(*i.NamePrefixLT))
	}
	if i.NamePrefixLTE != nil {
		predicates = append(predicates, item.NamePrefixLTE(*i.NamePrefixLTE))
	}
	if i.NamePrefixContains != nil {
		predicates = append(predicates, item.NamePrefixContains(*i.NamePrefixContains))
	}
	if i.NamePrefixHasPrefix != nil {
		predicates = append(predicates, item.NamePrefixHasPrefix(*i.NamePrefixHasPrefix))
	}
	if i.NamePrefixHasSuffix != nil {
		predicates = append(predicates, item.NamePrefixHasSuffix(*i.NamePrefixHasSuffix))
	}
	if i.NamePrefixIsNil {
		predicates = append(predicates, item.NamePrefixIsNil())
	}
	if i.NamePrefixNotNil {
		predicates = append(predicates, item.NamePrefixNotNil())
	}
	if i.NamePrefixEqualFold != nil {
		predicates = append(predicates, item.NamePrefixEqualFold(*i.NamePrefixEqualFold))
	}
	if i.NamePrefixContainsFold != nil {
		predicates = append(predicates, item.NamePrefixContainsFold(*i.NamePrefixContainsFold))
	}
	if i.NameSuffix != nil {
		predicates = append(predicates, item.NameSuffixEQ(*i.NameSuffix))
	}
	if i.NameSuffixNEQ != nil {
		predicates = append(predicates, item.NameSuffixNEQ(*i.NameSuffixNEQ))
	}
	if len(i.NameSuffixIn) > 0 {
		predicates = append(predicates, item.NameSuffixIn(i.NameSuffixIn...))
	}
	if len(i.NameSuffixNotIn) > 0 {
		predicates = append(predicates, item.NameSuffixNotIn(i.NameSuffixNotIn...))
	}
	if i.NameSuffixGT != nil {
		predicates = append(predicates, item.NameSuffixGT(*i.NameSuffixGT))
	}
	if i.NameSuffixGTE != nil {
		predicates = append(predicates, item.NameSuffixGTE(*i.NameSuffixGTE))
	}
	if i.NameSuffixLT != nil {
		predicates = append(predicates, item.NameSuffixLT(*i.NameSuffixLT))
	}
	if i.NameSuffixLTE != nil {
		predicates = append(predicates, item.NameSuffixLTE(*i.NameSuffixLTE))
	}
	if i.NameSuffixContains != nil {
		predicates = append(predicates, item.NameSuffixContains(*i.NameSuffixContains))
	}
	if i.NameSuffixHasPrefix != nil {
		predicates = append(predicates, item.NameSuffixHasPrefix(*i.NameSuffixHasPrefix))
	}
	if i.NameSuffixHasSuffix != nil {
		predicates = append(predicates, item.NameSuffixHasSuffix(*i.NameSuffixHasSuffix))
	}
	if i.NameSuffixIsNil {
		predicates = append(predicates, item.NameSuffixIsNil())
	}
	if i.NameSuffixNotNil {
		predicates = append(predicates, item.NameSuffixNotNil())
	}
	if i.NameSuffixEqualFold != nil {
		predicates = append(predicates, item.NameSuffixEqualFold(*i.NameSuffixEqualFold))
	}
	if i.NameSuffixContainsFold != nil {
		predicates = append(predicates, item.NameSuffixContainsFold(*i.NameSuffixContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, item.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, item.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, item.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, item.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, item.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, item.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, item.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, item.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, item.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, item.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, item.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, item.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, item.NameContainsFold(*i.NameContainsFold))
	}
	if i.Suffix != nil {
		predicates = append(predicates, item.SuffixEQ(*i.Suffix))
	}
	if i.SuffixNEQ != nil {
		predicates = append(predicates, item.SuffixNEQ(*i.SuffixNEQ))
	}
	if len(i.SuffixIn) > 0 {
		predicates = append(predicates, item.SuffixIn(i.SuffixIn...))
	}
	if len(i.SuffixNotIn) > 0 {
		predicates = append(predicates, item.SuffixNotIn(i.SuffixNotIn...))
	}
	if i.SuffixGT != nil {
		predicates = append(predicates, item.SuffixGT(*i.SuffixGT))
	}
	if i.SuffixGTE != nil {
		predicates = append(predicates, item.SuffixGTE(*i.SuffixGTE))
	}
	if i.SuffixLT != nil {
		predicates = append(predicates, item.SuffixLT(*i.SuffixLT))
	}
	if i.SuffixLTE != nil {
		predicates = append(predicates, item.SuffixLTE(*i.SuffixLTE))
	}
	if i.SuffixContains != nil {
		predicates = append(predicates, item.SuffixContains(*i.SuffixContains))
	}
	if i.SuffixHasPrefix != nil {
		predicates = append(predicates, item.SuffixHasPrefix(*i.SuffixHasPrefix))
	}
	if i.SuffixHasSuffix != nil {
		predicates = append(predicates, item.SuffixHasSuffix(*i.SuffixHasSuffix))
	}
	if i.SuffixIsNil {
		predicates = append(predicates, item.SuffixIsNil())
	}
	if i.SuffixNotNil {
		predicates = append(predicates, item.SuffixNotNil())
	}
	if i.SuffixEqualFold != nil {
		predicates = append(predicates, item.SuffixEqualFold(*i.SuffixEqualFold))
	}
	if i.SuffixContainsFold != nil {
		predicates = append(predicates, item.SuffixContainsFold(*i.SuffixContainsFold))
	}
	if i.Augmented != nil {
		predicates = append(predicates, item.AugmentedEQ(*i.Augmented))
	}
	if i.AugmentedNEQ != nil {
		predicates = append(predicates, item.AugmentedNEQ(*i.AugmentedNEQ))
	}
	if i.AugmentedIsNil {
		predicates = append(predicates, item.AugmentedIsNil())
	}
	if i.AugmentedNotNil {
		predicates = append(predicates, item.AugmentedNotNil())
	}
	if i.Svg != nil {
		predicates = append(predicates, item.SvgEQ(*i.Svg))
	}
	if i.SvgNEQ != nil {
		predicates = append(predicates, item.SvgNEQ(*i.SvgNEQ))
	}
	if len(i.SvgIn) > 0 {
		predicates = append(predicates, item.SvgIn(i.SvgIn...))
	}
	if len(i.SvgNotIn) > 0 {
		predicates = append(predicates, item.SvgNotIn(i.SvgNotIn...))
	}
	if i.SvgGT != nil {
		predicates = append(predicates, item.SvgGT(*i.SvgGT))
	}
	if i.SvgGTE != nil {
		predicates = append(predicates, item.SvgGTE(*i.SvgGTE))
	}
	if i.SvgLT != nil {
		predicates = append(predicates, item.SvgLT(*i.SvgLT))
	}
	if i.SvgLTE != nil {
		predicates = append(predicates, item.SvgLTE(*i.SvgLTE))
	}
	if i.SvgContains != nil {
		predicates = append(predicates, item.SvgContains(*i.SvgContains))
	}
	if i.SvgHasPrefix != nil {
		predicates = append(predicates, item.SvgHasPrefix(*i.SvgHasPrefix))
	}
	if i.SvgHasSuffix != nil {
		predicates = append(predicates, item.SvgHasSuffix(*i.SvgHasSuffix))
	}
	if i.SvgIsNil {
		predicates = append(predicates, item.SvgIsNil())
	}
	if i.SvgNotNil {
		predicates = append(predicates, item.SvgNotNil())
	}
	if i.SvgEqualFold != nil {
		predicates = append(predicates, item.SvgEqualFold(*i.SvgEqualFold))
	}
	if i.SvgContainsFold != nil {
		predicates = append(predicates, item.SvgContainsFold(*i.SvgContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, item.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, item.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, item.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, item.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, item.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, item.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, item.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, item.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasWallets != nil {
		p := item.HasWallets()
		if !*i.HasWallets {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWalletsWith) > 0 {
		with := make([]predicate.WalletItems, 0, len(i.HasWalletsWith))
		for _, w := range i.HasWalletsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasWalletsWith(with...))
	}
	if i.HasDopes != nil {
		p := item.HasDopes()
		if !*i.HasDopes {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDopesWith) > 0 {
		with := make([]predicate.Dope, 0, len(i.HasDopesWith))
		for _, w := range i.HasDopesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasDopesWith(with...))
	}
	if i.HasHustlerWeapons != nil {
		p := item.HasHustlerWeapons()
		if !*i.HasHustlerWeapons {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerWeaponsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerWeaponsWith))
		for _, w := range i.HasHustlerWeaponsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerWeaponsWith(with...))
	}
	if i.HasHustlerClothes != nil {
		p := item.HasHustlerClothes()
		if !*i.HasHustlerClothes {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerClothesWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerClothesWith))
		for _, w := range i.HasHustlerClothesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerClothesWith(with...))
	}
	if i.HasHustlerVehicles != nil {
		p := item.HasHustlerVehicles()
		if !*i.HasHustlerVehicles {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerVehiclesWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerVehiclesWith))
		for _, w := range i.HasHustlerVehiclesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerVehiclesWith(with...))
	}
	if i.HasHustlerWaists != nil {
		p := item.HasHustlerWaists()
		if !*i.HasHustlerWaists {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerWaistsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerWaistsWith))
		for _, w := range i.HasHustlerWaistsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerWaistsWith(with...))
	}
	if i.HasHustlerFeet != nil {
		p := item.HasHustlerFeet()
		if !*i.HasHustlerFeet {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerFeetWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerFeetWith))
		for _, w := range i.HasHustlerFeetWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerFeetWith(with...))
	}
	if i.HasHustlerHands != nil {
		p := item.HasHustlerHands()
		if !*i.HasHustlerHands {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerHandsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerHandsWith))
		for _, w := range i.HasHustlerHandsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerHandsWith(with...))
	}
	if i.HasHustlerDrugs != nil {
		p := item.HasHustlerDrugs()
		if !*i.HasHustlerDrugs {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerDrugsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerDrugsWith))
		for _, w := range i.HasHustlerDrugsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerDrugsWith(with...))
	}
	if i.HasHustlerNecks != nil {
		p := item.HasHustlerNecks()
		if !*i.HasHustlerNecks {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerNecksWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerNecksWith))
		for _, w := range i.HasHustlerNecksWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerNecksWith(with...))
	}
	if i.HasHustlerRings != nil {
		p := item.HasHustlerRings()
		if !*i.HasHustlerRings {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerRingsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerRingsWith))
		for _, w := range i.HasHustlerRingsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerRingsWith(with...))
	}
	if i.HasHustlerAccessories != nil {
		p := item.HasHustlerAccessories()
		if !*i.HasHustlerAccessories {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerAccessoriesWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerAccessoriesWith))
		for _, w := range i.HasHustlerAccessoriesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerAccessoriesWith(with...))
	}
	if i.HasBase != nil {
		p := item.HasBase()
		if !*i.HasBase {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBaseWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasBaseWith))
		for _, w := range i.HasBaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasBaseWith(with...))
	}
	if i.HasDerivative != nil {
		p := item.HasDerivative()
		if !*i.HasDerivative {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDerivativeWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasDerivativeWith))
		for _, w := range i.HasDerivativeWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasDerivativeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate ItemWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return item.And(predicates...), nil
	}
}

// SyncStateWhereInput represents a where input for filtering SyncState queries.
type SyncStateWhereInput struct {
	Not *SyncStateWhereInput   `json:"not,omitempty"`
	Or  []*SyncStateWhereInput `json:"or,omitempty"`
	And []*SyncStateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "start_block" field predicates.
	StartBlock      *uint64  `json:"startBlock,omitempty"`
	StartBlockNEQ   *uint64  `json:"startBlockNEQ,omitempty"`
	StartBlockIn    []uint64 `json:"startBlockIn,omitempty"`
	StartBlockNotIn []uint64 `json:"startBlockNotIn,omitempty"`
	StartBlockGT    *uint64  `json:"startBlockGT,omitempty"`
	StartBlockGTE   *uint64  `json:"startBlockGTE,omitempty"`
	StartBlockLT    *uint64  `json:"startBlockLT,omitempty"`
	StartBlockLTE   *uint64  `json:"startBlockLTE,omitempty"`
}

// Filter applies the SyncStateWhereInput filter on the SyncStateQuery builder.
func (i *SyncStateWhereInput) Filter(q *SyncStateQuery) (*SyncStateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering syncstates.
// An error is returned if the input is empty or invalid.
func (i *SyncStateWhereInput) P() (predicate.SyncState, error) {
	var predicates []predicate.SyncState
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, syncstate.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SyncState, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, syncstate.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SyncState, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, syncstate.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, syncstate.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, syncstate.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, syncstate.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, syncstate.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, syncstate.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, syncstate.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, syncstate.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, syncstate.IDLTE(*i.IDLTE))
	}
	if i.StartBlock != nil {
		predicates = append(predicates, syncstate.StartBlockEQ(*i.StartBlock))
	}
	if i.StartBlockNEQ != nil {
		predicates = append(predicates, syncstate.StartBlockNEQ(*i.StartBlockNEQ))
	}
	if len(i.StartBlockIn) > 0 {
		predicates = append(predicates, syncstate.StartBlockIn(i.StartBlockIn...))
	}
	if len(i.StartBlockNotIn) > 0 {
		predicates = append(predicates, syncstate.StartBlockNotIn(i.StartBlockNotIn...))
	}
	if i.StartBlockGT != nil {
		predicates = append(predicates, syncstate.StartBlockGT(*i.StartBlockGT))
	}
	if i.StartBlockGTE != nil {
		predicates = append(predicates, syncstate.StartBlockGTE(*i.StartBlockGTE))
	}
	if i.StartBlockLT != nil {
		predicates = append(predicates, syncstate.StartBlockLT(*i.StartBlockLT))
	}
	if i.StartBlockLTE != nil {
		predicates = append(predicates, syncstate.StartBlockLTE(*i.StartBlockLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate SyncStateWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return syncstate.And(predicates...), nil
	}
}

// WalletWhereInput represents a where input for filtering Wallet queries.
type WalletWhereInput struct {
	Not *WalletWhereInput   `json:"not,omitempty"`
	Or  []*WalletWhereInput `json:"or,omitempty"`
	And []*WalletWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "paper" field predicates.
	Paper      *schema.BigInt  `json:"paper,omitempty"`
	PaperNEQ   *schema.BigInt  `json:"paperNEQ,omitempty"`
	PaperIn    []schema.BigInt `json:"paperIn,omitempty"`
	PaperNotIn []schema.BigInt `json:"paperNotIn,omitempty"`
	PaperGT    *schema.BigInt  `json:"paperGT,omitempty"`
	PaperGTE   *schema.BigInt  `json:"paperGTE,omitempty"`
	PaperLT    *schema.BigInt  `json:"paperLT,omitempty"`
	PaperLTE   *schema.BigInt  `json:"paperLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "dopes" edge predicates.
	HasDopes     *bool             `json:"hasDopes,omitempty"`
	HasDopesWith []*DopeWhereInput `json:"hasDopesWith,omitempty"`

	// "items" edge predicates.
	HasItems     *bool                    `json:"hasItems,omitempty"`
	HasItemsWith []*WalletItemsWhereInput `json:"hasItemsWith,omitempty"`

	// "hustlers" edge predicates.
	HasHustlers     *bool                `json:"hasHustlers,omitempty"`
	HasHustlersWith []*HustlerWhereInput `json:"hasHustlersWith,omitempty"`
}

// Filter applies the WalletWhereInput filter on the WalletQuery builder.
func (i *WalletWhereInput) Filter(q *WalletQuery) (*WalletQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering wallets.
// An error is returned if the input is empty or invalid.
func (i *WalletWhereInput) P() (predicate.Wallet, error) {
	var predicates []predicate.Wallet
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, wallet.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Wallet, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, wallet.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Wallet, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, wallet.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, wallet.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, wallet.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, wallet.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, wallet.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, wallet.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, wallet.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, wallet.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, wallet.IDLTE(*i.IDLTE))
	}
	if i.Paper != nil {
		predicates = append(predicates, wallet.PaperEQ(*i.Paper))
	}
	if i.PaperNEQ != nil {
		predicates = append(predicates, wallet.PaperNEQ(*i.PaperNEQ))
	}
	if len(i.PaperIn) > 0 {
		predicates = append(predicates, wallet.PaperIn(i.PaperIn...))
	}
	if len(i.PaperNotIn) > 0 {
		predicates = append(predicates, wallet.PaperNotIn(i.PaperNotIn...))
	}
	if i.PaperGT != nil {
		predicates = append(predicates, wallet.PaperGT(*i.PaperGT))
	}
	if i.PaperGTE != nil {
		predicates = append(predicates, wallet.PaperGTE(*i.PaperGTE))
	}
	if i.PaperLT != nil {
		predicates = append(predicates, wallet.PaperLT(*i.PaperLT))
	}
	if i.PaperLTE != nil {
		predicates = append(predicates, wallet.PaperLTE(*i.PaperLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, wallet.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, wallet.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, wallet.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, wallet.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, wallet.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, wallet.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, wallet.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, wallet.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasDopes != nil {
		p := wallet.HasDopes()
		if !*i.HasDopes {
			p = wallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDopesWith) > 0 {
		with := make([]predicate.Dope, 0, len(i.HasDopesWith))
		for _, w := range i.HasDopesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, wallet.HasDopesWith(with...))
	}
	if i.HasItems != nil {
		p := wallet.HasItems()
		if !*i.HasItems {
			p = wallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemsWith) > 0 {
		with := make([]predicate.WalletItems, 0, len(i.HasItemsWith))
		for _, w := range i.HasItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, wallet.HasItemsWith(with...))
	}
	if i.HasHustlers != nil {
		p := wallet.HasHustlers()
		if !*i.HasHustlers {
			p = wallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlersWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlersWith))
		for _, w := range i.HasHustlersWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, wallet.HasHustlersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate WalletWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return wallet.And(predicates...), nil
	}
}

// WalletItemsWhereInput represents a where input for filtering WalletItems queries.
type WalletItemsWhereInput struct {
	Not *WalletItemsWhereInput   `json:"not,omitempty"`
	Or  []*WalletItemsWhereInput `json:"or,omitempty"`
	And []*WalletItemsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "balance" field predicates.
	Balance      *schema.BigInt  `json:"balance,omitempty"`
	BalanceNEQ   *schema.BigInt  `json:"balanceNEQ,omitempty"`
	BalanceIn    []schema.BigInt `json:"balanceIn,omitempty"`
	BalanceNotIn []schema.BigInt `json:"balanceNotIn,omitempty"`
	BalanceGT    *schema.BigInt  `json:"balanceGT,omitempty"`
	BalanceGTE   *schema.BigInt  `json:"balanceGTE,omitempty"`
	BalanceLT    *schema.BigInt  `json:"balanceLT,omitempty"`
	BalanceLTE   *schema.BigInt  `json:"balanceLTE,omitempty"`

	// "wallet" edge predicates.
	HasWallet     *bool               `json:"hasWallet,omitempty"`
	HasWalletWith []*WalletWhereInput `json:"hasWalletWith,omitempty"`

	// "item" edge predicates.
	HasItem     *bool             `json:"hasItem,omitempty"`
	HasItemWith []*ItemWhereInput `json:"hasItemWith,omitempty"`
}

// Filter applies the WalletItemsWhereInput filter on the WalletItemsQuery builder.
func (i *WalletItemsWhereInput) Filter(q *WalletItemsQuery) (*WalletItemsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering walletitemsslice.
// An error is returned if the input is empty or invalid.
func (i *WalletItemsWhereInput) P() (predicate.WalletItems, error) {
	var predicates []predicate.WalletItems
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, walletitems.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.WalletItems, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, walletitems.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.WalletItems, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, walletitems.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, walletitems.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, walletitems.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, walletitems.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, walletitems.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, walletitems.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, walletitems.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, walletitems.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, walletitems.IDLTE(*i.IDLTE))
	}
	if i.Balance != nil {
		predicates = append(predicates, walletitems.BalanceEQ(*i.Balance))
	}
	if i.BalanceNEQ != nil {
		predicates = append(predicates, walletitems.BalanceNEQ(*i.BalanceNEQ))
	}
	if len(i.BalanceIn) > 0 {
		predicates = append(predicates, walletitems.BalanceIn(i.BalanceIn...))
	}
	if len(i.BalanceNotIn) > 0 {
		predicates = append(predicates, walletitems.BalanceNotIn(i.BalanceNotIn...))
	}
	if i.BalanceGT != nil {
		predicates = append(predicates, walletitems.BalanceGT(*i.BalanceGT))
	}
	if i.BalanceGTE != nil {
		predicates = append(predicates, walletitems.BalanceGTE(*i.BalanceGTE))
	}
	if i.BalanceLT != nil {
		predicates = append(predicates, walletitems.BalanceLT(*i.BalanceLT))
	}
	if i.BalanceLTE != nil {
		predicates = append(predicates, walletitems.BalanceLTE(*i.BalanceLTE))
	}

	if i.HasWallet != nil {
		p := walletitems.HasWallet()
		if !*i.HasWallet {
			p = walletitems.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWalletWith) > 0 {
		with := make([]predicate.Wallet, 0, len(i.HasWalletWith))
		for _, w := range i.HasWalletWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, walletitems.HasWalletWith(with...))
	}
	if i.HasItem != nil {
		p := walletitems.HasItem()
		if !*i.HasItem {
			p = walletitems.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasItemWith))
		for _, w := range i.HasItemWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, walletitems.HasItemWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/dopedao/dope-monorepo/packages/api/ent: empty predicate WalletItemsWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return walletitems.And(predicates...), nil
	}
}
