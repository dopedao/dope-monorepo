// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/dopedao/dope-monorepo/packages/api/ent/bodypart"
	"github.com/dopedao/dope-monorepo/packages/api/ent/dope"
	"github.com/dopedao/dope-monorepo/packages/api/ent/hustler"
	"github.com/dopedao/dope-monorepo/packages/api/ent/item"
	"github.com/dopedao/dope-monorepo/packages/api/ent/predicate"
	"github.com/dopedao/dope-monorepo/packages/api/ent/schema"
	"github.com/dopedao/dope-monorepo/packages/api/ent/syncstate"
	"github.com/dopedao/dope-monorepo/packages/api/ent/wallet"
	"github.com/dopedao/dope-monorepo/packages/api/ent/walletitems"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBodyPart    = "BodyPart"
	TypeDope        = "Dope"
	TypeHustler     = "Hustler"
	TypeItem        = "Item"
	TypeSyncState   = "SyncState"
	TypeWallet      = "Wallet"
	TypeWalletItems = "WalletItems"
)

// BodyPartMutation represents an operation that mutates the BodyPart nodes in the graph.
type BodyPartMutation struct {
	config
	op             Op
	typ            string
	id             *string
	_type          *bodypart.Type
	sex            *bodypart.Sex
	rle            *string
	clearedFields  map[string]struct{}
	hustler        *string
	clearedhustler bool
	done           bool
	oldValue       func(context.Context) (*BodyPart, error)
	predicates     []predicate.BodyPart
}

var _ ent.Mutation = (*BodyPartMutation)(nil)

// bodypartOption allows management of the mutation configuration using functional options.
type bodypartOption func(*BodyPartMutation)

// newBodyPartMutation creates new mutation for the BodyPart entity.
func newBodyPartMutation(c config, op Op, opts ...bodypartOption) *BodyPartMutation {
	m := &BodyPartMutation{
		config:        c,
		op:            op,
		typ:           TypeBodyPart,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBodyPartID sets the ID field of the mutation.
func withBodyPartID(id string) bodypartOption {
	return func(m *BodyPartMutation) {
		var (
			err   error
			once  sync.Once
			value *BodyPart
		)
		m.oldValue = func(ctx context.Context) (*BodyPart, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BodyPart.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBodyPart sets the old BodyPart of the mutation.
func withBodyPart(node *BodyPart) bodypartOption {
	return func(m *BodyPartMutation) {
		m.oldValue = func(context.Context) (*BodyPart, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BodyPartMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BodyPartMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BodyPart entities.
func (m *BodyPartMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BodyPartMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BodyPartMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BodyPart.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *BodyPartMutation) SetType(b bodypart.Type) {
	m._type = &b
}

// GetType returns the value of the "type" field in the mutation.
func (m *BodyPartMutation) GetType() (r bodypart.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BodyPart entity.
// If the BodyPart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BodyPartMutation) OldType(ctx context.Context) (v bodypart.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BodyPartMutation) ResetType() {
	m._type = nil
}

// SetSex sets the "sex" field.
func (m *BodyPartMutation) SetSex(b bodypart.Sex) {
	m.sex = &b
}

// Sex returns the value of the "sex" field in the mutation.
func (m *BodyPartMutation) Sex() (r bodypart.Sex, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the BodyPart entity.
// If the BodyPart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BodyPartMutation) OldSex(ctx context.Context) (v bodypart.Sex, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// ResetSex resets all changes to the "sex" field.
func (m *BodyPartMutation) ResetSex() {
	m.sex = nil
}

// SetRle sets the "rle" field.
func (m *BodyPartMutation) SetRle(s string) {
	m.rle = &s
}

// Rle returns the value of the "rle" field in the mutation.
func (m *BodyPartMutation) Rle() (r string, exists bool) {
	v := m.rle
	if v == nil {
		return
	}
	return *v, true
}

// OldRle returns the old "rle" field's value of the BodyPart entity.
// If the BodyPart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BodyPartMutation) OldRle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRle: %w", err)
	}
	return oldValue.Rle, nil
}

// ResetRle resets all changes to the "rle" field.
func (m *BodyPartMutation) ResetRle() {
	m.rle = nil
}

// SetHustlerID sets the "hustler" edge to the Hustler entity by id.
func (m *BodyPartMutation) SetHustlerID(id string) {
	m.hustler = &id
}

// ClearHustler clears the "hustler" edge to the Hustler entity.
func (m *BodyPartMutation) ClearHustler() {
	m.clearedhustler = true
}

// HustlerCleared reports if the "hustler" edge to the Hustler entity was cleared.
func (m *BodyPartMutation) HustlerCleared() bool {
	return m.clearedhustler
}

// HustlerID returns the "hustler" edge ID in the mutation.
func (m *BodyPartMutation) HustlerID() (id string, exists bool) {
	if m.hustler != nil {
		return *m.hustler, true
	}
	return
}

// HustlerIDs returns the "hustler" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HustlerID instead. It exists only for internal usage by the builders.
func (m *BodyPartMutation) HustlerIDs() (ids []string) {
	if id := m.hustler; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHustler resets all changes to the "hustler" edge.
func (m *BodyPartMutation) ResetHustler() {
	m.hustler = nil
	m.clearedhustler = false
}

// Where appends a list predicates to the BodyPartMutation builder.
func (m *BodyPartMutation) Where(ps ...predicate.BodyPart) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BodyPartMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BodyPart).
func (m *BodyPartMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BodyPartMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._type != nil {
		fields = append(fields, bodypart.FieldType)
	}
	if m.sex != nil {
		fields = append(fields, bodypart.FieldSex)
	}
	if m.rle != nil {
		fields = append(fields, bodypart.FieldRle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BodyPartMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bodypart.FieldType:
		return m.GetType()
	case bodypart.FieldSex:
		return m.Sex()
	case bodypart.FieldRle:
		return m.Rle()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BodyPartMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bodypart.FieldType:
		return m.OldType(ctx)
	case bodypart.FieldSex:
		return m.OldSex(ctx)
	case bodypart.FieldRle:
		return m.OldRle(ctx)
	}
	return nil, fmt.Errorf("unknown BodyPart field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BodyPartMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bodypart.FieldType:
		v, ok := value.(bodypart.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case bodypart.FieldSex:
		v, ok := value.(bodypart.Sex)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case bodypart.FieldRle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRle(v)
		return nil
	}
	return fmt.Errorf("unknown BodyPart field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BodyPartMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BodyPartMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BodyPartMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BodyPart numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BodyPartMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BodyPartMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BodyPartMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BodyPart nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BodyPartMutation) ResetField(name string) error {
	switch name {
	case bodypart.FieldType:
		m.ResetType()
		return nil
	case bodypart.FieldSex:
		m.ResetSex()
		return nil
	case bodypart.FieldRle:
		m.ResetRle()
		return nil
	}
	return fmt.Errorf("unknown BodyPart field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BodyPartMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hustler != nil {
		edges = append(edges, bodypart.EdgeHustler)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BodyPartMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bodypart.EdgeHustler:
		if id := m.hustler; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BodyPartMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BodyPartMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BodyPartMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhustler {
		edges = append(edges, bodypart.EdgeHustler)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BodyPartMutation) EdgeCleared(name string) bool {
	switch name {
	case bodypart.EdgeHustler:
		return m.clearedhustler
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BodyPartMutation) ClearEdge(name string) error {
	switch name {
	case bodypart.EdgeHustler:
		m.ClearHustler()
		return nil
	}
	return fmt.Errorf("unknown BodyPart unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BodyPartMutation) ResetEdge(name string) error {
	switch name {
	case bodypart.EdgeHustler:
		m.ResetHustler()
		return nil
	}
	return fmt.Errorf("unknown BodyPart edge %s", name)
}

// DopeMutation represents an operation that mutates the Dope nodes in the graph.
type DopeMutation struct {
	config
	op            Op
	typ           string
	id            *string
	claimed       *bool
	opened        *bool
	clearedFields map[string]struct{}
	wallet        *string
	clearedwallet bool
	items         map[string]struct{}
	removeditems  map[string]struct{}
	cleareditems  bool
	done          bool
	oldValue      func(context.Context) (*Dope, error)
	predicates    []predicate.Dope
}

var _ ent.Mutation = (*DopeMutation)(nil)

// dopeOption allows management of the mutation configuration using functional options.
type dopeOption func(*DopeMutation)

// newDopeMutation creates new mutation for the Dope entity.
func newDopeMutation(c config, op Op, opts ...dopeOption) *DopeMutation {
	m := &DopeMutation{
		config:        c,
		op:            op,
		typ:           TypeDope,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDopeID sets the ID field of the mutation.
func withDopeID(id string) dopeOption {
	return func(m *DopeMutation) {
		var (
			err   error
			once  sync.Once
			value *Dope
		)
		m.oldValue = func(ctx context.Context) (*Dope, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dope.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDope sets the old Dope of the mutation.
func withDope(node *Dope) dopeOption {
	return func(m *DopeMutation) {
		m.oldValue = func(context.Context) (*Dope, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DopeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DopeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dope entities.
func (m *DopeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DopeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DopeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dope.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClaimed sets the "claimed" field.
func (m *DopeMutation) SetClaimed(b bool) {
	m.claimed = &b
}

// Claimed returns the value of the "claimed" field in the mutation.
func (m *DopeMutation) Claimed() (r bool, exists bool) {
	v := m.claimed
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimed returns the old "claimed" field's value of the Dope entity.
// If the Dope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DopeMutation) OldClaimed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimed: %w", err)
	}
	return oldValue.Claimed, nil
}

// ResetClaimed resets all changes to the "claimed" field.
func (m *DopeMutation) ResetClaimed() {
	m.claimed = nil
}

// SetOpened sets the "opened" field.
func (m *DopeMutation) SetOpened(b bool) {
	m.opened = &b
}

// Opened returns the value of the "opened" field in the mutation.
func (m *DopeMutation) Opened() (r bool, exists bool) {
	v := m.opened
	if v == nil {
		return
	}
	return *v, true
}

// OldOpened returns the old "opened" field's value of the Dope entity.
// If the Dope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DopeMutation) OldOpened(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpened is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpened requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpened: %w", err)
	}
	return oldValue.Opened, nil
}

// ResetOpened resets all changes to the "opened" field.
func (m *DopeMutation) ResetOpened() {
	m.opened = nil
}

// SetWalletID sets the "wallet" edge to the Wallet entity by id.
func (m *DopeMutation) SetWalletID(id string) {
	m.wallet = &id
}

// ClearWallet clears the "wallet" edge to the Wallet entity.
func (m *DopeMutation) ClearWallet() {
	m.clearedwallet = true
}

// WalletCleared reports if the "wallet" edge to the Wallet entity was cleared.
func (m *DopeMutation) WalletCleared() bool {
	return m.clearedwallet
}

// WalletID returns the "wallet" edge ID in the mutation.
func (m *DopeMutation) WalletID() (id string, exists bool) {
	if m.wallet != nil {
		return *m.wallet, true
	}
	return
}

// WalletIDs returns the "wallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WalletID instead. It exists only for internal usage by the builders.
func (m *DopeMutation) WalletIDs() (ids []string) {
	if id := m.wallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWallet resets all changes to the "wallet" edge.
func (m *DopeMutation) ResetWallet() {
	m.wallet = nil
	m.clearedwallet = false
}

// AddItemIDs adds the "items" edge to the Item entity by ids.
func (m *DopeMutation) AddItemIDs(ids ...string) {
	if m.items == nil {
		m.items = make(map[string]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the Item entity.
func (m *DopeMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the Item entity was cleared.
func (m *DopeMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the Item entity by IDs.
func (m *DopeMutation) RemoveItemIDs(ids ...string) {
	if m.removeditems == nil {
		m.removeditems = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the Item entity.
func (m *DopeMutation) RemovedItemsIDs() (ids []string) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *DopeMutation) ItemsIDs() (ids []string) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *DopeMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// Where appends a list predicates to the DopeMutation builder.
func (m *DopeMutation) Where(ps ...predicate.Dope) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DopeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Dope).
func (m *DopeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DopeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.claimed != nil {
		fields = append(fields, dope.FieldClaimed)
	}
	if m.opened != nil {
		fields = append(fields, dope.FieldOpened)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DopeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dope.FieldClaimed:
		return m.Claimed()
	case dope.FieldOpened:
		return m.Opened()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DopeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dope.FieldClaimed:
		return m.OldClaimed(ctx)
	case dope.FieldOpened:
		return m.OldOpened(ctx)
	}
	return nil, fmt.Errorf("unknown Dope field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DopeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dope.FieldClaimed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimed(v)
		return nil
	case dope.FieldOpened:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpened(v)
		return nil
	}
	return fmt.Errorf("unknown Dope field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DopeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DopeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DopeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Dope numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DopeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DopeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DopeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Dope nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DopeMutation) ResetField(name string) error {
	switch name {
	case dope.FieldClaimed:
		m.ResetClaimed()
		return nil
	case dope.FieldOpened:
		m.ResetOpened()
		return nil
	}
	return fmt.Errorf("unknown Dope field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DopeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.wallet != nil {
		edges = append(edges, dope.EdgeWallet)
	}
	if m.items != nil {
		edges = append(edges, dope.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DopeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dope.EdgeWallet:
		if id := m.wallet; id != nil {
			return []ent.Value{*id}
		}
	case dope.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DopeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditems != nil {
		edges = append(edges, dope.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DopeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dope.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DopeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedwallet {
		edges = append(edges, dope.EdgeWallet)
	}
	if m.cleareditems {
		edges = append(edges, dope.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DopeMutation) EdgeCleared(name string) bool {
	switch name {
	case dope.EdgeWallet:
		return m.clearedwallet
	case dope.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DopeMutation) ClearEdge(name string) error {
	switch name {
	case dope.EdgeWallet:
		m.ClearWallet()
		return nil
	}
	return fmt.Errorf("unknown Dope unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DopeMutation) ResetEdge(name string) error {
	switch name {
	case dope.EdgeWallet:
		m.ResetWallet()
		return nil
	case dope.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown Dope edge %s", name)
}

// HustlerMutation represents an operation that mutates the Hustler nodes in the graph.
type HustlerMutation struct {
	config
	op               Op
	typ              string
	id               *string
	_type            *hustler.Type
	name             *string
	title            *string
	color            *string
	background       *string
	age              *uint64
	addage           *int64
	sex              *hustler.Sex
	clearedFields    map[string]struct{}
	wallet           *string
	clearedwallet    bool
	items            map[string]struct{}
	removeditems     map[string]struct{}
	cleareditems     bool
	bodyparts        map[string]struct{}
	removedbodyparts map[string]struct{}
	clearedbodyparts bool
	done             bool
	oldValue         func(context.Context) (*Hustler, error)
	predicates       []predicate.Hustler
}

var _ ent.Mutation = (*HustlerMutation)(nil)

// hustlerOption allows management of the mutation configuration using functional options.
type hustlerOption func(*HustlerMutation)

// newHustlerMutation creates new mutation for the Hustler entity.
func newHustlerMutation(c config, op Op, opts ...hustlerOption) *HustlerMutation {
	m := &HustlerMutation{
		config:        c,
		op:            op,
		typ:           TypeHustler,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHustlerID sets the ID field of the mutation.
func withHustlerID(id string) hustlerOption {
	return func(m *HustlerMutation) {
		var (
			err   error
			once  sync.Once
			value *Hustler
		)
		m.oldValue = func(ctx context.Context) (*Hustler, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hustler.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHustler sets the old Hustler of the mutation.
func withHustler(node *Hustler) hustlerOption {
	return func(m *HustlerMutation) {
		m.oldValue = func(context.Context) (*Hustler, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HustlerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HustlerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Hustler entities.
func (m *HustlerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HustlerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HustlerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Hustler.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *HustlerMutation) SetType(h hustler.Type) {
	m._type = &h
}

// GetType returns the value of the "type" field in the mutation.
func (m *HustlerMutation) GetType() (r hustler.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldType(ctx context.Context) (v hustler.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *HustlerMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *HustlerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HustlerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *HustlerMutation) ClearName() {
	m.name = nil
	m.clearedFields[hustler.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *HustlerMutation) NameCleared() bool {
	_, ok := m.clearedFields[hustler.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *HustlerMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, hustler.FieldName)
}

// SetTitle sets the "title" field.
func (m *HustlerMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *HustlerMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *HustlerMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[hustler.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *HustlerMutation) TitleCleared() bool {
	_, ok := m.clearedFields[hustler.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *HustlerMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, hustler.FieldTitle)
}

// SetColor sets the "color" field.
func (m *HustlerMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *HustlerMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *HustlerMutation) ClearColor() {
	m.color = nil
	m.clearedFields[hustler.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *HustlerMutation) ColorCleared() bool {
	_, ok := m.clearedFields[hustler.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *HustlerMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, hustler.FieldColor)
}

// SetBackground sets the "background" field.
func (m *HustlerMutation) SetBackground(s string) {
	m.background = &s
}

// Background returns the value of the "background" field in the mutation.
func (m *HustlerMutation) Background() (r string, exists bool) {
	v := m.background
	if v == nil {
		return
	}
	return *v, true
}

// OldBackground returns the old "background" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldBackground(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackground is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackground requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackground: %w", err)
	}
	return oldValue.Background, nil
}

// ClearBackground clears the value of the "background" field.
func (m *HustlerMutation) ClearBackground() {
	m.background = nil
	m.clearedFields[hustler.FieldBackground] = struct{}{}
}

// BackgroundCleared returns if the "background" field was cleared in this mutation.
func (m *HustlerMutation) BackgroundCleared() bool {
	_, ok := m.clearedFields[hustler.FieldBackground]
	return ok
}

// ResetBackground resets all changes to the "background" field.
func (m *HustlerMutation) ResetBackground() {
	m.background = nil
	delete(m.clearedFields, hustler.FieldBackground)
}

// SetAge sets the "age" field.
func (m *HustlerMutation) SetAge(u uint64) {
	m.age = &u
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *HustlerMutation) Age() (r uint64, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldAge(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds u to the "age" field.
func (m *HustlerMutation) AddAge(u int64) {
	if m.addage != nil {
		*m.addage += u
	} else {
		m.addage = &u
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *HustlerMutation) AddedAge() (r int64, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *HustlerMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetSex sets the "sex" field.
func (m *HustlerMutation) SetSex(h hustler.Sex) {
	m.sex = &h
}

// Sex returns the value of the "sex" field in the mutation.
func (m *HustlerMutation) Sex() (r hustler.Sex, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldSex(ctx context.Context) (v hustler.Sex, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// ClearSex clears the value of the "sex" field.
func (m *HustlerMutation) ClearSex() {
	m.sex = nil
	m.clearedFields[hustler.FieldSex] = struct{}{}
}

// SexCleared returns if the "sex" field was cleared in this mutation.
func (m *HustlerMutation) SexCleared() bool {
	_, ok := m.clearedFields[hustler.FieldSex]
	return ok
}

// ResetSex resets all changes to the "sex" field.
func (m *HustlerMutation) ResetSex() {
	m.sex = nil
	delete(m.clearedFields, hustler.FieldSex)
}

// SetWalletID sets the "wallet" edge to the Wallet entity by id.
func (m *HustlerMutation) SetWalletID(id string) {
	m.wallet = &id
}

// ClearWallet clears the "wallet" edge to the Wallet entity.
func (m *HustlerMutation) ClearWallet() {
	m.clearedwallet = true
}

// WalletCleared reports if the "wallet" edge to the Wallet entity was cleared.
func (m *HustlerMutation) WalletCleared() bool {
	return m.clearedwallet
}

// WalletID returns the "wallet" edge ID in the mutation.
func (m *HustlerMutation) WalletID() (id string, exists bool) {
	if m.wallet != nil {
		return *m.wallet, true
	}
	return
}

// WalletIDs returns the "wallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WalletID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) WalletIDs() (ids []string) {
	if id := m.wallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWallet resets all changes to the "wallet" edge.
func (m *HustlerMutation) ResetWallet() {
	m.wallet = nil
	m.clearedwallet = false
}

// AddItemIDs adds the "items" edge to the Item entity by ids.
func (m *HustlerMutation) AddItemIDs(ids ...string) {
	if m.items == nil {
		m.items = make(map[string]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the Item entity.
func (m *HustlerMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the Item entity was cleared.
func (m *HustlerMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the Item entity by IDs.
func (m *HustlerMutation) RemoveItemIDs(ids ...string) {
	if m.removeditems == nil {
		m.removeditems = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the Item entity.
func (m *HustlerMutation) RemovedItemsIDs() (ids []string) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *HustlerMutation) ItemsIDs() (ids []string) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *HustlerMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddBodypartIDs adds the "bodyparts" edge to the BodyPart entity by ids.
func (m *HustlerMutation) AddBodypartIDs(ids ...string) {
	if m.bodyparts == nil {
		m.bodyparts = make(map[string]struct{})
	}
	for i := range ids {
		m.bodyparts[ids[i]] = struct{}{}
	}
}

// ClearBodyparts clears the "bodyparts" edge to the BodyPart entity.
func (m *HustlerMutation) ClearBodyparts() {
	m.clearedbodyparts = true
}

// BodypartsCleared reports if the "bodyparts" edge to the BodyPart entity was cleared.
func (m *HustlerMutation) BodypartsCleared() bool {
	return m.clearedbodyparts
}

// RemoveBodypartIDs removes the "bodyparts" edge to the BodyPart entity by IDs.
func (m *HustlerMutation) RemoveBodypartIDs(ids ...string) {
	if m.removedbodyparts == nil {
		m.removedbodyparts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.bodyparts, ids[i])
		m.removedbodyparts[ids[i]] = struct{}{}
	}
}

// RemovedBodyparts returns the removed IDs of the "bodyparts" edge to the BodyPart entity.
func (m *HustlerMutation) RemovedBodypartsIDs() (ids []string) {
	for id := range m.removedbodyparts {
		ids = append(ids, id)
	}
	return
}

// BodypartsIDs returns the "bodyparts" edge IDs in the mutation.
func (m *HustlerMutation) BodypartsIDs() (ids []string) {
	for id := range m.bodyparts {
		ids = append(ids, id)
	}
	return
}

// ResetBodyparts resets all changes to the "bodyparts" edge.
func (m *HustlerMutation) ResetBodyparts() {
	m.bodyparts = nil
	m.clearedbodyparts = false
	m.removedbodyparts = nil
}

// Where appends a list predicates to the HustlerMutation builder.
func (m *HustlerMutation) Where(ps ...predicate.Hustler) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HustlerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Hustler).
func (m *HustlerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HustlerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._type != nil {
		fields = append(fields, hustler.FieldType)
	}
	if m.name != nil {
		fields = append(fields, hustler.FieldName)
	}
	if m.title != nil {
		fields = append(fields, hustler.FieldTitle)
	}
	if m.color != nil {
		fields = append(fields, hustler.FieldColor)
	}
	if m.background != nil {
		fields = append(fields, hustler.FieldBackground)
	}
	if m.age != nil {
		fields = append(fields, hustler.FieldAge)
	}
	if m.sex != nil {
		fields = append(fields, hustler.FieldSex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HustlerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hustler.FieldType:
		return m.GetType()
	case hustler.FieldName:
		return m.Name()
	case hustler.FieldTitle:
		return m.Title()
	case hustler.FieldColor:
		return m.Color()
	case hustler.FieldBackground:
		return m.Background()
	case hustler.FieldAge:
		return m.Age()
	case hustler.FieldSex:
		return m.Sex()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HustlerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hustler.FieldType:
		return m.OldType(ctx)
	case hustler.FieldName:
		return m.OldName(ctx)
	case hustler.FieldTitle:
		return m.OldTitle(ctx)
	case hustler.FieldColor:
		return m.OldColor(ctx)
	case hustler.FieldBackground:
		return m.OldBackground(ctx)
	case hustler.FieldAge:
		return m.OldAge(ctx)
	case hustler.FieldSex:
		return m.OldSex(ctx)
	}
	return nil, fmt.Errorf("unknown Hustler field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HustlerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hustler.FieldType:
		v, ok := value.(hustler.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case hustler.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hustler.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case hustler.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case hustler.FieldBackground:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackground(v)
		return nil
	case hustler.FieldAge:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case hustler.FieldSex:
		v, ok := value.(hustler.Sex)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	}
	return fmt.Errorf("unknown Hustler field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HustlerMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, hustler.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HustlerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hustler.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HustlerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hustler.FieldAge:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown Hustler numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HustlerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hustler.FieldName) {
		fields = append(fields, hustler.FieldName)
	}
	if m.FieldCleared(hustler.FieldTitle) {
		fields = append(fields, hustler.FieldTitle)
	}
	if m.FieldCleared(hustler.FieldColor) {
		fields = append(fields, hustler.FieldColor)
	}
	if m.FieldCleared(hustler.FieldBackground) {
		fields = append(fields, hustler.FieldBackground)
	}
	if m.FieldCleared(hustler.FieldSex) {
		fields = append(fields, hustler.FieldSex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HustlerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HustlerMutation) ClearField(name string) error {
	switch name {
	case hustler.FieldName:
		m.ClearName()
		return nil
	case hustler.FieldTitle:
		m.ClearTitle()
		return nil
	case hustler.FieldColor:
		m.ClearColor()
		return nil
	case hustler.FieldBackground:
		m.ClearBackground()
		return nil
	case hustler.FieldSex:
		m.ClearSex()
		return nil
	}
	return fmt.Errorf("unknown Hustler nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HustlerMutation) ResetField(name string) error {
	switch name {
	case hustler.FieldType:
		m.ResetType()
		return nil
	case hustler.FieldName:
		m.ResetName()
		return nil
	case hustler.FieldTitle:
		m.ResetTitle()
		return nil
	case hustler.FieldColor:
		m.ResetColor()
		return nil
	case hustler.FieldBackground:
		m.ResetBackground()
		return nil
	case hustler.FieldAge:
		m.ResetAge()
		return nil
	case hustler.FieldSex:
		m.ResetSex()
		return nil
	}
	return fmt.Errorf("unknown Hustler field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HustlerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.wallet != nil {
		edges = append(edges, hustler.EdgeWallet)
	}
	if m.items != nil {
		edges = append(edges, hustler.EdgeItems)
	}
	if m.bodyparts != nil {
		edges = append(edges, hustler.EdgeBodyparts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HustlerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hustler.EdgeWallet:
		if id := m.wallet; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case hustler.EdgeBodyparts:
		ids := make([]ent.Value, 0, len(m.bodyparts))
		for id := range m.bodyparts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HustlerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeditems != nil {
		edges = append(edges, hustler.EdgeItems)
	}
	if m.removedbodyparts != nil {
		edges = append(edges, hustler.EdgeBodyparts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HustlerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hustler.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case hustler.EdgeBodyparts:
		ids := make([]ent.Value, 0, len(m.removedbodyparts))
		for id := range m.removedbodyparts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HustlerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedwallet {
		edges = append(edges, hustler.EdgeWallet)
	}
	if m.cleareditems {
		edges = append(edges, hustler.EdgeItems)
	}
	if m.clearedbodyparts {
		edges = append(edges, hustler.EdgeBodyparts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HustlerMutation) EdgeCleared(name string) bool {
	switch name {
	case hustler.EdgeWallet:
		return m.clearedwallet
	case hustler.EdgeItems:
		return m.cleareditems
	case hustler.EdgeBodyparts:
		return m.clearedbodyparts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HustlerMutation) ClearEdge(name string) error {
	switch name {
	case hustler.EdgeWallet:
		m.ClearWallet()
		return nil
	}
	return fmt.Errorf("unknown Hustler unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HustlerMutation) ResetEdge(name string) error {
	switch name {
	case hustler.EdgeWallet:
		m.ResetWallet()
		return nil
	case hustler.EdgeItems:
		m.ResetItems()
		return nil
	case hustler.EdgeBodyparts:
		m.ResetBodyparts()
		return nil
	}
	return fmt.Errorf("unknown Hustler edge %s", name)
}

// ItemMutation represents an operation that mutates the Item nodes in the graph.
type ItemMutation struct {
	config
	op                Op
	typ               string
	id                *string
	_type             *item.Type
	name_prefix       *string
	name_suffix       *string
	name              *string
	suffix            *string
	augmented         *bool
	rles              *schema.RLEs
	svg               *string
	clearedFields     map[string]struct{}
	wallets           map[string]struct{}
	removedwallets    map[string]struct{}
	clearedwallets    bool
	hustler           *string
	clearedhustler    bool
	dopes             map[string]struct{}
	removeddopes      map[string]struct{}
	cleareddopes      bool
	base              *string
	clearedbase       bool
	derivative        map[string]struct{}
	removedderivative map[string]struct{}
	clearedderivative bool
	done              bool
	oldValue          func(context.Context) (*Item, error)
	predicates        []predicate.Item
}

var _ ent.Mutation = (*ItemMutation)(nil)

// itemOption allows management of the mutation configuration using functional options.
type itemOption func(*ItemMutation)

// newItemMutation creates new mutation for the Item entity.
func newItemMutation(c config, op Op, opts ...itemOption) *ItemMutation {
	m := &ItemMutation{
		config:        c,
		op:            op,
		typ:           TypeItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withItemID sets the ID field of the mutation.
func withItemID(id string) itemOption {
	return func(m *ItemMutation) {
		var (
			err   error
			once  sync.Once
			value *Item
		)
		m.oldValue = func(ctx context.Context) (*Item, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Item.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withItem sets the old Item of the mutation.
func withItem(node *Item) itemOption {
	return func(m *ItemMutation) {
		m.oldValue = func(context.Context) (*Item, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Item entities.
func (m *ItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Item.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ItemMutation) SetType(i item.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *ItemMutation) GetType() (r item.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldType(ctx context.Context) (v item.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ItemMutation) ResetType() {
	m._type = nil
}

// SetNamePrefix sets the "name_prefix" field.
func (m *ItemMutation) SetNamePrefix(s string) {
	m.name_prefix = &s
}

// NamePrefix returns the value of the "name_prefix" field in the mutation.
func (m *ItemMutation) NamePrefix() (r string, exists bool) {
	v := m.name_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldNamePrefix returns the old "name_prefix" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldNamePrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamePrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamePrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamePrefix: %w", err)
	}
	return oldValue.NamePrefix, nil
}

// ClearNamePrefix clears the value of the "name_prefix" field.
func (m *ItemMutation) ClearNamePrefix() {
	m.name_prefix = nil
	m.clearedFields[item.FieldNamePrefix] = struct{}{}
}

// NamePrefixCleared returns if the "name_prefix" field was cleared in this mutation.
func (m *ItemMutation) NamePrefixCleared() bool {
	_, ok := m.clearedFields[item.FieldNamePrefix]
	return ok
}

// ResetNamePrefix resets all changes to the "name_prefix" field.
func (m *ItemMutation) ResetNamePrefix() {
	m.name_prefix = nil
	delete(m.clearedFields, item.FieldNamePrefix)
}

// SetNameSuffix sets the "name_suffix" field.
func (m *ItemMutation) SetNameSuffix(s string) {
	m.name_suffix = &s
}

// NameSuffix returns the value of the "name_suffix" field in the mutation.
func (m *ItemMutation) NameSuffix() (r string, exists bool) {
	v := m.name_suffix
	if v == nil {
		return
	}
	return *v, true
}

// OldNameSuffix returns the old "name_suffix" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldNameSuffix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameSuffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameSuffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameSuffix: %w", err)
	}
	return oldValue.NameSuffix, nil
}

// ClearNameSuffix clears the value of the "name_suffix" field.
func (m *ItemMutation) ClearNameSuffix() {
	m.name_suffix = nil
	m.clearedFields[item.FieldNameSuffix] = struct{}{}
}

// NameSuffixCleared returns if the "name_suffix" field was cleared in this mutation.
func (m *ItemMutation) NameSuffixCleared() bool {
	_, ok := m.clearedFields[item.FieldNameSuffix]
	return ok
}

// ResetNameSuffix resets all changes to the "name_suffix" field.
func (m *ItemMutation) ResetNameSuffix() {
	m.name_suffix = nil
	delete(m.clearedFields, item.FieldNameSuffix)
}

// SetName sets the "name" field.
func (m *ItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ItemMutation) ResetName() {
	m.name = nil
}

// SetSuffix sets the "suffix" field.
func (m *ItemMutation) SetSuffix(s string) {
	m.suffix = &s
}

// Suffix returns the value of the "suffix" field in the mutation.
func (m *ItemMutation) Suffix() (r string, exists bool) {
	v := m.suffix
	if v == nil {
		return
	}
	return *v, true
}

// OldSuffix returns the old "suffix" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSuffix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuffix: %w", err)
	}
	return oldValue.Suffix, nil
}

// ClearSuffix clears the value of the "suffix" field.
func (m *ItemMutation) ClearSuffix() {
	m.suffix = nil
	m.clearedFields[item.FieldSuffix] = struct{}{}
}

// SuffixCleared returns if the "suffix" field was cleared in this mutation.
func (m *ItemMutation) SuffixCleared() bool {
	_, ok := m.clearedFields[item.FieldSuffix]
	return ok
}

// ResetSuffix resets all changes to the "suffix" field.
func (m *ItemMutation) ResetSuffix() {
	m.suffix = nil
	delete(m.clearedFields, item.FieldSuffix)
}

// SetAugmented sets the "augmented" field.
func (m *ItemMutation) SetAugmented(b bool) {
	m.augmented = &b
}

// Augmented returns the value of the "augmented" field in the mutation.
func (m *ItemMutation) Augmented() (r bool, exists bool) {
	v := m.augmented
	if v == nil {
		return
	}
	return *v, true
}

// OldAugmented returns the old "augmented" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldAugmented(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAugmented is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAugmented requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAugmented: %w", err)
	}
	return oldValue.Augmented, nil
}

// ClearAugmented clears the value of the "augmented" field.
func (m *ItemMutation) ClearAugmented() {
	m.augmented = nil
	m.clearedFields[item.FieldAugmented] = struct{}{}
}

// AugmentedCleared returns if the "augmented" field was cleared in this mutation.
func (m *ItemMutation) AugmentedCleared() bool {
	_, ok := m.clearedFields[item.FieldAugmented]
	return ok
}

// ResetAugmented resets all changes to the "augmented" field.
func (m *ItemMutation) ResetAugmented() {
	m.augmented = nil
	delete(m.clearedFields, item.FieldAugmented)
}

// SetRles sets the "rles" field.
func (m *ItemMutation) SetRles(se schema.RLEs) {
	m.rles = &se
}

// Rles returns the value of the "rles" field in the mutation.
func (m *ItemMutation) Rles() (r schema.RLEs, exists bool) {
	v := m.rles
	if v == nil {
		return
	}
	return *v, true
}

// OldRles returns the old "rles" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldRles(ctx context.Context) (v schema.RLEs, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRles: %w", err)
	}
	return oldValue.Rles, nil
}

// ClearRles clears the value of the "rles" field.
func (m *ItemMutation) ClearRles() {
	m.rles = nil
	m.clearedFields[item.FieldRles] = struct{}{}
}

// RlesCleared returns if the "rles" field was cleared in this mutation.
func (m *ItemMutation) RlesCleared() bool {
	_, ok := m.clearedFields[item.FieldRles]
	return ok
}

// ResetRles resets all changes to the "rles" field.
func (m *ItemMutation) ResetRles() {
	m.rles = nil
	delete(m.clearedFields, item.FieldRles)
}

// SetSvg sets the "svg" field.
func (m *ItemMutation) SetSvg(s string) {
	m.svg = &s
}

// Svg returns the value of the "svg" field in the mutation.
func (m *ItemMutation) Svg() (r string, exists bool) {
	v := m.svg
	if v == nil {
		return
	}
	return *v, true
}

// OldSvg returns the old "svg" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSvg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSvg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSvg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSvg: %w", err)
	}
	return oldValue.Svg, nil
}

// ClearSvg clears the value of the "svg" field.
func (m *ItemMutation) ClearSvg() {
	m.svg = nil
	m.clearedFields[item.FieldSvg] = struct{}{}
}

// SvgCleared returns if the "svg" field was cleared in this mutation.
func (m *ItemMutation) SvgCleared() bool {
	_, ok := m.clearedFields[item.FieldSvg]
	return ok
}

// ResetSvg resets all changes to the "svg" field.
func (m *ItemMutation) ResetSvg() {
	m.svg = nil
	delete(m.clearedFields, item.FieldSvg)
}

// AddWalletIDs adds the "wallets" edge to the WalletItems entity by ids.
func (m *ItemMutation) AddWalletIDs(ids ...string) {
	if m.wallets == nil {
		m.wallets = make(map[string]struct{})
	}
	for i := range ids {
		m.wallets[ids[i]] = struct{}{}
	}
}

// ClearWallets clears the "wallets" edge to the WalletItems entity.
func (m *ItemMutation) ClearWallets() {
	m.clearedwallets = true
}

// WalletsCleared reports if the "wallets" edge to the WalletItems entity was cleared.
func (m *ItemMutation) WalletsCleared() bool {
	return m.clearedwallets
}

// RemoveWalletIDs removes the "wallets" edge to the WalletItems entity by IDs.
func (m *ItemMutation) RemoveWalletIDs(ids ...string) {
	if m.removedwallets == nil {
		m.removedwallets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.wallets, ids[i])
		m.removedwallets[ids[i]] = struct{}{}
	}
}

// RemovedWallets returns the removed IDs of the "wallets" edge to the WalletItems entity.
func (m *ItemMutation) RemovedWalletsIDs() (ids []string) {
	for id := range m.removedwallets {
		ids = append(ids, id)
	}
	return
}

// WalletsIDs returns the "wallets" edge IDs in the mutation.
func (m *ItemMutation) WalletsIDs() (ids []string) {
	for id := range m.wallets {
		ids = append(ids, id)
	}
	return
}

// ResetWallets resets all changes to the "wallets" edge.
func (m *ItemMutation) ResetWallets() {
	m.wallets = nil
	m.clearedwallets = false
	m.removedwallets = nil
}

// SetHustlerID sets the "hustler" edge to the Hustler entity by id.
func (m *ItemMutation) SetHustlerID(id string) {
	m.hustler = &id
}

// ClearHustler clears the "hustler" edge to the Hustler entity.
func (m *ItemMutation) ClearHustler() {
	m.clearedhustler = true
}

// HustlerCleared reports if the "hustler" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerCleared() bool {
	return m.clearedhustler
}

// HustlerID returns the "hustler" edge ID in the mutation.
func (m *ItemMutation) HustlerID() (id string, exists bool) {
	if m.hustler != nil {
		return *m.hustler, true
	}
	return
}

// HustlerIDs returns the "hustler" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HustlerID instead. It exists only for internal usage by the builders.
func (m *ItemMutation) HustlerIDs() (ids []string) {
	if id := m.hustler; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHustler resets all changes to the "hustler" edge.
func (m *ItemMutation) ResetHustler() {
	m.hustler = nil
	m.clearedhustler = false
}

// AddDopeIDs adds the "dopes" edge to the Dope entity by ids.
func (m *ItemMutation) AddDopeIDs(ids ...string) {
	if m.dopes == nil {
		m.dopes = make(map[string]struct{})
	}
	for i := range ids {
		m.dopes[ids[i]] = struct{}{}
	}
}

// ClearDopes clears the "dopes" edge to the Dope entity.
func (m *ItemMutation) ClearDopes() {
	m.cleareddopes = true
}

// DopesCleared reports if the "dopes" edge to the Dope entity was cleared.
func (m *ItemMutation) DopesCleared() bool {
	return m.cleareddopes
}

// RemoveDopeIDs removes the "dopes" edge to the Dope entity by IDs.
func (m *ItemMutation) RemoveDopeIDs(ids ...string) {
	if m.removeddopes == nil {
		m.removeddopes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dopes, ids[i])
		m.removeddopes[ids[i]] = struct{}{}
	}
}

// RemovedDopes returns the removed IDs of the "dopes" edge to the Dope entity.
func (m *ItemMutation) RemovedDopesIDs() (ids []string) {
	for id := range m.removeddopes {
		ids = append(ids, id)
	}
	return
}

// DopesIDs returns the "dopes" edge IDs in the mutation.
func (m *ItemMutation) DopesIDs() (ids []string) {
	for id := range m.dopes {
		ids = append(ids, id)
	}
	return
}

// ResetDopes resets all changes to the "dopes" edge.
func (m *ItemMutation) ResetDopes() {
	m.dopes = nil
	m.cleareddopes = false
	m.removeddopes = nil
}

// SetBaseID sets the "base" edge to the Item entity by id.
func (m *ItemMutation) SetBaseID(id string) {
	m.base = &id
}

// ClearBase clears the "base" edge to the Item entity.
func (m *ItemMutation) ClearBase() {
	m.clearedbase = true
}

// BaseCleared reports if the "base" edge to the Item entity was cleared.
func (m *ItemMutation) BaseCleared() bool {
	return m.clearedbase
}

// BaseID returns the "base" edge ID in the mutation.
func (m *ItemMutation) BaseID() (id string, exists bool) {
	if m.base != nil {
		return *m.base, true
	}
	return
}

// BaseIDs returns the "base" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BaseID instead. It exists only for internal usage by the builders.
func (m *ItemMutation) BaseIDs() (ids []string) {
	if id := m.base; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBase resets all changes to the "base" edge.
func (m *ItemMutation) ResetBase() {
	m.base = nil
	m.clearedbase = false
}

// AddDerivativeIDs adds the "derivative" edge to the Item entity by ids.
func (m *ItemMutation) AddDerivativeIDs(ids ...string) {
	if m.derivative == nil {
		m.derivative = make(map[string]struct{})
	}
	for i := range ids {
		m.derivative[ids[i]] = struct{}{}
	}
}

// ClearDerivative clears the "derivative" edge to the Item entity.
func (m *ItemMutation) ClearDerivative() {
	m.clearedderivative = true
}

// DerivativeCleared reports if the "derivative" edge to the Item entity was cleared.
func (m *ItemMutation) DerivativeCleared() bool {
	return m.clearedderivative
}

// RemoveDerivativeIDs removes the "derivative" edge to the Item entity by IDs.
func (m *ItemMutation) RemoveDerivativeIDs(ids ...string) {
	if m.removedderivative == nil {
		m.removedderivative = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.derivative, ids[i])
		m.removedderivative[ids[i]] = struct{}{}
	}
}

// RemovedDerivative returns the removed IDs of the "derivative" edge to the Item entity.
func (m *ItemMutation) RemovedDerivativeIDs() (ids []string) {
	for id := range m.removedderivative {
		ids = append(ids, id)
	}
	return
}

// DerivativeIDs returns the "derivative" edge IDs in the mutation.
func (m *ItemMutation) DerivativeIDs() (ids []string) {
	for id := range m.derivative {
		ids = append(ids, id)
	}
	return
}

// ResetDerivative resets all changes to the "derivative" edge.
func (m *ItemMutation) ResetDerivative() {
	m.derivative = nil
	m.clearedderivative = false
	m.removedderivative = nil
}

// Where appends a list predicates to the ItemMutation builder.
func (m *ItemMutation) Where(ps ...predicate.Item) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Item).
func (m *ItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._type != nil {
		fields = append(fields, item.FieldType)
	}
	if m.name_prefix != nil {
		fields = append(fields, item.FieldNamePrefix)
	}
	if m.name_suffix != nil {
		fields = append(fields, item.FieldNameSuffix)
	}
	if m.name != nil {
		fields = append(fields, item.FieldName)
	}
	if m.suffix != nil {
		fields = append(fields, item.FieldSuffix)
	}
	if m.augmented != nil {
		fields = append(fields, item.FieldAugmented)
	}
	if m.rles != nil {
		fields = append(fields, item.FieldRles)
	}
	if m.svg != nil {
		fields = append(fields, item.FieldSvg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case item.FieldType:
		return m.GetType()
	case item.FieldNamePrefix:
		return m.NamePrefix()
	case item.FieldNameSuffix:
		return m.NameSuffix()
	case item.FieldName:
		return m.Name()
	case item.FieldSuffix:
		return m.Suffix()
	case item.FieldAugmented:
		return m.Augmented()
	case item.FieldRles:
		return m.Rles()
	case item.FieldSvg:
		return m.Svg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case item.FieldType:
		return m.OldType(ctx)
	case item.FieldNamePrefix:
		return m.OldNamePrefix(ctx)
	case item.FieldNameSuffix:
		return m.OldNameSuffix(ctx)
	case item.FieldName:
		return m.OldName(ctx)
	case item.FieldSuffix:
		return m.OldSuffix(ctx)
	case item.FieldAugmented:
		return m.OldAugmented(ctx)
	case item.FieldRles:
		return m.OldRles(ctx)
	case item.FieldSvg:
		return m.OldSvg(ctx)
	}
	return nil, fmt.Errorf("unknown Item field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case item.FieldType:
		v, ok := value.(item.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case item.FieldNamePrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamePrefix(v)
		return nil
	case item.FieldNameSuffix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameSuffix(v)
		return nil
	case item.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case item.FieldSuffix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuffix(v)
		return nil
	case item.FieldAugmented:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAugmented(v)
		return nil
	case item.FieldRles:
		v, ok := value.(schema.RLEs)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRles(v)
		return nil
	case item.FieldSvg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSvg(v)
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ItemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ItemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Item numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(item.FieldNamePrefix) {
		fields = append(fields, item.FieldNamePrefix)
	}
	if m.FieldCleared(item.FieldNameSuffix) {
		fields = append(fields, item.FieldNameSuffix)
	}
	if m.FieldCleared(item.FieldSuffix) {
		fields = append(fields, item.FieldSuffix)
	}
	if m.FieldCleared(item.FieldAugmented) {
		fields = append(fields, item.FieldAugmented)
	}
	if m.FieldCleared(item.FieldRles) {
		fields = append(fields, item.FieldRles)
	}
	if m.FieldCleared(item.FieldSvg) {
		fields = append(fields, item.FieldSvg)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ItemMutation) ClearField(name string) error {
	switch name {
	case item.FieldNamePrefix:
		m.ClearNamePrefix()
		return nil
	case item.FieldNameSuffix:
		m.ClearNameSuffix()
		return nil
	case item.FieldSuffix:
		m.ClearSuffix()
		return nil
	case item.FieldAugmented:
		m.ClearAugmented()
		return nil
	case item.FieldRles:
		m.ClearRles()
		return nil
	case item.FieldSvg:
		m.ClearSvg()
		return nil
	}
	return fmt.Errorf("unknown Item nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ItemMutation) ResetField(name string) error {
	switch name {
	case item.FieldType:
		m.ResetType()
		return nil
	case item.FieldNamePrefix:
		m.ResetNamePrefix()
		return nil
	case item.FieldNameSuffix:
		m.ResetNameSuffix()
		return nil
	case item.FieldName:
		m.ResetName()
		return nil
	case item.FieldSuffix:
		m.ResetSuffix()
		return nil
	case item.FieldAugmented:
		m.ResetAugmented()
		return nil
	case item.FieldRles:
		m.ResetRles()
		return nil
	case item.FieldSvg:
		m.ResetSvg()
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.wallets != nil {
		edges = append(edges, item.EdgeWallets)
	}
	if m.hustler != nil {
		edges = append(edges, item.EdgeHustler)
	}
	if m.dopes != nil {
		edges = append(edges, item.EdgeDopes)
	}
	if m.base != nil {
		edges = append(edges, item.EdgeBase)
	}
	if m.derivative != nil {
		edges = append(edges, item.EdgeDerivative)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeWallets:
		ids := make([]ent.Value, 0, len(m.wallets))
		for id := range m.wallets {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustler:
		if id := m.hustler; id != nil {
			return []ent.Value{*id}
		}
	case item.EdgeDopes:
		ids := make([]ent.Value, 0, len(m.dopes))
		for id := range m.dopes {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeBase:
		if id := m.base; id != nil {
			return []ent.Value{*id}
		}
	case item.EdgeDerivative:
		ids := make([]ent.Value, 0, len(m.derivative))
		for id := range m.derivative {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedwallets != nil {
		edges = append(edges, item.EdgeWallets)
	}
	if m.removeddopes != nil {
		edges = append(edges, item.EdgeDopes)
	}
	if m.removedderivative != nil {
		edges = append(edges, item.EdgeDerivative)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeWallets:
		ids := make([]ent.Value, 0, len(m.removedwallets))
		for id := range m.removedwallets {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeDopes:
		ids := make([]ent.Value, 0, len(m.removeddopes))
		for id := range m.removeddopes {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeDerivative:
		ids := make([]ent.Value, 0, len(m.removedderivative))
		for id := range m.removedderivative {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedwallets {
		edges = append(edges, item.EdgeWallets)
	}
	if m.clearedhustler {
		edges = append(edges, item.EdgeHustler)
	}
	if m.cleareddopes {
		edges = append(edges, item.EdgeDopes)
	}
	if m.clearedbase {
		edges = append(edges, item.EdgeBase)
	}
	if m.clearedderivative {
		edges = append(edges, item.EdgeDerivative)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ItemMutation) EdgeCleared(name string) bool {
	switch name {
	case item.EdgeWallets:
		return m.clearedwallets
	case item.EdgeHustler:
		return m.clearedhustler
	case item.EdgeDopes:
		return m.cleareddopes
	case item.EdgeBase:
		return m.clearedbase
	case item.EdgeDerivative:
		return m.clearedderivative
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ItemMutation) ClearEdge(name string) error {
	switch name {
	case item.EdgeHustler:
		m.ClearHustler()
		return nil
	case item.EdgeBase:
		m.ClearBase()
		return nil
	}
	return fmt.Errorf("unknown Item unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ItemMutation) ResetEdge(name string) error {
	switch name {
	case item.EdgeWallets:
		m.ResetWallets()
		return nil
	case item.EdgeHustler:
		m.ResetHustler()
		return nil
	case item.EdgeDopes:
		m.ResetDopes()
		return nil
	case item.EdgeBase:
		m.ResetBase()
		return nil
	case item.EdgeDerivative:
		m.ResetDerivative()
		return nil
	}
	return fmt.Errorf("unknown Item edge %s", name)
}

// SyncStateMutation represents an operation that mutates the SyncState nodes in the graph.
type SyncStateMutation struct {
	config
	op             Op
	typ            string
	id             *string
	start_block    *uint64
	addstart_block *int64
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*SyncState, error)
	predicates     []predicate.SyncState
}

var _ ent.Mutation = (*SyncStateMutation)(nil)

// syncstateOption allows management of the mutation configuration using functional options.
type syncstateOption func(*SyncStateMutation)

// newSyncStateMutation creates new mutation for the SyncState entity.
func newSyncStateMutation(c config, op Op, opts ...syncstateOption) *SyncStateMutation {
	m := &SyncStateMutation{
		config:        c,
		op:            op,
		typ:           TypeSyncState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSyncStateID sets the ID field of the mutation.
func withSyncStateID(id string) syncstateOption {
	return func(m *SyncStateMutation) {
		var (
			err   error
			once  sync.Once
			value *SyncState
		)
		m.oldValue = func(ctx context.Context) (*SyncState, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SyncState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSyncState sets the old SyncState of the mutation.
func withSyncState(node *SyncState) syncstateOption {
	return func(m *SyncStateMutation) {
		m.oldValue = func(context.Context) (*SyncState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SyncStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SyncStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SyncState entities.
func (m *SyncStateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SyncStateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SyncStateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SyncState.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartBlock sets the "start_block" field.
func (m *SyncStateMutation) SetStartBlock(u uint64) {
	m.start_block = &u
	m.addstart_block = nil
}

// StartBlock returns the value of the "start_block" field in the mutation.
func (m *SyncStateMutation) StartBlock() (r uint64, exists bool) {
	v := m.start_block
	if v == nil {
		return
	}
	return *v, true
}

// OldStartBlock returns the old "start_block" field's value of the SyncState entity.
// If the SyncState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncStateMutation) OldStartBlock(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartBlock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartBlock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartBlock: %w", err)
	}
	return oldValue.StartBlock, nil
}

// AddStartBlock adds u to the "start_block" field.
func (m *SyncStateMutation) AddStartBlock(u int64) {
	if m.addstart_block != nil {
		*m.addstart_block += u
	} else {
		m.addstart_block = &u
	}
}

// AddedStartBlock returns the value that was added to the "start_block" field in this mutation.
func (m *SyncStateMutation) AddedStartBlock() (r int64, exists bool) {
	v := m.addstart_block
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartBlock resets all changes to the "start_block" field.
func (m *SyncStateMutation) ResetStartBlock() {
	m.start_block = nil
	m.addstart_block = nil
}

// Where appends a list predicates to the SyncStateMutation builder.
func (m *SyncStateMutation) Where(ps ...predicate.SyncState) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SyncStateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SyncState).
func (m *SyncStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SyncStateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.start_block != nil {
		fields = append(fields, syncstate.FieldStartBlock)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SyncStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case syncstate.FieldStartBlock:
		return m.StartBlock()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SyncStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case syncstate.FieldStartBlock:
		return m.OldStartBlock(ctx)
	}
	return nil, fmt.Errorf("unknown SyncState field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case syncstate.FieldStartBlock:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartBlock(v)
		return nil
	}
	return fmt.Errorf("unknown SyncState field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SyncStateMutation) AddedFields() []string {
	var fields []string
	if m.addstart_block != nil {
		fields = append(fields, syncstate.FieldStartBlock)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SyncStateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case syncstate.FieldStartBlock:
		return m.AddedStartBlock()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case syncstate.FieldStartBlock:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartBlock(v)
		return nil
	}
	return fmt.Errorf("unknown SyncState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SyncStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SyncStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SyncStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SyncState nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SyncStateMutation) ResetField(name string) error {
	switch name {
	case syncstate.FieldStartBlock:
		m.ResetStartBlock()
		return nil
	}
	return fmt.Errorf("unknown SyncState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SyncStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SyncStateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SyncStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SyncStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SyncStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SyncStateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SyncStateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SyncState unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SyncStateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SyncState edge %s", name)
}

// WalletMutation represents an operation that mutates the Wallet nodes in the graph.
type WalletMutation struct {
	config
	op              Op
	typ             string
	id              *string
	paper           *schema.BigInt
	addpaper        *schema.BigInt
	clearedFields   map[string]struct{}
	dopes           map[string]struct{}
	removeddopes    map[string]struct{}
	cleareddopes    bool
	items           map[string]struct{}
	removeditems    map[string]struct{}
	cleareditems    bool
	hustlers        map[string]struct{}
	removedhustlers map[string]struct{}
	clearedhustlers bool
	done            bool
	oldValue        func(context.Context) (*Wallet, error)
	predicates      []predicate.Wallet
}

var _ ent.Mutation = (*WalletMutation)(nil)

// walletOption allows management of the mutation configuration using functional options.
type walletOption func(*WalletMutation)

// newWalletMutation creates new mutation for the Wallet entity.
func newWalletMutation(c config, op Op, opts ...walletOption) *WalletMutation {
	m := &WalletMutation{
		config:        c,
		op:            op,
		typ:           TypeWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWalletID sets the ID field of the mutation.
func withWalletID(id string) walletOption {
	return func(m *WalletMutation) {
		var (
			err   error
			once  sync.Once
			value *Wallet
		)
		m.oldValue = func(ctx context.Context) (*Wallet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Wallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWallet sets the old Wallet of the mutation.
func withWallet(node *Wallet) walletOption {
	return func(m *WalletMutation) {
		m.oldValue = func(context.Context) (*Wallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Wallet entities.
func (m *WalletMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WalletMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WalletMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Wallet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPaper sets the "paper" field.
func (m *WalletMutation) SetPaper(si schema.BigInt) {
	m.paper = &si
	m.addpaper = nil
}

// Paper returns the value of the "paper" field in the mutation.
func (m *WalletMutation) Paper() (r schema.BigInt, exists bool) {
	v := m.paper
	if v == nil {
		return
	}
	return *v, true
}

// OldPaper returns the old "paper" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldPaper(ctx context.Context) (v schema.BigInt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaper: %w", err)
	}
	return oldValue.Paper, nil
}

// AddPaper adds si to the "paper" field.
func (m *WalletMutation) AddPaper(si schema.BigInt) {
	if m.addpaper != nil {
		*m.addpaper = m.addpaper.Add(si)
	} else {
		m.addpaper = &si
	}
}

// AddedPaper returns the value that was added to the "paper" field in this mutation.
func (m *WalletMutation) AddedPaper() (r schema.BigInt, exists bool) {
	v := m.addpaper
	if v == nil {
		return
	}
	return *v, true
}

// ResetPaper resets all changes to the "paper" field.
func (m *WalletMutation) ResetPaper() {
	m.paper = nil
	m.addpaper = nil
}

// AddDopeIDs adds the "dopes" edge to the Dope entity by ids.
func (m *WalletMutation) AddDopeIDs(ids ...string) {
	if m.dopes == nil {
		m.dopes = make(map[string]struct{})
	}
	for i := range ids {
		m.dopes[ids[i]] = struct{}{}
	}
}

// ClearDopes clears the "dopes" edge to the Dope entity.
func (m *WalletMutation) ClearDopes() {
	m.cleareddopes = true
}

// DopesCleared reports if the "dopes" edge to the Dope entity was cleared.
func (m *WalletMutation) DopesCleared() bool {
	return m.cleareddopes
}

// RemoveDopeIDs removes the "dopes" edge to the Dope entity by IDs.
func (m *WalletMutation) RemoveDopeIDs(ids ...string) {
	if m.removeddopes == nil {
		m.removeddopes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dopes, ids[i])
		m.removeddopes[ids[i]] = struct{}{}
	}
}

// RemovedDopes returns the removed IDs of the "dopes" edge to the Dope entity.
func (m *WalletMutation) RemovedDopesIDs() (ids []string) {
	for id := range m.removeddopes {
		ids = append(ids, id)
	}
	return
}

// DopesIDs returns the "dopes" edge IDs in the mutation.
func (m *WalletMutation) DopesIDs() (ids []string) {
	for id := range m.dopes {
		ids = append(ids, id)
	}
	return
}

// ResetDopes resets all changes to the "dopes" edge.
func (m *WalletMutation) ResetDopes() {
	m.dopes = nil
	m.cleareddopes = false
	m.removeddopes = nil
}

// AddItemIDs adds the "items" edge to the WalletItems entity by ids.
func (m *WalletMutation) AddItemIDs(ids ...string) {
	if m.items == nil {
		m.items = make(map[string]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the WalletItems entity.
func (m *WalletMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the WalletItems entity was cleared.
func (m *WalletMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the WalletItems entity by IDs.
func (m *WalletMutation) RemoveItemIDs(ids ...string) {
	if m.removeditems == nil {
		m.removeditems = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the WalletItems entity.
func (m *WalletMutation) RemovedItemsIDs() (ids []string) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *WalletMutation) ItemsIDs() (ids []string) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *WalletMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddHustlerIDs adds the "hustlers" edge to the Hustler entity by ids.
func (m *WalletMutation) AddHustlerIDs(ids ...string) {
	if m.hustlers == nil {
		m.hustlers = make(map[string]struct{})
	}
	for i := range ids {
		m.hustlers[ids[i]] = struct{}{}
	}
}

// ClearHustlers clears the "hustlers" edge to the Hustler entity.
func (m *WalletMutation) ClearHustlers() {
	m.clearedhustlers = true
}

// HustlersCleared reports if the "hustlers" edge to the Hustler entity was cleared.
func (m *WalletMutation) HustlersCleared() bool {
	return m.clearedhustlers
}

// RemoveHustlerIDs removes the "hustlers" edge to the Hustler entity by IDs.
func (m *WalletMutation) RemoveHustlerIDs(ids ...string) {
	if m.removedhustlers == nil {
		m.removedhustlers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustlers, ids[i])
		m.removedhustlers[ids[i]] = struct{}{}
	}
}

// RemovedHustlers returns the removed IDs of the "hustlers" edge to the Hustler entity.
func (m *WalletMutation) RemovedHustlersIDs() (ids []string) {
	for id := range m.removedhustlers {
		ids = append(ids, id)
	}
	return
}

// HustlersIDs returns the "hustlers" edge IDs in the mutation.
func (m *WalletMutation) HustlersIDs() (ids []string) {
	for id := range m.hustlers {
		ids = append(ids, id)
	}
	return
}

// ResetHustlers resets all changes to the "hustlers" edge.
func (m *WalletMutation) ResetHustlers() {
	m.hustlers = nil
	m.clearedhustlers = false
	m.removedhustlers = nil
}

// Where appends a list predicates to the WalletMutation builder.
func (m *WalletMutation) Where(ps ...predicate.Wallet) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WalletMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Wallet).
func (m *WalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WalletMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.paper != nil {
		fields = append(fields, wallet.FieldPaper)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldPaper:
		return m.Paper()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wallet.FieldPaper:
		return m.OldPaper(ctx)
	}
	return nil, fmt.Errorf("unknown Wallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldPaper:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaper(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WalletMutation) AddedFields() []string {
	var fields []string
	if m.addpaper != nil {
		fields = append(fields, wallet.FieldPaper)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldPaper:
		return m.AddedPaper()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldPaper:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaper(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WalletMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WalletMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Wallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WalletMutation) ResetField(name string) error {
	switch name {
	case wallet.FieldPaper:
		m.ResetPaper()
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.dopes != nil {
		edges = append(edges, wallet.EdgeDopes)
	}
	if m.items != nil {
		edges = append(edges, wallet.EdgeItems)
	}
	if m.hustlers != nil {
		edges = append(edges, wallet.EdgeHustlers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WalletMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wallet.EdgeDopes:
		ids := make([]ent.Value, 0, len(m.dopes))
		for id := range m.dopes {
			ids = append(ids, id)
		}
		return ids
	case wallet.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case wallet.EdgeHustlers:
		ids := make([]ent.Value, 0, len(m.hustlers))
		for id := range m.hustlers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddopes != nil {
		edges = append(edges, wallet.EdgeDopes)
	}
	if m.removeditems != nil {
		edges = append(edges, wallet.EdgeItems)
	}
	if m.removedhustlers != nil {
		edges = append(edges, wallet.EdgeHustlers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WalletMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case wallet.EdgeDopes:
		ids := make([]ent.Value, 0, len(m.removeddopes))
		for id := range m.removeddopes {
			ids = append(ids, id)
		}
		return ids
	case wallet.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case wallet.EdgeHustlers:
		ids := make([]ent.Value, 0, len(m.removedhustlers))
		for id := range m.removedhustlers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddopes {
		edges = append(edges, wallet.EdgeDopes)
	}
	if m.cleareditems {
		edges = append(edges, wallet.EdgeItems)
	}
	if m.clearedhustlers {
		edges = append(edges, wallet.EdgeHustlers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WalletMutation) EdgeCleared(name string) bool {
	switch name {
	case wallet.EdgeDopes:
		return m.cleareddopes
	case wallet.EdgeItems:
		return m.cleareditems
	case wallet.EdgeHustlers:
		return m.clearedhustlers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WalletMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Wallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WalletMutation) ResetEdge(name string) error {
	switch name {
	case wallet.EdgeDopes:
		m.ResetDopes()
		return nil
	case wallet.EdgeItems:
		m.ResetItems()
		return nil
	case wallet.EdgeHustlers:
		m.ResetHustlers()
		return nil
	}
	return fmt.Errorf("unknown Wallet edge %s", name)
}

// WalletItemsMutation represents an operation that mutates the WalletItems nodes in the graph.
type WalletItemsMutation struct {
	config
	op            Op
	typ           string
	id            *string
	balance       *schema.BigInt
	addbalance    *schema.BigInt
	clearedFields map[string]struct{}
	wallet        *string
	clearedwallet bool
	item          *string
	cleareditem   bool
	done          bool
	oldValue      func(context.Context) (*WalletItems, error)
	predicates    []predicate.WalletItems
}

var _ ent.Mutation = (*WalletItemsMutation)(nil)

// walletitemsOption allows management of the mutation configuration using functional options.
type walletitemsOption func(*WalletItemsMutation)

// newWalletItemsMutation creates new mutation for the WalletItems entity.
func newWalletItemsMutation(c config, op Op, opts ...walletitemsOption) *WalletItemsMutation {
	m := &WalletItemsMutation{
		config:        c,
		op:            op,
		typ:           TypeWalletItems,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWalletItemsID sets the ID field of the mutation.
func withWalletItemsID(id string) walletitemsOption {
	return func(m *WalletItemsMutation) {
		var (
			err   error
			once  sync.Once
			value *WalletItems
		)
		m.oldValue = func(ctx context.Context) (*WalletItems, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WalletItems.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWalletItems sets the old WalletItems of the mutation.
func withWalletItems(node *WalletItems) walletitemsOption {
	return func(m *WalletItemsMutation) {
		m.oldValue = func(context.Context) (*WalletItems, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WalletItemsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WalletItemsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WalletItems entities.
func (m *WalletItemsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WalletItemsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WalletItemsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WalletItems.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBalance sets the "balance" field.
func (m *WalletItemsMutation) SetBalance(si schema.BigInt) {
	m.balance = &si
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *WalletItemsMutation) Balance() (r schema.BigInt, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the WalletItems entity.
// If the WalletItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletItemsMutation) OldBalance(ctx context.Context) (v schema.BigInt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds si to the "balance" field.
func (m *WalletItemsMutation) AddBalance(si schema.BigInt) {
	if m.addbalance != nil {
		*m.addbalance = m.addbalance.Add(si)
	} else {
		m.addbalance = &si
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *WalletItemsMutation) AddedBalance() (r schema.BigInt, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *WalletItemsMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetWalletID sets the "wallet" edge to the Wallet entity by id.
func (m *WalletItemsMutation) SetWalletID(id string) {
	m.wallet = &id
}

// ClearWallet clears the "wallet" edge to the Wallet entity.
func (m *WalletItemsMutation) ClearWallet() {
	m.clearedwallet = true
}

// WalletCleared reports if the "wallet" edge to the Wallet entity was cleared.
func (m *WalletItemsMutation) WalletCleared() bool {
	return m.clearedwallet
}

// WalletID returns the "wallet" edge ID in the mutation.
func (m *WalletItemsMutation) WalletID() (id string, exists bool) {
	if m.wallet != nil {
		return *m.wallet, true
	}
	return
}

// WalletIDs returns the "wallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WalletID instead. It exists only for internal usage by the builders.
func (m *WalletItemsMutation) WalletIDs() (ids []string) {
	if id := m.wallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWallet resets all changes to the "wallet" edge.
func (m *WalletItemsMutation) ResetWallet() {
	m.wallet = nil
	m.clearedwallet = false
}

// SetItemID sets the "item" edge to the Item entity by id.
func (m *WalletItemsMutation) SetItemID(id string) {
	m.item = &id
}

// ClearItem clears the "item" edge to the Item entity.
func (m *WalletItemsMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the Item entity was cleared.
func (m *WalletItemsMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemID returns the "item" edge ID in the mutation.
func (m *WalletItemsMutation) ItemID() (id string, exists bool) {
	if m.item != nil {
		return *m.item, true
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *WalletItemsMutation) ItemIDs() (ids []string) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *WalletItemsMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// Where appends a list predicates to the WalletItemsMutation builder.
func (m *WalletItemsMutation) Where(ps ...predicate.WalletItems) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WalletItemsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WalletItems).
func (m *WalletItemsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WalletItemsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.balance != nil {
		fields = append(fields, walletitems.FieldBalance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WalletItemsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case walletitems.FieldBalance:
		return m.Balance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WalletItemsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case walletitems.FieldBalance:
		return m.OldBalance(ctx)
	}
	return nil, fmt.Errorf("unknown WalletItems field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletItemsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case walletitems.FieldBalance:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	}
	return fmt.Errorf("unknown WalletItems field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WalletItemsMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, walletitems.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WalletItemsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case walletitems.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletItemsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case walletitems.FieldBalance:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown WalletItems numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WalletItemsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WalletItemsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WalletItemsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WalletItems nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WalletItemsMutation) ResetField(name string) error {
	switch name {
	case walletitems.FieldBalance:
		m.ResetBalance()
		return nil
	}
	return fmt.Errorf("unknown WalletItems field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WalletItemsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.wallet != nil {
		edges = append(edges, walletitems.EdgeWallet)
	}
	if m.item != nil {
		edges = append(edges, walletitems.EdgeItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WalletItemsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case walletitems.EdgeWallet:
		if id := m.wallet; id != nil {
			return []ent.Value{*id}
		}
	case walletitems.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WalletItemsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WalletItemsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WalletItemsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedwallet {
		edges = append(edges, walletitems.EdgeWallet)
	}
	if m.cleareditem {
		edges = append(edges, walletitems.EdgeItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WalletItemsMutation) EdgeCleared(name string) bool {
	switch name {
	case walletitems.EdgeWallet:
		return m.clearedwallet
	case walletitems.EdgeItem:
		return m.cleareditem
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WalletItemsMutation) ClearEdge(name string) error {
	switch name {
	case walletitems.EdgeWallet:
		m.ClearWallet()
		return nil
	case walletitems.EdgeItem:
		m.ClearItem()
		return nil
	}
	return fmt.Errorf("unknown WalletItems unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WalletItemsMutation) ResetEdge(name string) error {
	switch name {
	case walletitems.EdgeWallet:
		m.ResetWallet()
		return nil
	case walletitems.EdgeItem:
		m.ResetItem()
		return nil
	}
	return fmt.Errorf("unknown WalletItems edge %s", name)
}
