// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/dopedao/dope-monorepo/packages/api/ent/asset"
	"github.com/dopedao/dope-monorepo/packages/api/ent/bodypart"
	"github.com/dopedao/dope-monorepo/packages/api/ent/dope"
	"github.com/dopedao/dope-monorepo/packages/api/ent/event"
	"github.com/dopedao/dope-monorepo/packages/api/ent/hustler"
	"github.com/dopedao/dope-monorepo/packages/api/ent/item"
	"github.com/dopedao/dope-monorepo/packages/api/ent/listing"
	"github.com/dopedao/dope-monorepo/packages/api/ent/paymenttoken"
	"github.com/dopedao/dope-monorepo/packages/api/ent/predicate"
	"github.com/dopedao/dope-monorepo/packages/api/ent/schema"
	"github.com/dopedao/dope-monorepo/packages/api/ent/syncstate"
	"github.com/dopedao/dope-monorepo/packages/api/ent/wallet"
	"github.com/dopedao/dope-monorepo/packages/api/ent/walletitems"
	"github.com/ethereum/go-ethereum/common"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAsset        = "Asset"
	TypeBodyPart     = "BodyPart"
	TypeDope         = "Dope"
	TypeEvent        = "Event"
	TypeHustler      = "Hustler"
	TypeItem         = "Item"
	TypeListing      = "Listing"
	TypePaymentToken = "PaymentToken"
	TypeSyncState    = "SyncState"
	TypeWallet       = "Wallet"
	TypeWalletItems  = "WalletItems"
)

// AssetMutation represents an operation that mutates the Asset nodes in the graph.
type AssetMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	address             *string
	_type               *asset.Type
	symbol              *string
	amount              *schema.BigInt
	addamount           *schema.BigInt
	assetId             *schema.BigInt
	addassetId          *schema.BigInt
	price               *float64
	addprice            *float64
	clearedFields       map[string]struct{}
	paymentToken        map[string]struct{}
	removedpaymentToken map[string]struct{}
	clearedpaymentToken bool
	done                bool
	oldValue            func(context.Context) (*Asset, error)
	predicates          []predicate.Asset
}

var _ ent.Mutation = (*AssetMutation)(nil)

// assetOption allows management of the mutation configuration using functional options.
type assetOption func(*AssetMutation)

// newAssetMutation creates new mutation for the Asset entity.
func newAssetMutation(c config, op Op, opts ...assetOption) *AssetMutation {
	m := &AssetMutation{
		config:        c,
		op:            op,
		typ:           TypeAsset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetID sets the ID field of the mutation.
func withAssetID(id string) assetOption {
	return func(m *AssetMutation) {
		var (
			err   error
			once  sync.Once
			value *Asset
		)
		m.oldValue = func(ctx context.Context) (*Asset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Asset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsset sets the old Asset of the mutation.
func withAsset(node *Asset) assetOption {
	return func(m *AssetMutation) {
		m.oldValue = func(context.Context) (*Asset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Asset entities.
func (m *AssetMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Asset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAddress sets the "address" field.
func (m *AssetMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AssetMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *AssetMutation) ResetAddress() {
	m.address = nil
}

// SetType sets the "type" field.
func (m *AssetMutation) SetType(a asset.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AssetMutation) GetType() (r asset.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldType(ctx context.Context) (v asset.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AssetMutation) ResetType() {
	m._type = nil
}

// SetSymbol sets the "symbol" field.
func (m *AssetMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *AssetMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *AssetMutation) ResetSymbol() {
	m.symbol = nil
}

// SetAmount sets the "amount" field.
func (m *AssetMutation) SetAmount(si schema.BigInt) {
	m.amount = &si
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *AssetMutation) Amount() (r schema.BigInt, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldAmount(ctx context.Context) (v schema.BigInt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds si to the "amount" field.
func (m *AssetMutation) AddAmount(si schema.BigInt) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(si)
	} else {
		m.addamount = &si
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *AssetMutation) AddedAmount() (r schema.BigInt, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *AssetMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetAssetId sets the "assetId" field.
func (m *AssetMutation) SetAssetId(si schema.BigInt) {
	m.assetId = &si
	m.addassetId = nil
}

// AssetId returns the value of the "assetId" field in the mutation.
func (m *AssetMutation) AssetId() (r schema.BigInt, exists bool) {
	v := m.assetId
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetId returns the old "assetId" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldAssetId(ctx context.Context) (v schema.BigInt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetId: %w", err)
	}
	return oldValue.AssetId, nil
}

// AddAssetId adds si to the "assetId" field.
func (m *AssetMutation) AddAssetId(si schema.BigInt) {
	if m.addassetId != nil {
		*m.addassetId = m.addassetId.Add(si)
	} else {
		m.addassetId = &si
	}
}

// AddedAssetId returns the value that was added to the "assetId" field in this mutation.
func (m *AssetMutation) AddedAssetId() (r schema.BigInt, exists bool) {
	v := m.addassetId
	if v == nil {
		return
	}
	return *v, true
}

// ResetAssetId resets all changes to the "assetId" field.
func (m *AssetMutation) ResetAssetId() {
	m.assetId = nil
	m.addassetId = nil
}

// SetPrice sets the "price" field.
func (m *AssetMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *AssetMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *AssetMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *AssetMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *AssetMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// AddPaymentTokenIDs adds the "paymentToken" edge to the PaymentToken entity by ids.
func (m *AssetMutation) AddPaymentTokenIDs(ids ...string) {
	if m.paymentToken == nil {
		m.paymentToken = make(map[string]struct{})
	}
	for i := range ids {
		m.paymentToken[ids[i]] = struct{}{}
	}
}

// ClearPaymentToken clears the "paymentToken" edge to the PaymentToken entity.
func (m *AssetMutation) ClearPaymentToken() {
	m.clearedpaymentToken = true
}

// PaymentTokenCleared reports if the "paymentToken" edge to the PaymentToken entity was cleared.
func (m *AssetMutation) PaymentTokenCleared() bool {
	return m.clearedpaymentToken
}

// RemovePaymentTokenIDs removes the "paymentToken" edge to the PaymentToken entity by IDs.
func (m *AssetMutation) RemovePaymentTokenIDs(ids ...string) {
	if m.removedpaymentToken == nil {
		m.removedpaymentToken = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.paymentToken, ids[i])
		m.removedpaymentToken[ids[i]] = struct{}{}
	}
}

// RemovedPaymentToken returns the removed IDs of the "paymentToken" edge to the PaymentToken entity.
func (m *AssetMutation) RemovedPaymentTokenIDs() (ids []string) {
	for id := range m.removedpaymentToken {
		ids = append(ids, id)
	}
	return
}

// PaymentTokenIDs returns the "paymentToken" edge IDs in the mutation.
func (m *AssetMutation) PaymentTokenIDs() (ids []string) {
	for id := range m.paymentToken {
		ids = append(ids, id)
	}
	return
}

// ResetPaymentToken resets all changes to the "paymentToken" edge.
func (m *AssetMutation) ResetPaymentToken() {
	m.paymentToken = nil
	m.clearedpaymentToken = false
	m.removedpaymentToken = nil
}

// Where appends a list predicates to the AssetMutation builder.
func (m *AssetMutation) Where(ps ...predicate.Asset) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AssetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Asset).
func (m *AssetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.address != nil {
		fields = append(fields, asset.FieldAddress)
	}
	if m._type != nil {
		fields = append(fields, asset.FieldType)
	}
	if m.symbol != nil {
		fields = append(fields, asset.FieldSymbol)
	}
	if m.amount != nil {
		fields = append(fields, asset.FieldAmount)
	}
	if m.assetId != nil {
		fields = append(fields, asset.FieldAssetId)
	}
	if m.price != nil {
		fields = append(fields, asset.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asset.FieldAddress:
		return m.Address()
	case asset.FieldType:
		return m.GetType()
	case asset.FieldSymbol:
		return m.Symbol()
	case asset.FieldAmount:
		return m.Amount()
	case asset.FieldAssetId:
		return m.AssetId()
	case asset.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asset.FieldAddress:
		return m.OldAddress(ctx)
	case asset.FieldType:
		return m.OldType(ctx)
	case asset.FieldSymbol:
		return m.OldSymbol(ctx)
	case asset.FieldAmount:
		return m.OldAmount(ctx)
	case asset.FieldAssetId:
		return m.OldAssetId(ctx)
	case asset.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown Asset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asset.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case asset.FieldType:
		v, ok := value.(asset.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case asset.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case asset.FieldAmount:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case asset.FieldAssetId:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetId(v)
		return nil
	case asset.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, asset.FieldAmount)
	}
	if m.addassetId != nil {
		fields = append(fields, asset.FieldAssetId)
	}
	if m.addprice != nil {
		fields = append(fields, asset.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asset.FieldAmount:
		return m.AddedAmount()
	case asset.FieldAssetId:
		return m.AddedAssetId()
	case asset.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asset.FieldAmount:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case asset.FieldAssetId:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssetId(v)
		return nil
	case asset.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Asset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Asset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetMutation) ResetField(name string) error {
	switch name {
	case asset.FieldAddress:
		m.ResetAddress()
		return nil
	case asset.FieldType:
		m.ResetType()
		return nil
	case asset.FieldSymbol:
		m.ResetSymbol()
		return nil
	case asset.FieldAmount:
		m.ResetAmount()
		return nil
	case asset.FieldAssetId:
		m.ResetAssetId()
		return nil
	case asset.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.paymentToken != nil {
		edges = append(edges, asset.EdgePaymentToken)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgePaymentToken:
		ids := make([]ent.Value, 0, len(m.paymentToken))
		for id := range m.paymentToken {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpaymentToken != nil {
		edges = append(edges, asset.EdgePaymentToken)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgePaymentToken:
		ids := make([]ent.Value, 0, len(m.removedpaymentToken))
		for id := range m.removedpaymentToken {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpaymentToken {
		edges = append(edges, asset.EdgePaymentToken)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetMutation) EdgeCleared(name string) bool {
	switch name {
	case asset.EdgePaymentToken:
		return m.clearedpaymentToken
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Asset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetMutation) ResetEdge(name string) error {
	switch name {
	case asset.EdgePaymentToken:
		m.ResetPaymentToken()
		return nil
	}
	return fmt.Errorf("unknown Asset edge %s", name)
}

// BodyPartMutation represents an operation that mutates the BodyPart nodes in the graph.
type BodyPartMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	_type                 *bodypart.Type
	sex                   *bodypart.Sex
	rle                   *string
	clearedFields         map[string]struct{}
	hustler_bodies        map[string]struct{}
	removedhustler_bodies map[string]struct{}
	clearedhustler_bodies bool
	hustler_hairs         map[string]struct{}
	removedhustler_hairs  map[string]struct{}
	clearedhustler_hairs  bool
	hustler_beards        map[string]struct{}
	removedhustler_beards map[string]struct{}
	clearedhustler_beards bool
	done                  bool
	oldValue              func(context.Context) (*BodyPart, error)
	predicates            []predicate.BodyPart
}

var _ ent.Mutation = (*BodyPartMutation)(nil)

// bodypartOption allows management of the mutation configuration using functional options.
type bodypartOption func(*BodyPartMutation)

// newBodyPartMutation creates new mutation for the BodyPart entity.
func newBodyPartMutation(c config, op Op, opts ...bodypartOption) *BodyPartMutation {
	m := &BodyPartMutation{
		config:        c,
		op:            op,
		typ:           TypeBodyPart,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBodyPartID sets the ID field of the mutation.
func withBodyPartID(id string) bodypartOption {
	return func(m *BodyPartMutation) {
		var (
			err   error
			once  sync.Once
			value *BodyPart
		)
		m.oldValue = func(ctx context.Context) (*BodyPart, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BodyPart.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBodyPart sets the old BodyPart of the mutation.
func withBodyPart(node *BodyPart) bodypartOption {
	return func(m *BodyPartMutation) {
		m.oldValue = func(context.Context) (*BodyPart, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BodyPartMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BodyPartMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BodyPart entities.
func (m *BodyPartMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BodyPartMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BodyPartMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BodyPart.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *BodyPartMutation) SetType(b bodypart.Type) {
	m._type = &b
}

// GetType returns the value of the "type" field in the mutation.
func (m *BodyPartMutation) GetType() (r bodypart.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BodyPart entity.
// If the BodyPart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BodyPartMutation) OldType(ctx context.Context) (v bodypart.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BodyPartMutation) ResetType() {
	m._type = nil
}

// SetSex sets the "sex" field.
func (m *BodyPartMutation) SetSex(b bodypart.Sex) {
	m.sex = &b
}

// Sex returns the value of the "sex" field in the mutation.
func (m *BodyPartMutation) Sex() (r bodypart.Sex, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the BodyPart entity.
// If the BodyPart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BodyPartMutation) OldSex(ctx context.Context) (v bodypart.Sex, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// ResetSex resets all changes to the "sex" field.
func (m *BodyPartMutation) ResetSex() {
	m.sex = nil
}

// SetRle sets the "rle" field.
func (m *BodyPartMutation) SetRle(s string) {
	m.rle = &s
}

// Rle returns the value of the "rle" field in the mutation.
func (m *BodyPartMutation) Rle() (r string, exists bool) {
	v := m.rle
	if v == nil {
		return
	}
	return *v, true
}

// OldRle returns the old "rle" field's value of the BodyPart entity.
// If the BodyPart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BodyPartMutation) OldRle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRle: %w", err)
	}
	return oldValue.Rle, nil
}

// ResetRle resets all changes to the "rle" field.
func (m *BodyPartMutation) ResetRle() {
	m.rle = nil
}

// AddHustlerBodyIDs adds the "hustler_bodies" edge to the Hustler entity by ids.
func (m *BodyPartMutation) AddHustlerBodyIDs(ids ...string) {
	if m.hustler_bodies == nil {
		m.hustler_bodies = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_bodies[ids[i]] = struct{}{}
	}
}

// ClearHustlerBodies clears the "hustler_bodies" edge to the Hustler entity.
func (m *BodyPartMutation) ClearHustlerBodies() {
	m.clearedhustler_bodies = true
}

// HustlerBodiesCleared reports if the "hustler_bodies" edge to the Hustler entity was cleared.
func (m *BodyPartMutation) HustlerBodiesCleared() bool {
	return m.clearedhustler_bodies
}

// RemoveHustlerBodyIDs removes the "hustler_bodies" edge to the Hustler entity by IDs.
func (m *BodyPartMutation) RemoveHustlerBodyIDs(ids ...string) {
	if m.removedhustler_bodies == nil {
		m.removedhustler_bodies = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_bodies, ids[i])
		m.removedhustler_bodies[ids[i]] = struct{}{}
	}
}

// RemovedHustlerBodies returns the removed IDs of the "hustler_bodies" edge to the Hustler entity.
func (m *BodyPartMutation) RemovedHustlerBodiesIDs() (ids []string) {
	for id := range m.removedhustler_bodies {
		ids = append(ids, id)
	}
	return
}

// HustlerBodiesIDs returns the "hustler_bodies" edge IDs in the mutation.
func (m *BodyPartMutation) HustlerBodiesIDs() (ids []string) {
	for id := range m.hustler_bodies {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerBodies resets all changes to the "hustler_bodies" edge.
func (m *BodyPartMutation) ResetHustlerBodies() {
	m.hustler_bodies = nil
	m.clearedhustler_bodies = false
	m.removedhustler_bodies = nil
}

// AddHustlerHairIDs adds the "hustler_hairs" edge to the Hustler entity by ids.
func (m *BodyPartMutation) AddHustlerHairIDs(ids ...string) {
	if m.hustler_hairs == nil {
		m.hustler_hairs = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_hairs[ids[i]] = struct{}{}
	}
}

// ClearHustlerHairs clears the "hustler_hairs" edge to the Hustler entity.
func (m *BodyPartMutation) ClearHustlerHairs() {
	m.clearedhustler_hairs = true
}

// HustlerHairsCleared reports if the "hustler_hairs" edge to the Hustler entity was cleared.
func (m *BodyPartMutation) HustlerHairsCleared() bool {
	return m.clearedhustler_hairs
}

// RemoveHustlerHairIDs removes the "hustler_hairs" edge to the Hustler entity by IDs.
func (m *BodyPartMutation) RemoveHustlerHairIDs(ids ...string) {
	if m.removedhustler_hairs == nil {
		m.removedhustler_hairs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_hairs, ids[i])
		m.removedhustler_hairs[ids[i]] = struct{}{}
	}
}

// RemovedHustlerHairs returns the removed IDs of the "hustler_hairs" edge to the Hustler entity.
func (m *BodyPartMutation) RemovedHustlerHairsIDs() (ids []string) {
	for id := range m.removedhustler_hairs {
		ids = append(ids, id)
	}
	return
}

// HustlerHairsIDs returns the "hustler_hairs" edge IDs in the mutation.
func (m *BodyPartMutation) HustlerHairsIDs() (ids []string) {
	for id := range m.hustler_hairs {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerHairs resets all changes to the "hustler_hairs" edge.
func (m *BodyPartMutation) ResetHustlerHairs() {
	m.hustler_hairs = nil
	m.clearedhustler_hairs = false
	m.removedhustler_hairs = nil
}

// AddHustlerBeardIDs adds the "hustler_beards" edge to the Hustler entity by ids.
func (m *BodyPartMutation) AddHustlerBeardIDs(ids ...string) {
	if m.hustler_beards == nil {
		m.hustler_beards = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_beards[ids[i]] = struct{}{}
	}
}

// ClearHustlerBeards clears the "hustler_beards" edge to the Hustler entity.
func (m *BodyPartMutation) ClearHustlerBeards() {
	m.clearedhustler_beards = true
}

// HustlerBeardsCleared reports if the "hustler_beards" edge to the Hustler entity was cleared.
func (m *BodyPartMutation) HustlerBeardsCleared() bool {
	return m.clearedhustler_beards
}

// RemoveHustlerBeardIDs removes the "hustler_beards" edge to the Hustler entity by IDs.
func (m *BodyPartMutation) RemoveHustlerBeardIDs(ids ...string) {
	if m.removedhustler_beards == nil {
		m.removedhustler_beards = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_beards, ids[i])
		m.removedhustler_beards[ids[i]] = struct{}{}
	}
}

// RemovedHustlerBeards returns the removed IDs of the "hustler_beards" edge to the Hustler entity.
func (m *BodyPartMutation) RemovedHustlerBeardsIDs() (ids []string) {
	for id := range m.removedhustler_beards {
		ids = append(ids, id)
	}
	return
}

// HustlerBeardsIDs returns the "hustler_beards" edge IDs in the mutation.
func (m *BodyPartMutation) HustlerBeardsIDs() (ids []string) {
	for id := range m.hustler_beards {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerBeards resets all changes to the "hustler_beards" edge.
func (m *BodyPartMutation) ResetHustlerBeards() {
	m.hustler_beards = nil
	m.clearedhustler_beards = false
	m.removedhustler_beards = nil
}

// Where appends a list predicates to the BodyPartMutation builder.
func (m *BodyPartMutation) Where(ps ...predicate.BodyPart) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BodyPartMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BodyPart).
func (m *BodyPartMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BodyPartMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._type != nil {
		fields = append(fields, bodypart.FieldType)
	}
	if m.sex != nil {
		fields = append(fields, bodypart.FieldSex)
	}
	if m.rle != nil {
		fields = append(fields, bodypart.FieldRle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BodyPartMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bodypart.FieldType:
		return m.GetType()
	case bodypart.FieldSex:
		return m.Sex()
	case bodypart.FieldRle:
		return m.Rle()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BodyPartMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bodypart.FieldType:
		return m.OldType(ctx)
	case bodypart.FieldSex:
		return m.OldSex(ctx)
	case bodypart.FieldRle:
		return m.OldRle(ctx)
	}
	return nil, fmt.Errorf("unknown BodyPart field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BodyPartMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bodypart.FieldType:
		v, ok := value.(bodypart.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case bodypart.FieldSex:
		v, ok := value.(bodypart.Sex)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case bodypart.FieldRle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRle(v)
		return nil
	}
	return fmt.Errorf("unknown BodyPart field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BodyPartMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BodyPartMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BodyPartMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BodyPart numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BodyPartMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BodyPartMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BodyPartMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BodyPart nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BodyPartMutation) ResetField(name string) error {
	switch name {
	case bodypart.FieldType:
		m.ResetType()
		return nil
	case bodypart.FieldSex:
		m.ResetSex()
		return nil
	case bodypart.FieldRle:
		m.ResetRle()
		return nil
	}
	return fmt.Errorf("unknown BodyPart field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BodyPartMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.hustler_bodies != nil {
		edges = append(edges, bodypart.EdgeHustlerBodies)
	}
	if m.hustler_hairs != nil {
		edges = append(edges, bodypart.EdgeHustlerHairs)
	}
	if m.hustler_beards != nil {
		edges = append(edges, bodypart.EdgeHustlerBeards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BodyPartMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bodypart.EdgeHustlerBodies:
		ids := make([]ent.Value, 0, len(m.hustler_bodies))
		for id := range m.hustler_bodies {
			ids = append(ids, id)
		}
		return ids
	case bodypart.EdgeHustlerHairs:
		ids := make([]ent.Value, 0, len(m.hustler_hairs))
		for id := range m.hustler_hairs {
			ids = append(ids, id)
		}
		return ids
	case bodypart.EdgeHustlerBeards:
		ids := make([]ent.Value, 0, len(m.hustler_beards))
		for id := range m.hustler_beards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BodyPartMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedhustler_bodies != nil {
		edges = append(edges, bodypart.EdgeHustlerBodies)
	}
	if m.removedhustler_hairs != nil {
		edges = append(edges, bodypart.EdgeHustlerHairs)
	}
	if m.removedhustler_beards != nil {
		edges = append(edges, bodypart.EdgeHustlerBeards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BodyPartMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bodypart.EdgeHustlerBodies:
		ids := make([]ent.Value, 0, len(m.removedhustler_bodies))
		for id := range m.removedhustler_bodies {
			ids = append(ids, id)
		}
		return ids
	case bodypart.EdgeHustlerHairs:
		ids := make([]ent.Value, 0, len(m.removedhustler_hairs))
		for id := range m.removedhustler_hairs {
			ids = append(ids, id)
		}
		return ids
	case bodypart.EdgeHustlerBeards:
		ids := make([]ent.Value, 0, len(m.removedhustler_beards))
		for id := range m.removedhustler_beards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BodyPartMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedhustler_bodies {
		edges = append(edges, bodypart.EdgeHustlerBodies)
	}
	if m.clearedhustler_hairs {
		edges = append(edges, bodypart.EdgeHustlerHairs)
	}
	if m.clearedhustler_beards {
		edges = append(edges, bodypart.EdgeHustlerBeards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BodyPartMutation) EdgeCleared(name string) bool {
	switch name {
	case bodypart.EdgeHustlerBodies:
		return m.clearedhustler_bodies
	case bodypart.EdgeHustlerHairs:
		return m.clearedhustler_hairs
	case bodypart.EdgeHustlerBeards:
		return m.clearedhustler_beards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BodyPartMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BodyPart unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BodyPartMutation) ResetEdge(name string) error {
	switch name {
	case bodypart.EdgeHustlerBodies:
		m.ResetHustlerBodies()
		return nil
	case bodypart.EdgeHustlerHairs:
		m.ResetHustlerHairs()
		return nil
	case bodypart.EdgeHustlerBeards:
		m.ResetHustlerBeards()
		return nil
	}
	return fmt.Errorf("unknown BodyPart edge %s", name)
}

// DopeMutation represents an operation that mutates the Dope nodes in the graph.
type DopeMutation struct {
	config
	op              Op
	typ             string
	id              *string
	claimed         *bool
	opened          *bool
	score           *int
	addscore        *int
	rank            *int
	addrank         *int
	_order          *int
	add_order       *int
	clearedFields   map[string]struct{}
	wallet          *string
	clearedwallet   bool
	lastSale        *string
	clearedlastSale bool
	listings        map[string]struct{}
	removedlistings map[string]struct{}
	clearedlistings bool
	items           map[string]struct{}
	removeditems    map[string]struct{}
	cleareditems    bool
	done            bool
	oldValue        func(context.Context) (*Dope, error)
	predicates      []predicate.Dope
}

var _ ent.Mutation = (*DopeMutation)(nil)

// dopeOption allows management of the mutation configuration using functional options.
type dopeOption func(*DopeMutation)

// newDopeMutation creates new mutation for the Dope entity.
func newDopeMutation(c config, op Op, opts ...dopeOption) *DopeMutation {
	m := &DopeMutation{
		config:        c,
		op:            op,
		typ:           TypeDope,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDopeID sets the ID field of the mutation.
func withDopeID(id string) dopeOption {
	return func(m *DopeMutation) {
		var (
			err   error
			once  sync.Once
			value *Dope
		)
		m.oldValue = func(ctx context.Context) (*Dope, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dope.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDope sets the old Dope of the mutation.
func withDope(node *Dope) dopeOption {
	return func(m *DopeMutation) {
		m.oldValue = func(context.Context) (*Dope, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DopeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DopeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dope entities.
func (m *DopeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DopeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DopeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dope.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClaimed sets the "claimed" field.
func (m *DopeMutation) SetClaimed(b bool) {
	m.claimed = &b
}

// Claimed returns the value of the "claimed" field in the mutation.
func (m *DopeMutation) Claimed() (r bool, exists bool) {
	v := m.claimed
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimed returns the old "claimed" field's value of the Dope entity.
// If the Dope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DopeMutation) OldClaimed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimed: %w", err)
	}
	return oldValue.Claimed, nil
}

// ResetClaimed resets all changes to the "claimed" field.
func (m *DopeMutation) ResetClaimed() {
	m.claimed = nil
}

// SetOpened sets the "opened" field.
func (m *DopeMutation) SetOpened(b bool) {
	m.opened = &b
}

// Opened returns the value of the "opened" field in the mutation.
func (m *DopeMutation) Opened() (r bool, exists bool) {
	v := m.opened
	if v == nil {
		return
	}
	return *v, true
}

// OldOpened returns the old "opened" field's value of the Dope entity.
// If the Dope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DopeMutation) OldOpened(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpened is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpened requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpened: %w", err)
	}
	return oldValue.Opened, nil
}

// ResetOpened resets all changes to the "opened" field.
func (m *DopeMutation) ResetOpened() {
	m.opened = nil
}

// SetScore sets the "score" field.
func (m *DopeMutation) SetScore(i int) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *DopeMutation) Score() (r int, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Dope entity.
// If the Dope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DopeMutation) OldScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *DopeMutation) AddScore(i int) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *DopeMutation) AddedScore() (r int, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *DopeMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[dope.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *DopeMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[dope.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *DopeMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, dope.FieldScore)
}

// SetRank sets the "rank" field.
func (m *DopeMutation) SetRank(i int) {
	m.rank = &i
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *DopeMutation) Rank() (r int, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the Dope entity.
// If the Dope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DopeMutation) OldRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to the "rank" field.
func (m *DopeMutation) AddRank(i int) {
	if m.addrank != nil {
		*m.addrank += i
	} else {
		m.addrank = &i
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *DopeMutation) AddedRank() (r int, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ClearRank clears the value of the "rank" field.
func (m *DopeMutation) ClearRank() {
	m.rank = nil
	m.addrank = nil
	m.clearedFields[dope.FieldRank] = struct{}{}
}

// RankCleared returns if the "rank" field was cleared in this mutation.
func (m *DopeMutation) RankCleared() bool {
	_, ok := m.clearedFields[dope.FieldRank]
	return ok
}

// ResetRank resets all changes to the "rank" field.
func (m *DopeMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
	delete(m.clearedFields, dope.FieldRank)
}

// SetOrder sets the "order" field.
func (m *DopeMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *DopeMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Dope entity.
// If the Dope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DopeMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *DopeMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *DopeMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *DopeMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetWalletID sets the "wallet" edge to the Wallet entity by id.
func (m *DopeMutation) SetWalletID(id string) {
	m.wallet = &id
}

// ClearWallet clears the "wallet" edge to the Wallet entity.
func (m *DopeMutation) ClearWallet() {
	m.clearedwallet = true
}

// WalletCleared reports if the "wallet" edge to the Wallet entity was cleared.
func (m *DopeMutation) WalletCleared() bool {
	return m.clearedwallet
}

// WalletID returns the "wallet" edge ID in the mutation.
func (m *DopeMutation) WalletID() (id string, exists bool) {
	if m.wallet != nil {
		return *m.wallet, true
	}
	return
}

// WalletIDs returns the "wallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WalletID instead. It exists only for internal usage by the builders.
func (m *DopeMutation) WalletIDs() (ids []string) {
	if id := m.wallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWallet resets all changes to the "wallet" edge.
func (m *DopeMutation) ResetWallet() {
	m.wallet = nil
	m.clearedwallet = false
}

// SetLastSaleID sets the "lastSale" edge to the Listing entity by id.
func (m *DopeMutation) SetLastSaleID(id string) {
	m.lastSale = &id
}

// ClearLastSale clears the "lastSale" edge to the Listing entity.
func (m *DopeMutation) ClearLastSale() {
	m.clearedlastSale = true
}

// LastSaleCleared reports if the "lastSale" edge to the Listing entity was cleared.
func (m *DopeMutation) LastSaleCleared() bool {
	return m.clearedlastSale
}

// LastSaleID returns the "lastSale" edge ID in the mutation.
func (m *DopeMutation) LastSaleID() (id string, exists bool) {
	if m.lastSale != nil {
		return *m.lastSale, true
	}
	return
}

// LastSaleIDs returns the "lastSale" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LastSaleID instead. It exists only for internal usage by the builders.
func (m *DopeMutation) LastSaleIDs() (ids []string) {
	if id := m.lastSale; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLastSale resets all changes to the "lastSale" edge.
func (m *DopeMutation) ResetLastSale() {
	m.lastSale = nil
	m.clearedlastSale = false
}

// AddListingIDs adds the "listings" edge to the Listing entity by ids.
func (m *DopeMutation) AddListingIDs(ids ...string) {
	if m.listings == nil {
		m.listings = make(map[string]struct{})
	}
	for i := range ids {
		m.listings[ids[i]] = struct{}{}
	}
}

// ClearListings clears the "listings" edge to the Listing entity.
func (m *DopeMutation) ClearListings() {
	m.clearedlistings = true
}

// ListingsCleared reports if the "listings" edge to the Listing entity was cleared.
func (m *DopeMutation) ListingsCleared() bool {
	return m.clearedlistings
}

// RemoveListingIDs removes the "listings" edge to the Listing entity by IDs.
func (m *DopeMutation) RemoveListingIDs(ids ...string) {
	if m.removedlistings == nil {
		m.removedlistings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.listings, ids[i])
		m.removedlistings[ids[i]] = struct{}{}
	}
}

// RemovedListings returns the removed IDs of the "listings" edge to the Listing entity.
func (m *DopeMutation) RemovedListingsIDs() (ids []string) {
	for id := range m.removedlistings {
		ids = append(ids, id)
	}
	return
}

// ListingsIDs returns the "listings" edge IDs in the mutation.
func (m *DopeMutation) ListingsIDs() (ids []string) {
	for id := range m.listings {
		ids = append(ids, id)
	}
	return
}

// ResetListings resets all changes to the "listings" edge.
func (m *DopeMutation) ResetListings() {
	m.listings = nil
	m.clearedlistings = false
	m.removedlistings = nil
}

// AddItemIDs adds the "items" edge to the Item entity by ids.
func (m *DopeMutation) AddItemIDs(ids ...string) {
	if m.items == nil {
		m.items = make(map[string]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the Item entity.
func (m *DopeMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the Item entity was cleared.
func (m *DopeMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the Item entity by IDs.
func (m *DopeMutation) RemoveItemIDs(ids ...string) {
	if m.removeditems == nil {
		m.removeditems = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the Item entity.
func (m *DopeMutation) RemovedItemsIDs() (ids []string) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *DopeMutation) ItemsIDs() (ids []string) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *DopeMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// Where appends a list predicates to the DopeMutation builder.
func (m *DopeMutation) Where(ps ...predicate.Dope) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DopeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Dope).
func (m *DopeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DopeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.claimed != nil {
		fields = append(fields, dope.FieldClaimed)
	}
	if m.opened != nil {
		fields = append(fields, dope.FieldOpened)
	}
	if m.score != nil {
		fields = append(fields, dope.FieldScore)
	}
	if m.rank != nil {
		fields = append(fields, dope.FieldRank)
	}
	if m._order != nil {
		fields = append(fields, dope.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DopeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dope.FieldClaimed:
		return m.Claimed()
	case dope.FieldOpened:
		return m.Opened()
	case dope.FieldScore:
		return m.Score()
	case dope.FieldRank:
		return m.Rank()
	case dope.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DopeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dope.FieldClaimed:
		return m.OldClaimed(ctx)
	case dope.FieldOpened:
		return m.OldOpened(ctx)
	case dope.FieldScore:
		return m.OldScore(ctx)
	case dope.FieldRank:
		return m.OldRank(ctx)
	case dope.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Dope field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DopeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dope.FieldClaimed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimed(v)
		return nil
	case dope.FieldOpened:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpened(v)
		return nil
	case dope.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case dope.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case dope.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Dope field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DopeMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, dope.FieldScore)
	}
	if m.addrank != nil {
		fields = append(fields, dope.FieldRank)
	}
	if m.add_order != nil {
		fields = append(fields, dope.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DopeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dope.FieldScore:
		return m.AddedScore()
	case dope.FieldRank:
		return m.AddedRank()
	case dope.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DopeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dope.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case dope.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	case dope.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Dope numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DopeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dope.FieldScore) {
		fields = append(fields, dope.FieldScore)
	}
	if m.FieldCleared(dope.FieldRank) {
		fields = append(fields, dope.FieldRank)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DopeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DopeMutation) ClearField(name string) error {
	switch name {
	case dope.FieldScore:
		m.ClearScore()
		return nil
	case dope.FieldRank:
		m.ClearRank()
		return nil
	}
	return fmt.Errorf("unknown Dope nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DopeMutation) ResetField(name string) error {
	switch name {
	case dope.FieldClaimed:
		m.ResetClaimed()
		return nil
	case dope.FieldOpened:
		m.ResetOpened()
		return nil
	case dope.FieldScore:
		m.ResetScore()
		return nil
	case dope.FieldRank:
		m.ResetRank()
		return nil
	case dope.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Dope field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DopeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.wallet != nil {
		edges = append(edges, dope.EdgeWallet)
	}
	if m.lastSale != nil {
		edges = append(edges, dope.EdgeLastSale)
	}
	if m.listings != nil {
		edges = append(edges, dope.EdgeListings)
	}
	if m.items != nil {
		edges = append(edges, dope.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DopeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dope.EdgeWallet:
		if id := m.wallet; id != nil {
			return []ent.Value{*id}
		}
	case dope.EdgeLastSale:
		if id := m.lastSale; id != nil {
			return []ent.Value{*id}
		}
	case dope.EdgeListings:
		ids := make([]ent.Value, 0, len(m.listings))
		for id := range m.listings {
			ids = append(ids, id)
		}
		return ids
	case dope.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DopeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedlistings != nil {
		edges = append(edges, dope.EdgeListings)
	}
	if m.removeditems != nil {
		edges = append(edges, dope.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DopeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dope.EdgeListings:
		ids := make([]ent.Value, 0, len(m.removedlistings))
		for id := range m.removedlistings {
			ids = append(ids, id)
		}
		return ids
	case dope.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DopeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedwallet {
		edges = append(edges, dope.EdgeWallet)
	}
	if m.clearedlastSale {
		edges = append(edges, dope.EdgeLastSale)
	}
	if m.clearedlistings {
		edges = append(edges, dope.EdgeListings)
	}
	if m.cleareditems {
		edges = append(edges, dope.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DopeMutation) EdgeCleared(name string) bool {
	switch name {
	case dope.EdgeWallet:
		return m.clearedwallet
	case dope.EdgeLastSale:
		return m.clearedlastSale
	case dope.EdgeListings:
		return m.clearedlistings
	case dope.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DopeMutation) ClearEdge(name string) error {
	switch name {
	case dope.EdgeWallet:
		m.ClearWallet()
		return nil
	case dope.EdgeLastSale:
		m.ClearLastSale()
		return nil
	}
	return fmt.Errorf("unknown Dope unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DopeMutation) ResetEdge(name string) error {
	switch name {
	case dope.EdgeWallet:
		m.ResetWallet()
		return nil
	case dope.EdgeLastSale:
		m.ResetLastSale()
		return nil
	case dope.EdgeListings:
		m.ResetListings()
		return nil
	case dope.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown Dope edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op            Op
	typ           string
	id            *string
	address       *common.Address
	index         *uint64
	addindex      *int64
	hash          *common.Hash
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Event, error)
	predicates    []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id string) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAddress sets the "address" field.
func (m *EventMutation) SetAddress(c common.Address) {
	m.address = &c
}

// Address returns the value of the "address" field in the mutation.
func (m *EventMutation) Address() (r common.Address, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAddress(ctx context.Context) (v common.Address, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *EventMutation) ResetAddress() {
	m.address = nil
}

// SetIndex sets the "index" field.
func (m *EventMutation) SetIndex(u uint64) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *EventMutation) Index() (r uint64, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIndex(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *EventMutation) AddIndex(u int64) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *EventMutation) AddedIndex() (r int64, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *EventMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetHash sets the "hash" field.
func (m *EventMutation) SetHash(c common.Hash) {
	m.hash = &c
}

// Hash returns the value of the "hash" field in the mutation.
func (m *EventMutation) Hash() (r common.Hash, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldHash(ctx context.Context) (v common.Hash, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *EventMutation) ResetHash() {
	m.hash = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.address != nil {
		fields = append(fields, event.FieldAddress)
	}
	if m.index != nil {
		fields = append(fields, event.FieldIndex)
	}
	if m.hash != nil {
		fields = append(fields, event.FieldHash)
	}
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldAddress:
		return m.Address()
	case event.FieldIndex:
		return m.Index()
	case event.FieldHash:
		return m.Hash()
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldAddress:
		return m.OldAddress(ctx)
	case event.FieldIndex:
		return m.OldIndex(ctx)
	case event.FieldHash:
		return m.OldHash(ctx)
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldAddress:
		v, ok := value.(common.Address)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case event.FieldIndex:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case event.FieldHash:
		v, ok := value.(common.Hash)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, event.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldAddress:
		m.ResetAddress()
		return nil
	case event.FieldIndex:
		m.ResetIndex()
		return nil
	case event.FieldHash:
		m.ResetHash()
		return nil
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Event edge %s", name)
}

// HustlerMutation represents an operation that mutates the Hustler nodes in the graph.
type HustlerMutation struct {
	config
	op               Op
	typ              string
	id               *string
	_type            *hustler.Type
	name             *string
	title            *string
	color            *string
	background       *string
	age              *uint64
	addage           *int64
	sex              *hustler.Sex
	viewbox          *[]int
	_order           *[]int
	svg              *string
	created_at       *time.Time
	clearedFields    map[string]struct{}
	wallet           *string
	clearedwallet    bool
	weapon           *string
	clearedweapon    bool
	clothes          *string
	clearedclothes   bool
	vehicle          *string
	clearedvehicle   bool
	waist            *string
	clearedwaist     bool
	foot             *string
	clearedfoot      bool
	hand             *string
	clearedhand      bool
	drug             *string
	cleareddrug      bool
	neck             *string
	clearedneck      bool
	ring             *string
	clearedring      bool
	accessory        *string
	clearedaccessory bool
	body             *string
	clearedbody      bool
	hair             *string
	clearedhair      bool
	beard            *string
	clearedbeard     bool
	done             bool
	oldValue         func(context.Context) (*Hustler, error)
	predicates       []predicate.Hustler
}

var _ ent.Mutation = (*HustlerMutation)(nil)

// hustlerOption allows management of the mutation configuration using functional options.
type hustlerOption func(*HustlerMutation)

// newHustlerMutation creates new mutation for the Hustler entity.
func newHustlerMutation(c config, op Op, opts ...hustlerOption) *HustlerMutation {
	m := &HustlerMutation{
		config:        c,
		op:            op,
		typ:           TypeHustler,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHustlerID sets the ID field of the mutation.
func withHustlerID(id string) hustlerOption {
	return func(m *HustlerMutation) {
		var (
			err   error
			once  sync.Once
			value *Hustler
		)
		m.oldValue = func(ctx context.Context) (*Hustler, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hustler.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHustler sets the old Hustler of the mutation.
func withHustler(node *Hustler) hustlerOption {
	return func(m *HustlerMutation) {
		m.oldValue = func(context.Context) (*Hustler, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HustlerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HustlerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Hustler entities.
func (m *HustlerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HustlerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HustlerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Hustler.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *HustlerMutation) SetType(h hustler.Type) {
	m._type = &h
}

// GetType returns the value of the "type" field in the mutation.
func (m *HustlerMutation) GetType() (r hustler.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldType(ctx context.Context) (v hustler.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *HustlerMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *HustlerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HustlerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *HustlerMutation) ClearName() {
	m.name = nil
	m.clearedFields[hustler.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *HustlerMutation) NameCleared() bool {
	_, ok := m.clearedFields[hustler.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *HustlerMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, hustler.FieldName)
}

// SetTitle sets the "title" field.
func (m *HustlerMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *HustlerMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *HustlerMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[hustler.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *HustlerMutation) TitleCleared() bool {
	_, ok := m.clearedFields[hustler.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *HustlerMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, hustler.FieldTitle)
}

// SetColor sets the "color" field.
func (m *HustlerMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *HustlerMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *HustlerMutation) ClearColor() {
	m.color = nil
	m.clearedFields[hustler.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *HustlerMutation) ColorCleared() bool {
	_, ok := m.clearedFields[hustler.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *HustlerMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, hustler.FieldColor)
}

// SetBackground sets the "background" field.
func (m *HustlerMutation) SetBackground(s string) {
	m.background = &s
}

// Background returns the value of the "background" field in the mutation.
func (m *HustlerMutation) Background() (r string, exists bool) {
	v := m.background
	if v == nil {
		return
	}
	return *v, true
}

// OldBackground returns the old "background" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldBackground(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackground is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackground requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackground: %w", err)
	}
	return oldValue.Background, nil
}

// ClearBackground clears the value of the "background" field.
func (m *HustlerMutation) ClearBackground() {
	m.background = nil
	m.clearedFields[hustler.FieldBackground] = struct{}{}
}

// BackgroundCleared returns if the "background" field was cleared in this mutation.
func (m *HustlerMutation) BackgroundCleared() bool {
	_, ok := m.clearedFields[hustler.FieldBackground]
	return ok
}

// ResetBackground resets all changes to the "background" field.
func (m *HustlerMutation) ResetBackground() {
	m.background = nil
	delete(m.clearedFields, hustler.FieldBackground)
}

// SetAge sets the "age" field.
func (m *HustlerMutation) SetAge(u uint64) {
	m.age = &u
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *HustlerMutation) Age() (r uint64, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldAge(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds u to the "age" field.
func (m *HustlerMutation) AddAge(u int64) {
	if m.addage != nil {
		*m.addage += u
	} else {
		m.addage = &u
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *HustlerMutation) AddedAge() (r int64, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *HustlerMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetSex sets the "sex" field.
func (m *HustlerMutation) SetSex(h hustler.Sex) {
	m.sex = &h
}

// Sex returns the value of the "sex" field in the mutation.
func (m *HustlerMutation) Sex() (r hustler.Sex, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldSex(ctx context.Context) (v hustler.Sex, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// ResetSex resets all changes to the "sex" field.
func (m *HustlerMutation) ResetSex() {
	m.sex = nil
}

// SetViewbox sets the "viewbox" field.
func (m *HustlerMutation) SetViewbox(i []int) {
	m.viewbox = &i
}

// Viewbox returns the value of the "viewbox" field in the mutation.
func (m *HustlerMutation) Viewbox() (r []int, exists bool) {
	v := m.viewbox
	if v == nil {
		return
	}
	return *v, true
}

// OldViewbox returns the old "viewbox" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldViewbox(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewbox is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewbox requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewbox: %w", err)
	}
	return oldValue.Viewbox, nil
}

// ResetViewbox resets all changes to the "viewbox" field.
func (m *HustlerMutation) ResetViewbox() {
	m.viewbox = nil
}

// SetOrder sets the "order" field.
func (m *HustlerMutation) SetOrder(i []int) {
	m._order = &i
}

// Order returns the value of the "order" field in the mutation.
func (m *HustlerMutation) Order() (r []int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldOrder(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// ResetOrder resets all changes to the "order" field.
func (m *HustlerMutation) ResetOrder() {
	m._order = nil
}

// SetSvg sets the "svg" field.
func (m *HustlerMutation) SetSvg(s string) {
	m.svg = &s
}

// Svg returns the value of the "svg" field in the mutation.
func (m *HustlerMutation) Svg() (r string, exists bool) {
	v := m.svg
	if v == nil {
		return
	}
	return *v, true
}

// OldSvg returns the old "svg" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldSvg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSvg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSvg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSvg: %w", err)
	}
	return oldValue.Svg, nil
}

// ClearSvg clears the value of the "svg" field.
func (m *HustlerMutation) ClearSvg() {
	m.svg = nil
	m.clearedFields[hustler.FieldSvg] = struct{}{}
}

// SvgCleared returns if the "svg" field was cleared in this mutation.
func (m *HustlerMutation) SvgCleared() bool {
	_, ok := m.clearedFields[hustler.FieldSvg]
	return ok
}

// ResetSvg resets all changes to the "svg" field.
func (m *HustlerMutation) ResetSvg() {
	m.svg = nil
	delete(m.clearedFields, hustler.FieldSvg)
}

// SetCreatedAt sets the "created_at" field.
func (m *HustlerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HustlerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HustlerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetWalletID sets the "wallet" edge to the Wallet entity by id.
func (m *HustlerMutation) SetWalletID(id string) {
	m.wallet = &id
}

// ClearWallet clears the "wallet" edge to the Wallet entity.
func (m *HustlerMutation) ClearWallet() {
	m.clearedwallet = true
}

// WalletCleared reports if the "wallet" edge to the Wallet entity was cleared.
func (m *HustlerMutation) WalletCleared() bool {
	return m.clearedwallet
}

// WalletID returns the "wallet" edge ID in the mutation.
func (m *HustlerMutation) WalletID() (id string, exists bool) {
	if m.wallet != nil {
		return *m.wallet, true
	}
	return
}

// WalletIDs returns the "wallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WalletID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) WalletIDs() (ids []string) {
	if id := m.wallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWallet resets all changes to the "wallet" edge.
func (m *HustlerMutation) ResetWallet() {
	m.wallet = nil
	m.clearedwallet = false
}

// SetWeaponID sets the "weapon" edge to the Item entity by id.
func (m *HustlerMutation) SetWeaponID(id string) {
	m.weapon = &id
}

// ClearWeapon clears the "weapon" edge to the Item entity.
func (m *HustlerMutation) ClearWeapon() {
	m.clearedweapon = true
}

// WeaponCleared reports if the "weapon" edge to the Item entity was cleared.
func (m *HustlerMutation) WeaponCleared() bool {
	return m.clearedweapon
}

// WeaponID returns the "weapon" edge ID in the mutation.
func (m *HustlerMutation) WeaponID() (id string, exists bool) {
	if m.weapon != nil {
		return *m.weapon, true
	}
	return
}

// WeaponIDs returns the "weapon" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WeaponID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) WeaponIDs() (ids []string) {
	if id := m.weapon; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWeapon resets all changes to the "weapon" edge.
func (m *HustlerMutation) ResetWeapon() {
	m.weapon = nil
	m.clearedweapon = false
}

// SetClothesID sets the "clothes" edge to the Item entity by id.
func (m *HustlerMutation) SetClothesID(id string) {
	m.clothes = &id
}

// ClearClothes clears the "clothes" edge to the Item entity.
func (m *HustlerMutation) ClearClothes() {
	m.clearedclothes = true
}

// ClothesCleared reports if the "clothes" edge to the Item entity was cleared.
func (m *HustlerMutation) ClothesCleared() bool {
	return m.clearedclothes
}

// ClothesID returns the "clothes" edge ID in the mutation.
func (m *HustlerMutation) ClothesID() (id string, exists bool) {
	if m.clothes != nil {
		return *m.clothes, true
	}
	return
}

// ClothesIDs returns the "clothes" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClothesID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) ClothesIDs() (ids []string) {
	if id := m.clothes; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClothes resets all changes to the "clothes" edge.
func (m *HustlerMutation) ResetClothes() {
	m.clothes = nil
	m.clearedclothes = false
}

// SetVehicleID sets the "vehicle" edge to the Item entity by id.
func (m *HustlerMutation) SetVehicleID(id string) {
	m.vehicle = &id
}

// ClearVehicle clears the "vehicle" edge to the Item entity.
func (m *HustlerMutation) ClearVehicle() {
	m.clearedvehicle = true
}

// VehicleCleared reports if the "vehicle" edge to the Item entity was cleared.
func (m *HustlerMutation) VehicleCleared() bool {
	return m.clearedvehicle
}

// VehicleID returns the "vehicle" edge ID in the mutation.
func (m *HustlerMutation) VehicleID() (id string, exists bool) {
	if m.vehicle != nil {
		return *m.vehicle, true
	}
	return
}

// VehicleIDs returns the "vehicle" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VehicleID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) VehicleIDs() (ids []string) {
	if id := m.vehicle; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVehicle resets all changes to the "vehicle" edge.
func (m *HustlerMutation) ResetVehicle() {
	m.vehicle = nil
	m.clearedvehicle = false
}

// SetWaistID sets the "waist" edge to the Item entity by id.
func (m *HustlerMutation) SetWaistID(id string) {
	m.waist = &id
}

// ClearWaist clears the "waist" edge to the Item entity.
func (m *HustlerMutation) ClearWaist() {
	m.clearedwaist = true
}

// WaistCleared reports if the "waist" edge to the Item entity was cleared.
func (m *HustlerMutation) WaistCleared() bool {
	return m.clearedwaist
}

// WaistID returns the "waist" edge ID in the mutation.
func (m *HustlerMutation) WaistID() (id string, exists bool) {
	if m.waist != nil {
		return *m.waist, true
	}
	return
}

// WaistIDs returns the "waist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WaistID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) WaistIDs() (ids []string) {
	if id := m.waist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWaist resets all changes to the "waist" edge.
func (m *HustlerMutation) ResetWaist() {
	m.waist = nil
	m.clearedwaist = false
}

// SetFootID sets the "foot" edge to the Item entity by id.
func (m *HustlerMutation) SetFootID(id string) {
	m.foot = &id
}

// ClearFoot clears the "foot" edge to the Item entity.
func (m *HustlerMutation) ClearFoot() {
	m.clearedfoot = true
}

// FootCleared reports if the "foot" edge to the Item entity was cleared.
func (m *HustlerMutation) FootCleared() bool {
	return m.clearedfoot
}

// FootID returns the "foot" edge ID in the mutation.
func (m *HustlerMutation) FootID() (id string, exists bool) {
	if m.foot != nil {
		return *m.foot, true
	}
	return
}

// FootIDs returns the "foot" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FootID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) FootIDs() (ids []string) {
	if id := m.foot; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFoot resets all changes to the "foot" edge.
func (m *HustlerMutation) ResetFoot() {
	m.foot = nil
	m.clearedfoot = false
}

// SetHandID sets the "hand" edge to the Item entity by id.
func (m *HustlerMutation) SetHandID(id string) {
	m.hand = &id
}

// ClearHand clears the "hand" edge to the Item entity.
func (m *HustlerMutation) ClearHand() {
	m.clearedhand = true
}

// HandCleared reports if the "hand" edge to the Item entity was cleared.
func (m *HustlerMutation) HandCleared() bool {
	return m.clearedhand
}

// HandID returns the "hand" edge ID in the mutation.
func (m *HustlerMutation) HandID() (id string, exists bool) {
	if m.hand != nil {
		return *m.hand, true
	}
	return
}

// HandIDs returns the "hand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HandID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) HandIDs() (ids []string) {
	if id := m.hand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHand resets all changes to the "hand" edge.
func (m *HustlerMutation) ResetHand() {
	m.hand = nil
	m.clearedhand = false
}

// SetDrugID sets the "drug" edge to the Item entity by id.
func (m *HustlerMutation) SetDrugID(id string) {
	m.drug = &id
}

// ClearDrug clears the "drug" edge to the Item entity.
func (m *HustlerMutation) ClearDrug() {
	m.cleareddrug = true
}

// DrugCleared reports if the "drug" edge to the Item entity was cleared.
func (m *HustlerMutation) DrugCleared() bool {
	return m.cleareddrug
}

// DrugID returns the "drug" edge ID in the mutation.
func (m *HustlerMutation) DrugID() (id string, exists bool) {
	if m.drug != nil {
		return *m.drug, true
	}
	return
}

// DrugIDs returns the "drug" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DrugID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) DrugIDs() (ids []string) {
	if id := m.drug; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDrug resets all changes to the "drug" edge.
func (m *HustlerMutation) ResetDrug() {
	m.drug = nil
	m.cleareddrug = false
}

// SetNeckID sets the "neck" edge to the Item entity by id.
func (m *HustlerMutation) SetNeckID(id string) {
	m.neck = &id
}

// ClearNeck clears the "neck" edge to the Item entity.
func (m *HustlerMutation) ClearNeck() {
	m.clearedneck = true
}

// NeckCleared reports if the "neck" edge to the Item entity was cleared.
func (m *HustlerMutation) NeckCleared() bool {
	return m.clearedneck
}

// NeckID returns the "neck" edge ID in the mutation.
func (m *HustlerMutation) NeckID() (id string, exists bool) {
	if m.neck != nil {
		return *m.neck, true
	}
	return
}

// NeckIDs returns the "neck" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NeckID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) NeckIDs() (ids []string) {
	if id := m.neck; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNeck resets all changes to the "neck" edge.
func (m *HustlerMutation) ResetNeck() {
	m.neck = nil
	m.clearedneck = false
}

// SetRingID sets the "ring" edge to the Item entity by id.
func (m *HustlerMutation) SetRingID(id string) {
	m.ring = &id
}

// ClearRing clears the "ring" edge to the Item entity.
func (m *HustlerMutation) ClearRing() {
	m.clearedring = true
}

// RingCleared reports if the "ring" edge to the Item entity was cleared.
func (m *HustlerMutation) RingCleared() bool {
	return m.clearedring
}

// RingID returns the "ring" edge ID in the mutation.
func (m *HustlerMutation) RingID() (id string, exists bool) {
	if m.ring != nil {
		return *m.ring, true
	}
	return
}

// RingIDs returns the "ring" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RingID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) RingIDs() (ids []string) {
	if id := m.ring; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRing resets all changes to the "ring" edge.
func (m *HustlerMutation) ResetRing() {
	m.ring = nil
	m.clearedring = false
}

// SetAccessoryID sets the "accessory" edge to the Item entity by id.
func (m *HustlerMutation) SetAccessoryID(id string) {
	m.accessory = &id
}

// ClearAccessory clears the "accessory" edge to the Item entity.
func (m *HustlerMutation) ClearAccessory() {
	m.clearedaccessory = true
}

// AccessoryCleared reports if the "accessory" edge to the Item entity was cleared.
func (m *HustlerMutation) AccessoryCleared() bool {
	return m.clearedaccessory
}

// AccessoryID returns the "accessory" edge ID in the mutation.
func (m *HustlerMutation) AccessoryID() (id string, exists bool) {
	if m.accessory != nil {
		return *m.accessory, true
	}
	return
}

// AccessoryIDs returns the "accessory" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccessoryID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) AccessoryIDs() (ids []string) {
	if id := m.accessory; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccessory resets all changes to the "accessory" edge.
func (m *HustlerMutation) ResetAccessory() {
	m.accessory = nil
	m.clearedaccessory = false
}

// SetBodyID sets the "body" edge to the BodyPart entity by id.
func (m *HustlerMutation) SetBodyID(id string) {
	m.body = &id
}

// ClearBody clears the "body" edge to the BodyPart entity.
func (m *HustlerMutation) ClearBody() {
	m.clearedbody = true
}

// BodyCleared reports if the "body" edge to the BodyPart entity was cleared.
func (m *HustlerMutation) BodyCleared() bool {
	return m.clearedbody
}

// BodyID returns the "body" edge ID in the mutation.
func (m *HustlerMutation) BodyID() (id string, exists bool) {
	if m.body != nil {
		return *m.body, true
	}
	return
}

// BodyIDs returns the "body" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BodyID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) BodyIDs() (ids []string) {
	if id := m.body; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBody resets all changes to the "body" edge.
func (m *HustlerMutation) ResetBody() {
	m.body = nil
	m.clearedbody = false
}

// SetHairID sets the "hair" edge to the BodyPart entity by id.
func (m *HustlerMutation) SetHairID(id string) {
	m.hair = &id
}

// ClearHair clears the "hair" edge to the BodyPart entity.
func (m *HustlerMutation) ClearHair() {
	m.clearedhair = true
}

// HairCleared reports if the "hair" edge to the BodyPart entity was cleared.
func (m *HustlerMutation) HairCleared() bool {
	return m.clearedhair
}

// HairID returns the "hair" edge ID in the mutation.
func (m *HustlerMutation) HairID() (id string, exists bool) {
	if m.hair != nil {
		return *m.hair, true
	}
	return
}

// HairIDs returns the "hair" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HairID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) HairIDs() (ids []string) {
	if id := m.hair; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHair resets all changes to the "hair" edge.
func (m *HustlerMutation) ResetHair() {
	m.hair = nil
	m.clearedhair = false
}

// SetBeardID sets the "beard" edge to the BodyPart entity by id.
func (m *HustlerMutation) SetBeardID(id string) {
	m.beard = &id
}

// ClearBeard clears the "beard" edge to the BodyPart entity.
func (m *HustlerMutation) ClearBeard() {
	m.clearedbeard = true
}

// BeardCleared reports if the "beard" edge to the BodyPart entity was cleared.
func (m *HustlerMutation) BeardCleared() bool {
	return m.clearedbeard
}

// BeardID returns the "beard" edge ID in the mutation.
func (m *HustlerMutation) BeardID() (id string, exists bool) {
	if m.beard != nil {
		return *m.beard, true
	}
	return
}

// BeardIDs returns the "beard" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BeardID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) BeardIDs() (ids []string) {
	if id := m.beard; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBeard resets all changes to the "beard" edge.
func (m *HustlerMutation) ResetBeard() {
	m.beard = nil
	m.clearedbeard = false
}

// Where appends a list predicates to the HustlerMutation builder.
func (m *HustlerMutation) Where(ps ...predicate.Hustler) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HustlerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Hustler).
func (m *HustlerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HustlerMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m._type != nil {
		fields = append(fields, hustler.FieldType)
	}
	if m.name != nil {
		fields = append(fields, hustler.FieldName)
	}
	if m.title != nil {
		fields = append(fields, hustler.FieldTitle)
	}
	if m.color != nil {
		fields = append(fields, hustler.FieldColor)
	}
	if m.background != nil {
		fields = append(fields, hustler.FieldBackground)
	}
	if m.age != nil {
		fields = append(fields, hustler.FieldAge)
	}
	if m.sex != nil {
		fields = append(fields, hustler.FieldSex)
	}
	if m.viewbox != nil {
		fields = append(fields, hustler.FieldViewbox)
	}
	if m._order != nil {
		fields = append(fields, hustler.FieldOrder)
	}
	if m.svg != nil {
		fields = append(fields, hustler.FieldSvg)
	}
	if m.created_at != nil {
		fields = append(fields, hustler.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HustlerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hustler.FieldType:
		return m.GetType()
	case hustler.FieldName:
		return m.Name()
	case hustler.FieldTitle:
		return m.Title()
	case hustler.FieldColor:
		return m.Color()
	case hustler.FieldBackground:
		return m.Background()
	case hustler.FieldAge:
		return m.Age()
	case hustler.FieldSex:
		return m.Sex()
	case hustler.FieldViewbox:
		return m.Viewbox()
	case hustler.FieldOrder:
		return m.Order()
	case hustler.FieldSvg:
		return m.Svg()
	case hustler.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HustlerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hustler.FieldType:
		return m.OldType(ctx)
	case hustler.FieldName:
		return m.OldName(ctx)
	case hustler.FieldTitle:
		return m.OldTitle(ctx)
	case hustler.FieldColor:
		return m.OldColor(ctx)
	case hustler.FieldBackground:
		return m.OldBackground(ctx)
	case hustler.FieldAge:
		return m.OldAge(ctx)
	case hustler.FieldSex:
		return m.OldSex(ctx)
	case hustler.FieldViewbox:
		return m.OldViewbox(ctx)
	case hustler.FieldOrder:
		return m.OldOrder(ctx)
	case hustler.FieldSvg:
		return m.OldSvg(ctx)
	case hustler.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Hustler field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HustlerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hustler.FieldType:
		v, ok := value.(hustler.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case hustler.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hustler.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case hustler.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case hustler.FieldBackground:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackground(v)
		return nil
	case hustler.FieldAge:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case hustler.FieldSex:
		v, ok := value.(hustler.Sex)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case hustler.FieldViewbox:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewbox(v)
		return nil
	case hustler.FieldOrder:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case hustler.FieldSvg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSvg(v)
		return nil
	case hustler.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Hustler field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HustlerMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, hustler.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HustlerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hustler.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HustlerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hustler.FieldAge:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown Hustler numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HustlerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hustler.FieldName) {
		fields = append(fields, hustler.FieldName)
	}
	if m.FieldCleared(hustler.FieldTitle) {
		fields = append(fields, hustler.FieldTitle)
	}
	if m.FieldCleared(hustler.FieldColor) {
		fields = append(fields, hustler.FieldColor)
	}
	if m.FieldCleared(hustler.FieldBackground) {
		fields = append(fields, hustler.FieldBackground)
	}
	if m.FieldCleared(hustler.FieldSvg) {
		fields = append(fields, hustler.FieldSvg)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HustlerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HustlerMutation) ClearField(name string) error {
	switch name {
	case hustler.FieldName:
		m.ClearName()
		return nil
	case hustler.FieldTitle:
		m.ClearTitle()
		return nil
	case hustler.FieldColor:
		m.ClearColor()
		return nil
	case hustler.FieldBackground:
		m.ClearBackground()
		return nil
	case hustler.FieldSvg:
		m.ClearSvg()
		return nil
	}
	return fmt.Errorf("unknown Hustler nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HustlerMutation) ResetField(name string) error {
	switch name {
	case hustler.FieldType:
		m.ResetType()
		return nil
	case hustler.FieldName:
		m.ResetName()
		return nil
	case hustler.FieldTitle:
		m.ResetTitle()
		return nil
	case hustler.FieldColor:
		m.ResetColor()
		return nil
	case hustler.FieldBackground:
		m.ResetBackground()
		return nil
	case hustler.FieldAge:
		m.ResetAge()
		return nil
	case hustler.FieldSex:
		m.ResetSex()
		return nil
	case hustler.FieldViewbox:
		m.ResetViewbox()
		return nil
	case hustler.FieldOrder:
		m.ResetOrder()
		return nil
	case hustler.FieldSvg:
		m.ResetSvg()
		return nil
	case hustler.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Hustler field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HustlerMutation) AddedEdges() []string {
	edges := make([]string, 0, 14)
	if m.wallet != nil {
		edges = append(edges, hustler.EdgeWallet)
	}
	if m.weapon != nil {
		edges = append(edges, hustler.EdgeWeapon)
	}
	if m.clothes != nil {
		edges = append(edges, hustler.EdgeClothes)
	}
	if m.vehicle != nil {
		edges = append(edges, hustler.EdgeVehicle)
	}
	if m.waist != nil {
		edges = append(edges, hustler.EdgeWaist)
	}
	if m.foot != nil {
		edges = append(edges, hustler.EdgeFoot)
	}
	if m.hand != nil {
		edges = append(edges, hustler.EdgeHand)
	}
	if m.drug != nil {
		edges = append(edges, hustler.EdgeDrug)
	}
	if m.neck != nil {
		edges = append(edges, hustler.EdgeNeck)
	}
	if m.ring != nil {
		edges = append(edges, hustler.EdgeRing)
	}
	if m.accessory != nil {
		edges = append(edges, hustler.EdgeAccessory)
	}
	if m.body != nil {
		edges = append(edges, hustler.EdgeBody)
	}
	if m.hair != nil {
		edges = append(edges, hustler.EdgeHair)
	}
	if m.beard != nil {
		edges = append(edges, hustler.EdgeBeard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HustlerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hustler.EdgeWallet:
		if id := m.wallet; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeWeapon:
		if id := m.weapon; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeClothes:
		if id := m.clothes; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeVehicle:
		if id := m.vehicle; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeWaist:
		if id := m.waist; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeFoot:
		if id := m.foot; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeHand:
		if id := m.hand; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeDrug:
		if id := m.drug; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeNeck:
		if id := m.neck; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeRing:
		if id := m.ring; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeAccessory:
		if id := m.accessory; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeBody:
		if id := m.body; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeHair:
		if id := m.hair; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeBeard:
		if id := m.beard; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HustlerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 14)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HustlerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HustlerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 14)
	if m.clearedwallet {
		edges = append(edges, hustler.EdgeWallet)
	}
	if m.clearedweapon {
		edges = append(edges, hustler.EdgeWeapon)
	}
	if m.clearedclothes {
		edges = append(edges, hustler.EdgeClothes)
	}
	if m.clearedvehicle {
		edges = append(edges, hustler.EdgeVehicle)
	}
	if m.clearedwaist {
		edges = append(edges, hustler.EdgeWaist)
	}
	if m.clearedfoot {
		edges = append(edges, hustler.EdgeFoot)
	}
	if m.clearedhand {
		edges = append(edges, hustler.EdgeHand)
	}
	if m.cleareddrug {
		edges = append(edges, hustler.EdgeDrug)
	}
	if m.clearedneck {
		edges = append(edges, hustler.EdgeNeck)
	}
	if m.clearedring {
		edges = append(edges, hustler.EdgeRing)
	}
	if m.clearedaccessory {
		edges = append(edges, hustler.EdgeAccessory)
	}
	if m.clearedbody {
		edges = append(edges, hustler.EdgeBody)
	}
	if m.clearedhair {
		edges = append(edges, hustler.EdgeHair)
	}
	if m.clearedbeard {
		edges = append(edges, hustler.EdgeBeard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HustlerMutation) EdgeCleared(name string) bool {
	switch name {
	case hustler.EdgeWallet:
		return m.clearedwallet
	case hustler.EdgeWeapon:
		return m.clearedweapon
	case hustler.EdgeClothes:
		return m.clearedclothes
	case hustler.EdgeVehicle:
		return m.clearedvehicle
	case hustler.EdgeWaist:
		return m.clearedwaist
	case hustler.EdgeFoot:
		return m.clearedfoot
	case hustler.EdgeHand:
		return m.clearedhand
	case hustler.EdgeDrug:
		return m.cleareddrug
	case hustler.EdgeNeck:
		return m.clearedneck
	case hustler.EdgeRing:
		return m.clearedring
	case hustler.EdgeAccessory:
		return m.clearedaccessory
	case hustler.EdgeBody:
		return m.clearedbody
	case hustler.EdgeHair:
		return m.clearedhair
	case hustler.EdgeBeard:
		return m.clearedbeard
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HustlerMutation) ClearEdge(name string) error {
	switch name {
	case hustler.EdgeWallet:
		m.ClearWallet()
		return nil
	case hustler.EdgeWeapon:
		m.ClearWeapon()
		return nil
	case hustler.EdgeClothes:
		m.ClearClothes()
		return nil
	case hustler.EdgeVehicle:
		m.ClearVehicle()
		return nil
	case hustler.EdgeWaist:
		m.ClearWaist()
		return nil
	case hustler.EdgeFoot:
		m.ClearFoot()
		return nil
	case hustler.EdgeHand:
		m.ClearHand()
		return nil
	case hustler.EdgeDrug:
		m.ClearDrug()
		return nil
	case hustler.EdgeNeck:
		m.ClearNeck()
		return nil
	case hustler.EdgeRing:
		m.ClearRing()
		return nil
	case hustler.EdgeAccessory:
		m.ClearAccessory()
		return nil
	case hustler.EdgeBody:
		m.ClearBody()
		return nil
	case hustler.EdgeHair:
		m.ClearHair()
		return nil
	case hustler.EdgeBeard:
		m.ClearBeard()
		return nil
	}
	return fmt.Errorf("unknown Hustler unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HustlerMutation) ResetEdge(name string) error {
	switch name {
	case hustler.EdgeWallet:
		m.ResetWallet()
		return nil
	case hustler.EdgeWeapon:
		m.ResetWeapon()
		return nil
	case hustler.EdgeClothes:
		m.ResetClothes()
		return nil
	case hustler.EdgeVehicle:
		m.ResetVehicle()
		return nil
	case hustler.EdgeWaist:
		m.ResetWaist()
		return nil
	case hustler.EdgeFoot:
		m.ResetFoot()
		return nil
	case hustler.EdgeHand:
		m.ResetHand()
		return nil
	case hustler.EdgeDrug:
		m.ResetDrug()
		return nil
	case hustler.EdgeNeck:
		m.ResetNeck()
		return nil
	case hustler.EdgeRing:
		m.ResetRing()
		return nil
	case hustler.EdgeAccessory:
		m.ResetAccessory()
		return nil
	case hustler.EdgeBody:
		m.ResetBody()
		return nil
	case hustler.EdgeHair:
		m.ResetHair()
		return nil
	case hustler.EdgeBeard:
		m.ResetBeard()
		return nil
	}
	return fmt.Errorf("unknown Hustler edge %s", name)
}

// ItemMutation represents an operation that mutates the Item nodes in the graph.
type ItemMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	_type                      *item.Type
	name_prefix                *string
	name_suffix                *string
	name                       *string
	suffix                     *string
	augmented                  *bool
	count                      *int
	addcount                   *int
	tier                       *item.Tier
	greatness                  *int
	addgreatness               *int
	rles                       *schema.RLEs
	svg                        *string
	clearedFields              map[string]struct{}
	wallets                    map[string]struct{}
	removedwallets             map[string]struct{}
	clearedwallets             bool
	dopes                      map[string]struct{}
	removeddopes               map[string]struct{}
	cleareddopes               bool
	hustler_weapons            map[string]struct{}
	removedhustler_weapons     map[string]struct{}
	clearedhustler_weapons     bool
	hustler_clothes            map[string]struct{}
	removedhustler_clothes     map[string]struct{}
	clearedhustler_clothes     bool
	hustler_vehicles           map[string]struct{}
	removedhustler_vehicles    map[string]struct{}
	clearedhustler_vehicles    bool
	hustler_waists             map[string]struct{}
	removedhustler_waists      map[string]struct{}
	clearedhustler_waists      bool
	hustler_feet               map[string]struct{}
	removedhustler_feet        map[string]struct{}
	clearedhustler_feet        bool
	hustler_hands              map[string]struct{}
	removedhustler_hands       map[string]struct{}
	clearedhustler_hands       bool
	hustler_drugs              map[string]struct{}
	removedhustler_drugs       map[string]struct{}
	clearedhustler_drugs       bool
	hustler_necks              map[string]struct{}
	removedhustler_necks       map[string]struct{}
	clearedhustler_necks       bool
	hustler_rings              map[string]struct{}
	removedhustler_rings       map[string]struct{}
	clearedhustler_rings       bool
	hustler_accessories        map[string]struct{}
	removedhustler_accessories map[string]struct{}
	clearedhustler_accessories bool
	base                       *string
	clearedbase                bool
	derivative                 map[string]struct{}
	removedderivative          map[string]struct{}
	clearedderivative          bool
	done                       bool
	oldValue                   func(context.Context) (*Item, error)
	predicates                 []predicate.Item
}

var _ ent.Mutation = (*ItemMutation)(nil)

// itemOption allows management of the mutation configuration using functional options.
type itemOption func(*ItemMutation)

// newItemMutation creates new mutation for the Item entity.
func newItemMutation(c config, op Op, opts ...itemOption) *ItemMutation {
	m := &ItemMutation{
		config:        c,
		op:            op,
		typ:           TypeItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withItemID sets the ID field of the mutation.
func withItemID(id string) itemOption {
	return func(m *ItemMutation) {
		var (
			err   error
			once  sync.Once
			value *Item
		)
		m.oldValue = func(ctx context.Context) (*Item, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Item.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withItem sets the old Item of the mutation.
func withItem(node *Item) itemOption {
	return func(m *ItemMutation) {
		m.oldValue = func(context.Context) (*Item, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Item entities.
func (m *ItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Item.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ItemMutation) SetType(i item.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *ItemMutation) GetType() (r item.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldType(ctx context.Context) (v item.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ItemMutation) ResetType() {
	m._type = nil
}

// SetNamePrefix sets the "name_prefix" field.
func (m *ItemMutation) SetNamePrefix(s string) {
	m.name_prefix = &s
}

// NamePrefix returns the value of the "name_prefix" field in the mutation.
func (m *ItemMutation) NamePrefix() (r string, exists bool) {
	v := m.name_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldNamePrefix returns the old "name_prefix" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldNamePrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamePrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamePrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamePrefix: %w", err)
	}
	return oldValue.NamePrefix, nil
}

// ClearNamePrefix clears the value of the "name_prefix" field.
func (m *ItemMutation) ClearNamePrefix() {
	m.name_prefix = nil
	m.clearedFields[item.FieldNamePrefix] = struct{}{}
}

// NamePrefixCleared returns if the "name_prefix" field was cleared in this mutation.
func (m *ItemMutation) NamePrefixCleared() bool {
	_, ok := m.clearedFields[item.FieldNamePrefix]
	return ok
}

// ResetNamePrefix resets all changes to the "name_prefix" field.
func (m *ItemMutation) ResetNamePrefix() {
	m.name_prefix = nil
	delete(m.clearedFields, item.FieldNamePrefix)
}

// SetNameSuffix sets the "name_suffix" field.
func (m *ItemMutation) SetNameSuffix(s string) {
	m.name_suffix = &s
}

// NameSuffix returns the value of the "name_suffix" field in the mutation.
func (m *ItemMutation) NameSuffix() (r string, exists bool) {
	v := m.name_suffix
	if v == nil {
		return
	}
	return *v, true
}

// OldNameSuffix returns the old "name_suffix" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldNameSuffix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameSuffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameSuffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameSuffix: %w", err)
	}
	return oldValue.NameSuffix, nil
}

// ClearNameSuffix clears the value of the "name_suffix" field.
func (m *ItemMutation) ClearNameSuffix() {
	m.name_suffix = nil
	m.clearedFields[item.FieldNameSuffix] = struct{}{}
}

// NameSuffixCleared returns if the "name_suffix" field was cleared in this mutation.
func (m *ItemMutation) NameSuffixCleared() bool {
	_, ok := m.clearedFields[item.FieldNameSuffix]
	return ok
}

// ResetNameSuffix resets all changes to the "name_suffix" field.
func (m *ItemMutation) ResetNameSuffix() {
	m.name_suffix = nil
	delete(m.clearedFields, item.FieldNameSuffix)
}

// SetName sets the "name" field.
func (m *ItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ItemMutation) ResetName() {
	m.name = nil
}

// SetSuffix sets the "suffix" field.
func (m *ItemMutation) SetSuffix(s string) {
	m.suffix = &s
}

// Suffix returns the value of the "suffix" field in the mutation.
func (m *ItemMutation) Suffix() (r string, exists bool) {
	v := m.suffix
	if v == nil {
		return
	}
	return *v, true
}

// OldSuffix returns the old "suffix" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSuffix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuffix: %w", err)
	}
	return oldValue.Suffix, nil
}

// ClearSuffix clears the value of the "suffix" field.
func (m *ItemMutation) ClearSuffix() {
	m.suffix = nil
	m.clearedFields[item.FieldSuffix] = struct{}{}
}

// SuffixCleared returns if the "suffix" field was cleared in this mutation.
func (m *ItemMutation) SuffixCleared() bool {
	_, ok := m.clearedFields[item.FieldSuffix]
	return ok
}

// ResetSuffix resets all changes to the "suffix" field.
func (m *ItemMutation) ResetSuffix() {
	m.suffix = nil
	delete(m.clearedFields, item.FieldSuffix)
}

// SetAugmented sets the "augmented" field.
func (m *ItemMutation) SetAugmented(b bool) {
	m.augmented = &b
}

// Augmented returns the value of the "augmented" field in the mutation.
func (m *ItemMutation) Augmented() (r bool, exists bool) {
	v := m.augmented
	if v == nil {
		return
	}
	return *v, true
}

// OldAugmented returns the old "augmented" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldAugmented(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAugmented is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAugmented requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAugmented: %w", err)
	}
	return oldValue.Augmented, nil
}

// ClearAugmented clears the value of the "augmented" field.
func (m *ItemMutation) ClearAugmented() {
	m.augmented = nil
	m.clearedFields[item.FieldAugmented] = struct{}{}
}

// AugmentedCleared returns if the "augmented" field was cleared in this mutation.
func (m *ItemMutation) AugmentedCleared() bool {
	_, ok := m.clearedFields[item.FieldAugmented]
	return ok
}

// ResetAugmented resets all changes to the "augmented" field.
func (m *ItemMutation) ResetAugmented() {
	m.augmented = nil
	delete(m.clearedFields, item.FieldAugmented)
}

// SetCount sets the "count" field.
func (m *ItemMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *ItemMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *ItemMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *ItemMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ClearCount clears the value of the "count" field.
func (m *ItemMutation) ClearCount() {
	m.count = nil
	m.addcount = nil
	m.clearedFields[item.FieldCount] = struct{}{}
}

// CountCleared returns if the "count" field was cleared in this mutation.
func (m *ItemMutation) CountCleared() bool {
	_, ok := m.clearedFields[item.FieldCount]
	return ok
}

// ResetCount resets all changes to the "count" field.
func (m *ItemMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
	delete(m.clearedFields, item.FieldCount)
}

// SetTier sets the "tier" field.
func (m *ItemMutation) SetTier(i item.Tier) {
	m.tier = &i
}

// Tier returns the value of the "tier" field in the mutation.
func (m *ItemMutation) Tier() (r item.Tier, exists bool) {
	v := m.tier
	if v == nil {
		return
	}
	return *v, true
}

// OldTier returns the old "tier" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldTier(ctx context.Context) (v item.Tier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTier: %w", err)
	}
	return oldValue.Tier, nil
}

// ClearTier clears the value of the "tier" field.
func (m *ItemMutation) ClearTier() {
	m.tier = nil
	m.clearedFields[item.FieldTier] = struct{}{}
}

// TierCleared returns if the "tier" field was cleared in this mutation.
func (m *ItemMutation) TierCleared() bool {
	_, ok := m.clearedFields[item.FieldTier]
	return ok
}

// ResetTier resets all changes to the "tier" field.
func (m *ItemMutation) ResetTier() {
	m.tier = nil
	delete(m.clearedFields, item.FieldTier)
}

// SetGreatness sets the "greatness" field.
func (m *ItemMutation) SetGreatness(i int) {
	m.greatness = &i
	m.addgreatness = nil
}

// Greatness returns the value of the "greatness" field in the mutation.
func (m *ItemMutation) Greatness() (r int, exists bool) {
	v := m.greatness
	if v == nil {
		return
	}
	return *v, true
}

// OldGreatness returns the old "greatness" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldGreatness(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGreatness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGreatness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGreatness: %w", err)
	}
	return oldValue.Greatness, nil
}

// AddGreatness adds i to the "greatness" field.
func (m *ItemMutation) AddGreatness(i int) {
	if m.addgreatness != nil {
		*m.addgreatness += i
	} else {
		m.addgreatness = &i
	}
}

// AddedGreatness returns the value that was added to the "greatness" field in this mutation.
func (m *ItemMutation) AddedGreatness() (r int, exists bool) {
	v := m.addgreatness
	if v == nil {
		return
	}
	return *v, true
}

// ClearGreatness clears the value of the "greatness" field.
func (m *ItemMutation) ClearGreatness() {
	m.greatness = nil
	m.addgreatness = nil
	m.clearedFields[item.FieldGreatness] = struct{}{}
}

// GreatnessCleared returns if the "greatness" field was cleared in this mutation.
func (m *ItemMutation) GreatnessCleared() bool {
	_, ok := m.clearedFields[item.FieldGreatness]
	return ok
}

// ResetGreatness resets all changes to the "greatness" field.
func (m *ItemMutation) ResetGreatness() {
	m.greatness = nil
	m.addgreatness = nil
	delete(m.clearedFields, item.FieldGreatness)
}

// SetRles sets the "rles" field.
func (m *ItemMutation) SetRles(se schema.RLEs) {
	m.rles = &se
}

// Rles returns the value of the "rles" field in the mutation.
func (m *ItemMutation) Rles() (r schema.RLEs, exists bool) {
	v := m.rles
	if v == nil {
		return
	}
	return *v, true
}

// OldRles returns the old "rles" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldRles(ctx context.Context) (v schema.RLEs, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRles: %w", err)
	}
	return oldValue.Rles, nil
}

// ClearRles clears the value of the "rles" field.
func (m *ItemMutation) ClearRles() {
	m.rles = nil
	m.clearedFields[item.FieldRles] = struct{}{}
}

// RlesCleared returns if the "rles" field was cleared in this mutation.
func (m *ItemMutation) RlesCleared() bool {
	_, ok := m.clearedFields[item.FieldRles]
	return ok
}

// ResetRles resets all changes to the "rles" field.
func (m *ItemMutation) ResetRles() {
	m.rles = nil
	delete(m.clearedFields, item.FieldRles)
}

// SetSvg sets the "svg" field.
func (m *ItemMutation) SetSvg(s string) {
	m.svg = &s
}

// Svg returns the value of the "svg" field in the mutation.
func (m *ItemMutation) Svg() (r string, exists bool) {
	v := m.svg
	if v == nil {
		return
	}
	return *v, true
}

// OldSvg returns the old "svg" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSvg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSvg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSvg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSvg: %w", err)
	}
	return oldValue.Svg, nil
}

// ClearSvg clears the value of the "svg" field.
func (m *ItemMutation) ClearSvg() {
	m.svg = nil
	m.clearedFields[item.FieldSvg] = struct{}{}
}

// SvgCleared returns if the "svg" field was cleared in this mutation.
func (m *ItemMutation) SvgCleared() bool {
	_, ok := m.clearedFields[item.FieldSvg]
	return ok
}

// ResetSvg resets all changes to the "svg" field.
func (m *ItemMutation) ResetSvg() {
	m.svg = nil
	delete(m.clearedFields, item.FieldSvg)
}

// AddWalletIDs adds the "wallets" edge to the WalletItems entity by ids.
func (m *ItemMutation) AddWalletIDs(ids ...string) {
	if m.wallets == nil {
		m.wallets = make(map[string]struct{})
	}
	for i := range ids {
		m.wallets[ids[i]] = struct{}{}
	}
}

// ClearWallets clears the "wallets" edge to the WalletItems entity.
func (m *ItemMutation) ClearWallets() {
	m.clearedwallets = true
}

// WalletsCleared reports if the "wallets" edge to the WalletItems entity was cleared.
func (m *ItemMutation) WalletsCleared() bool {
	return m.clearedwallets
}

// RemoveWalletIDs removes the "wallets" edge to the WalletItems entity by IDs.
func (m *ItemMutation) RemoveWalletIDs(ids ...string) {
	if m.removedwallets == nil {
		m.removedwallets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.wallets, ids[i])
		m.removedwallets[ids[i]] = struct{}{}
	}
}

// RemovedWallets returns the removed IDs of the "wallets" edge to the WalletItems entity.
func (m *ItemMutation) RemovedWalletsIDs() (ids []string) {
	for id := range m.removedwallets {
		ids = append(ids, id)
	}
	return
}

// WalletsIDs returns the "wallets" edge IDs in the mutation.
func (m *ItemMutation) WalletsIDs() (ids []string) {
	for id := range m.wallets {
		ids = append(ids, id)
	}
	return
}

// ResetWallets resets all changes to the "wallets" edge.
func (m *ItemMutation) ResetWallets() {
	m.wallets = nil
	m.clearedwallets = false
	m.removedwallets = nil
}

// AddDopeIDs adds the "dopes" edge to the Dope entity by ids.
func (m *ItemMutation) AddDopeIDs(ids ...string) {
	if m.dopes == nil {
		m.dopes = make(map[string]struct{})
	}
	for i := range ids {
		m.dopes[ids[i]] = struct{}{}
	}
}

// ClearDopes clears the "dopes" edge to the Dope entity.
func (m *ItemMutation) ClearDopes() {
	m.cleareddopes = true
}

// DopesCleared reports if the "dopes" edge to the Dope entity was cleared.
func (m *ItemMutation) DopesCleared() bool {
	return m.cleareddopes
}

// RemoveDopeIDs removes the "dopes" edge to the Dope entity by IDs.
func (m *ItemMutation) RemoveDopeIDs(ids ...string) {
	if m.removeddopes == nil {
		m.removeddopes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dopes, ids[i])
		m.removeddopes[ids[i]] = struct{}{}
	}
}

// RemovedDopes returns the removed IDs of the "dopes" edge to the Dope entity.
func (m *ItemMutation) RemovedDopesIDs() (ids []string) {
	for id := range m.removeddopes {
		ids = append(ids, id)
	}
	return
}

// DopesIDs returns the "dopes" edge IDs in the mutation.
func (m *ItemMutation) DopesIDs() (ids []string) {
	for id := range m.dopes {
		ids = append(ids, id)
	}
	return
}

// ResetDopes resets all changes to the "dopes" edge.
func (m *ItemMutation) ResetDopes() {
	m.dopes = nil
	m.cleareddopes = false
	m.removeddopes = nil
}

// AddHustlerWeaponIDs adds the "hustler_weapons" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerWeaponIDs(ids ...string) {
	if m.hustler_weapons == nil {
		m.hustler_weapons = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_weapons[ids[i]] = struct{}{}
	}
}

// ClearHustlerWeapons clears the "hustler_weapons" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerWeapons() {
	m.clearedhustler_weapons = true
}

// HustlerWeaponsCleared reports if the "hustler_weapons" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerWeaponsCleared() bool {
	return m.clearedhustler_weapons
}

// RemoveHustlerWeaponIDs removes the "hustler_weapons" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerWeaponIDs(ids ...string) {
	if m.removedhustler_weapons == nil {
		m.removedhustler_weapons = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_weapons, ids[i])
		m.removedhustler_weapons[ids[i]] = struct{}{}
	}
}

// RemovedHustlerWeapons returns the removed IDs of the "hustler_weapons" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerWeaponsIDs() (ids []string) {
	for id := range m.removedhustler_weapons {
		ids = append(ids, id)
	}
	return
}

// HustlerWeaponsIDs returns the "hustler_weapons" edge IDs in the mutation.
func (m *ItemMutation) HustlerWeaponsIDs() (ids []string) {
	for id := range m.hustler_weapons {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerWeapons resets all changes to the "hustler_weapons" edge.
func (m *ItemMutation) ResetHustlerWeapons() {
	m.hustler_weapons = nil
	m.clearedhustler_weapons = false
	m.removedhustler_weapons = nil
}

// AddHustlerClotheIDs adds the "hustler_clothes" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerClotheIDs(ids ...string) {
	if m.hustler_clothes == nil {
		m.hustler_clothes = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_clothes[ids[i]] = struct{}{}
	}
}

// ClearHustlerClothes clears the "hustler_clothes" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerClothes() {
	m.clearedhustler_clothes = true
}

// HustlerClothesCleared reports if the "hustler_clothes" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerClothesCleared() bool {
	return m.clearedhustler_clothes
}

// RemoveHustlerClotheIDs removes the "hustler_clothes" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerClotheIDs(ids ...string) {
	if m.removedhustler_clothes == nil {
		m.removedhustler_clothes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_clothes, ids[i])
		m.removedhustler_clothes[ids[i]] = struct{}{}
	}
}

// RemovedHustlerClothes returns the removed IDs of the "hustler_clothes" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerClothesIDs() (ids []string) {
	for id := range m.removedhustler_clothes {
		ids = append(ids, id)
	}
	return
}

// HustlerClothesIDs returns the "hustler_clothes" edge IDs in the mutation.
func (m *ItemMutation) HustlerClothesIDs() (ids []string) {
	for id := range m.hustler_clothes {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerClothes resets all changes to the "hustler_clothes" edge.
func (m *ItemMutation) ResetHustlerClothes() {
	m.hustler_clothes = nil
	m.clearedhustler_clothes = false
	m.removedhustler_clothes = nil
}

// AddHustlerVehicleIDs adds the "hustler_vehicles" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerVehicleIDs(ids ...string) {
	if m.hustler_vehicles == nil {
		m.hustler_vehicles = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_vehicles[ids[i]] = struct{}{}
	}
}

// ClearHustlerVehicles clears the "hustler_vehicles" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerVehicles() {
	m.clearedhustler_vehicles = true
}

// HustlerVehiclesCleared reports if the "hustler_vehicles" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerVehiclesCleared() bool {
	return m.clearedhustler_vehicles
}

// RemoveHustlerVehicleIDs removes the "hustler_vehicles" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerVehicleIDs(ids ...string) {
	if m.removedhustler_vehicles == nil {
		m.removedhustler_vehicles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_vehicles, ids[i])
		m.removedhustler_vehicles[ids[i]] = struct{}{}
	}
}

// RemovedHustlerVehicles returns the removed IDs of the "hustler_vehicles" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerVehiclesIDs() (ids []string) {
	for id := range m.removedhustler_vehicles {
		ids = append(ids, id)
	}
	return
}

// HustlerVehiclesIDs returns the "hustler_vehicles" edge IDs in the mutation.
func (m *ItemMutation) HustlerVehiclesIDs() (ids []string) {
	for id := range m.hustler_vehicles {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerVehicles resets all changes to the "hustler_vehicles" edge.
func (m *ItemMutation) ResetHustlerVehicles() {
	m.hustler_vehicles = nil
	m.clearedhustler_vehicles = false
	m.removedhustler_vehicles = nil
}

// AddHustlerWaistIDs adds the "hustler_waists" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerWaistIDs(ids ...string) {
	if m.hustler_waists == nil {
		m.hustler_waists = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_waists[ids[i]] = struct{}{}
	}
}

// ClearHustlerWaists clears the "hustler_waists" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerWaists() {
	m.clearedhustler_waists = true
}

// HustlerWaistsCleared reports if the "hustler_waists" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerWaistsCleared() bool {
	return m.clearedhustler_waists
}

// RemoveHustlerWaistIDs removes the "hustler_waists" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerWaistIDs(ids ...string) {
	if m.removedhustler_waists == nil {
		m.removedhustler_waists = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_waists, ids[i])
		m.removedhustler_waists[ids[i]] = struct{}{}
	}
}

// RemovedHustlerWaists returns the removed IDs of the "hustler_waists" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerWaistsIDs() (ids []string) {
	for id := range m.removedhustler_waists {
		ids = append(ids, id)
	}
	return
}

// HustlerWaistsIDs returns the "hustler_waists" edge IDs in the mutation.
func (m *ItemMutation) HustlerWaistsIDs() (ids []string) {
	for id := range m.hustler_waists {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerWaists resets all changes to the "hustler_waists" edge.
func (m *ItemMutation) ResetHustlerWaists() {
	m.hustler_waists = nil
	m.clearedhustler_waists = false
	m.removedhustler_waists = nil
}

// AddHustlerFeetIDs adds the "hustler_feet" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerFeetIDs(ids ...string) {
	if m.hustler_feet == nil {
		m.hustler_feet = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_feet[ids[i]] = struct{}{}
	}
}

// ClearHustlerFeet clears the "hustler_feet" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerFeet() {
	m.clearedhustler_feet = true
}

// HustlerFeetCleared reports if the "hustler_feet" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerFeetCleared() bool {
	return m.clearedhustler_feet
}

// RemoveHustlerFeetIDs removes the "hustler_feet" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerFeetIDs(ids ...string) {
	if m.removedhustler_feet == nil {
		m.removedhustler_feet = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_feet, ids[i])
		m.removedhustler_feet[ids[i]] = struct{}{}
	}
}

// RemovedHustlerFeet returns the removed IDs of the "hustler_feet" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerFeetIDs() (ids []string) {
	for id := range m.removedhustler_feet {
		ids = append(ids, id)
	}
	return
}

// HustlerFeetIDs returns the "hustler_feet" edge IDs in the mutation.
func (m *ItemMutation) HustlerFeetIDs() (ids []string) {
	for id := range m.hustler_feet {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerFeet resets all changes to the "hustler_feet" edge.
func (m *ItemMutation) ResetHustlerFeet() {
	m.hustler_feet = nil
	m.clearedhustler_feet = false
	m.removedhustler_feet = nil
}

// AddHustlerHandIDs adds the "hustler_hands" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerHandIDs(ids ...string) {
	if m.hustler_hands == nil {
		m.hustler_hands = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_hands[ids[i]] = struct{}{}
	}
}

// ClearHustlerHands clears the "hustler_hands" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerHands() {
	m.clearedhustler_hands = true
}

// HustlerHandsCleared reports if the "hustler_hands" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerHandsCleared() bool {
	return m.clearedhustler_hands
}

// RemoveHustlerHandIDs removes the "hustler_hands" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerHandIDs(ids ...string) {
	if m.removedhustler_hands == nil {
		m.removedhustler_hands = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_hands, ids[i])
		m.removedhustler_hands[ids[i]] = struct{}{}
	}
}

// RemovedHustlerHands returns the removed IDs of the "hustler_hands" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerHandsIDs() (ids []string) {
	for id := range m.removedhustler_hands {
		ids = append(ids, id)
	}
	return
}

// HustlerHandsIDs returns the "hustler_hands" edge IDs in the mutation.
func (m *ItemMutation) HustlerHandsIDs() (ids []string) {
	for id := range m.hustler_hands {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerHands resets all changes to the "hustler_hands" edge.
func (m *ItemMutation) ResetHustlerHands() {
	m.hustler_hands = nil
	m.clearedhustler_hands = false
	m.removedhustler_hands = nil
}

// AddHustlerDrugIDs adds the "hustler_drugs" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerDrugIDs(ids ...string) {
	if m.hustler_drugs == nil {
		m.hustler_drugs = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_drugs[ids[i]] = struct{}{}
	}
}

// ClearHustlerDrugs clears the "hustler_drugs" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerDrugs() {
	m.clearedhustler_drugs = true
}

// HustlerDrugsCleared reports if the "hustler_drugs" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerDrugsCleared() bool {
	return m.clearedhustler_drugs
}

// RemoveHustlerDrugIDs removes the "hustler_drugs" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerDrugIDs(ids ...string) {
	if m.removedhustler_drugs == nil {
		m.removedhustler_drugs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_drugs, ids[i])
		m.removedhustler_drugs[ids[i]] = struct{}{}
	}
}

// RemovedHustlerDrugs returns the removed IDs of the "hustler_drugs" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerDrugsIDs() (ids []string) {
	for id := range m.removedhustler_drugs {
		ids = append(ids, id)
	}
	return
}

// HustlerDrugsIDs returns the "hustler_drugs" edge IDs in the mutation.
func (m *ItemMutation) HustlerDrugsIDs() (ids []string) {
	for id := range m.hustler_drugs {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerDrugs resets all changes to the "hustler_drugs" edge.
func (m *ItemMutation) ResetHustlerDrugs() {
	m.hustler_drugs = nil
	m.clearedhustler_drugs = false
	m.removedhustler_drugs = nil
}

// AddHustlerNeckIDs adds the "hustler_necks" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerNeckIDs(ids ...string) {
	if m.hustler_necks == nil {
		m.hustler_necks = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_necks[ids[i]] = struct{}{}
	}
}

// ClearHustlerNecks clears the "hustler_necks" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerNecks() {
	m.clearedhustler_necks = true
}

// HustlerNecksCleared reports if the "hustler_necks" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerNecksCleared() bool {
	return m.clearedhustler_necks
}

// RemoveHustlerNeckIDs removes the "hustler_necks" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerNeckIDs(ids ...string) {
	if m.removedhustler_necks == nil {
		m.removedhustler_necks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_necks, ids[i])
		m.removedhustler_necks[ids[i]] = struct{}{}
	}
}

// RemovedHustlerNecks returns the removed IDs of the "hustler_necks" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerNecksIDs() (ids []string) {
	for id := range m.removedhustler_necks {
		ids = append(ids, id)
	}
	return
}

// HustlerNecksIDs returns the "hustler_necks" edge IDs in the mutation.
func (m *ItemMutation) HustlerNecksIDs() (ids []string) {
	for id := range m.hustler_necks {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerNecks resets all changes to the "hustler_necks" edge.
func (m *ItemMutation) ResetHustlerNecks() {
	m.hustler_necks = nil
	m.clearedhustler_necks = false
	m.removedhustler_necks = nil
}

// AddHustlerRingIDs adds the "hustler_rings" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerRingIDs(ids ...string) {
	if m.hustler_rings == nil {
		m.hustler_rings = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_rings[ids[i]] = struct{}{}
	}
}

// ClearHustlerRings clears the "hustler_rings" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerRings() {
	m.clearedhustler_rings = true
}

// HustlerRingsCleared reports if the "hustler_rings" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerRingsCleared() bool {
	return m.clearedhustler_rings
}

// RemoveHustlerRingIDs removes the "hustler_rings" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerRingIDs(ids ...string) {
	if m.removedhustler_rings == nil {
		m.removedhustler_rings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_rings, ids[i])
		m.removedhustler_rings[ids[i]] = struct{}{}
	}
}

// RemovedHustlerRings returns the removed IDs of the "hustler_rings" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerRingsIDs() (ids []string) {
	for id := range m.removedhustler_rings {
		ids = append(ids, id)
	}
	return
}

// HustlerRingsIDs returns the "hustler_rings" edge IDs in the mutation.
func (m *ItemMutation) HustlerRingsIDs() (ids []string) {
	for id := range m.hustler_rings {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerRings resets all changes to the "hustler_rings" edge.
func (m *ItemMutation) ResetHustlerRings() {
	m.hustler_rings = nil
	m.clearedhustler_rings = false
	m.removedhustler_rings = nil
}

// AddHustlerAccessoryIDs adds the "hustler_accessories" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerAccessoryIDs(ids ...string) {
	if m.hustler_accessories == nil {
		m.hustler_accessories = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_accessories[ids[i]] = struct{}{}
	}
}

// ClearHustlerAccessories clears the "hustler_accessories" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerAccessories() {
	m.clearedhustler_accessories = true
}

// HustlerAccessoriesCleared reports if the "hustler_accessories" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerAccessoriesCleared() bool {
	return m.clearedhustler_accessories
}

// RemoveHustlerAccessoryIDs removes the "hustler_accessories" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerAccessoryIDs(ids ...string) {
	if m.removedhustler_accessories == nil {
		m.removedhustler_accessories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_accessories, ids[i])
		m.removedhustler_accessories[ids[i]] = struct{}{}
	}
}

// RemovedHustlerAccessories returns the removed IDs of the "hustler_accessories" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerAccessoriesIDs() (ids []string) {
	for id := range m.removedhustler_accessories {
		ids = append(ids, id)
	}
	return
}

// HustlerAccessoriesIDs returns the "hustler_accessories" edge IDs in the mutation.
func (m *ItemMutation) HustlerAccessoriesIDs() (ids []string) {
	for id := range m.hustler_accessories {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerAccessories resets all changes to the "hustler_accessories" edge.
func (m *ItemMutation) ResetHustlerAccessories() {
	m.hustler_accessories = nil
	m.clearedhustler_accessories = false
	m.removedhustler_accessories = nil
}

// SetBaseID sets the "base" edge to the Item entity by id.
func (m *ItemMutation) SetBaseID(id string) {
	m.base = &id
}

// ClearBase clears the "base" edge to the Item entity.
func (m *ItemMutation) ClearBase() {
	m.clearedbase = true
}

// BaseCleared reports if the "base" edge to the Item entity was cleared.
func (m *ItemMutation) BaseCleared() bool {
	return m.clearedbase
}

// BaseID returns the "base" edge ID in the mutation.
func (m *ItemMutation) BaseID() (id string, exists bool) {
	if m.base != nil {
		return *m.base, true
	}
	return
}

// BaseIDs returns the "base" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BaseID instead. It exists only for internal usage by the builders.
func (m *ItemMutation) BaseIDs() (ids []string) {
	if id := m.base; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBase resets all changes to the "base" edge.
func (m *ItemMutation) ResetBase() {
	m.base = nil
	m.clearedbase = false
}

// AddDerivativeIDs adds the "derivative" edge to the Item entity by ids.
func (m *ItemMutation) AddDerivativeIDs(ids ...string) {
	if m.derivative == nil {
		m.derivative = make(map[string]struct{})
	}
	for i := range ids {
		m.derivative[ids[i]] = struct{}{}
	}
}

// ClearDerivative clears the "derivative" edge to the Item entity.
func (m *ItemMutation) ClearDerivative() {
	m.clearedderivative = true
}

// DerivativeCleared reports if the "derivative" edge to the Item entity was cleared.
func (m *ItemMutation) DerivativeCleared() bool {
	return m.clearedderivative
}

// RemoveDerivativeIDs removes the "derivative" edge to the Item entity by IDs.
func (m *ItemMutation) RemoveDerivativeIDs(ids ...string) {
	if m.removedderivative == nil {
		m.removedderivative = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.derivative, ids[i])
		m.removedderivative[ids[i]] = struct{}{}
	}
}

// RemovedDerivative returns the removed IDs of the "derivative" edge to the Item entity.
func (m *ItemMutation) RemovedDerivativeIDs() (ids []string) {
	for id := range m.removedderivative {
		ids = append(ids, id)
	}
	return
}

// DerivativeIDs returns the "derivative" edge IDs in the mutation.
func (m *ItemMutation) DerivativeIDs() (ids []string) {
	for id := range m.derivative {
		ids = append(ids, id)
	}
	return
}

// ResetDerivative resets all changes to the "derivative" edge.
func (m *ItemMutation) ResetDerivative() {
	m.derivative = nil
	m.clearedderivative = false
	m.removedderivative = nil
}

// Where appends a list predicates to the ItemMutation builder.
func (m *ItemMutation) Where(ps ...predicate.Item) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Item).
func (m *ItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ItemMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m._type != nil {
		fields = append(fields, item.FieldType)
	}
	if m.name_prefix != nil {
		fields = append(fields, item.FieldNamePrefix)
	}
	if m.name_suffix != nil {
		fields = append(fields, item.FieldNameSuffix)
	}
	if m.name != nil {
		fields = append(fields, item.FieldName)
	}
	if m.suffix != nil {
		fields = append(fields, item.FieldSuffix)
	}
	if m.augmented != nil {
		fields = append(fields, item.FieldAugmented)
	}
	if m.count != nil {
		fields = append(fields, item.FieldCount)
	}
	if m.tier != nil {
		fields = append(fields, item.FieldTier)
	}
	if m.greatness != nil {
		fields = append(fields, item.FieldGreatness)
	}
	if m.rles != nil {
		fields = append(fields, item.FieldRles)
	}
	if m.svg != nil {
		fields = append(fields, item.FieldSvg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case item.FieldType:
		return m.GetType()
	case item.FieldNamePrefix:
		return m.NamePrefix()
	case item.FieldNameSuffix:
		return m.NameSuffix()
	case item.FieldName:
		return m.Name()
	case item.FieldSuffix:
		return m.Suffix()
	case item.FieldAugmented:
		return m.Augmented()
	case item.FieldCount:
		return m.Count()
	case item.FieldTier:
		return m.Tier()
	case item.FieldGreatness:
		return m.Greatness()
	case item.FieldRles:
		return m.Rles()
	case item.FieldSvg:
		return m.Svg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case item.FieldType:
		return m.OldType(ctx)
	case item.FieldNamePrefix:
		return m.OldNamePrefix(ctx)
	case item.FieldNameSuffix:
		return m.OldNameSuffix(ctx)
	case item.FieldName:
		return m.OldName(ctx)
	case item.FieldSuffix:
		return m.OldSuffix(ctx)
	case item.FieldAugmented:
		return m.OldAugmented(ctx)
	case item.FieldCount:
		return m.OldCount(ctx)
	case item.FieldTier:
		return m.OldTier(ctx)
	case item.FieldGreatness:
		return m.OldGreatness(ctx)
	case item.FieldRles:
		return m.OldRles(ctx)
	case item.FieldSvg:
		return m.OldSvg(ctx)
	}
	return nil, fmt.Errorf("unknown Item field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case item.FieldType:
		v, ok := value.(item.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case item.FieldNamePrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamePrefix(v)
		return nil
	case item.FieldNameSuffix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameSuffix(v)
		return nil
	case item.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case item.FieldSuffix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuffix(v)
		return nil
	case item.FieldAugmented:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAugmented(v)
		return nil
	case item.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case item.FieldTier:
		v, ok := value.(item.Tier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTier(v)
		return nil
	case item.FieldGreatness:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGreatness(v)
		return nil
	case item.FieldRles:
		v, ok := value.(schema.RLEs)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRles(v)
		return nil
	case item.FieldSvg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSvg(v)
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ItemMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, item.FieldCount)
	}
	if m.addgreatness != nil {
		fields = append(fields, item.FieldGreatness)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case item.FieldCount:
		return m.AddedCount()
	case item.FieldGreatness:
		return m.AddedGreatness()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case item.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case item.FieldGreatness:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGreatness(v)
		return nil
	}
	return fmt.Errorf("unknown Item numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(item.FieldNamePrefix) {
		fields = append(fields, item.FieldNamePrefix)
	}
	if m.FieldCleared(item.FieldNameSuffix) {
		fields = append(fields, item.FieldNameSuffix)
	}
	if m.FieldCleared(item.FieldSuffix) {
		fields = append(fields, item.FieldSuffix)
	}
	if m.FieldCleared(item.FieldAugmented) {
		fields = append(fields, item.FieldAugmented)
	}
	if m.FieldCleared(item.FieldCount) {
		fields = append(fields, item.FieldCount)
	}
	if m.FieldCleared(item.FieldTier) {
		fields = append(fields, item.FieldTier)
	}
	if m.FieldCleared(item.FieldGreatness) {
		fields = append(fields, item.FieldGreatness)
	}
	if m.FieldCleared(item.FieldRles) {
		fields = append(fields, item.FieldRles)
	}
	if m.FieldCleared(item.FieldSvg) {
		fields = append(fields, item.FieldSvg)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ItemMutation) ClearField(name string) error {
	switch name {
	case item.FieldNamePrefix:
		m.ClearNamePrefix()
		return nil
	case item.FieldNameSuffix:
		m.ClearNameSuffix()
		return nil
	case item.FieldSuffix:
		m.ClearSuffix()
		return nil
	case item.FieldAugmented:
		m.ClearAugmented()
		return nil
	case item.FieldCount:
		m.ClearCount()
		return nil
	case item.FieldTier:
		m.ClearTier()
		return nil
	case item.FieldGreatness:
		m.ClearGreatness()
		return nil
	case item.FieldRles:
		m.ClearRles()
		return nil
	case item.FieldSvg:
		m.ClearSvg()
		return nil
	}
	return fmt.Errorf("unknown Item nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ItemMutation) ResetField(name string) error {
	switch name {
	case item.FieldType:
		m.ResetType()
		return nil
	case item.FieldNamePrefix:
		m.ResetNamePrefix()
		return nil
	case item.FieldNameSuffix:
		m.ResetNameSuffix()
		return nil
	case item.FieldName:
		m.ResetName()
		return nil
	case item.FieldSuffix:
		m.ResetSuffix()
		return nil
	case item.FieldAugmented:
		m.ResetAugmented()
		return nil
	case item.FieldCount:
		m.ResetCount()
		return nil
	case item.FieldTier:
		m.ResetTier()
		return nil
	case item.FieldGreatness:
		m.ResetGreatness()
		return nil
	case item.FieldRles:
		m.ResetRles()
		return nil
	case item.FieldSvg:
		m.ResetSvg()
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 14)
	if m.wallets != nil {
		edges = append(edges, item.EdgeWallets)
	}
	if m.dopes != nil {
		edges = append(edges, item.EdgeDopes)
	}
	if m.hustler_weapons != nil {
		edges = append(edges, item.EdgeHustlerWeapons)
	}
	if m.hustler_clothes != nil {
		edges = append(edges, item.EdgeHustlerClothes)
	}
	if m.hustler_vehicles != nil {
		edges = append(edges, item.EdgeHustlerVehicles)
	}
	if m.hustler_waists != nil {
		edges = append(edges, item.EdgeHustlerWaists)
	}
	if m.hustler_feet != nil {
		edges = append(edges, item.EdgeHustlerFeet)
	}
	if m.hustler_hands != nil {
		edges = append(edges, item.EdgeHustlerHands)
	}
	if m.hustler_drugs != nil {
		edges = append(edges, item.EdgeHustlerDrugs)
	}
	if m.hustler_necks != nil {
		edges = append(edges, item.EdgeHustlerNecks)
	}
	if m.hustler_rings != nil {
		edges = append(edges, item.EdgeHustlerRings)
	}
	if m.hustler_accessories != nil {
		edges = append(edges, item.EdgeHustlerAccessories)
	}
	if m.base != nil {
		edges = append(edges, item.EdgeBase)
	}
	if m.derivative != nil {
		edges = append(edges, item.EdgeDerivative)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeWallets:
		ids := make([]ent.Value, 0, len(m.wallets))
		for id := range m.wallets {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeDopes:
		ids := make([]ent.Value, 0, len(m.dopes))
		for id := range m.dopes {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerWeapons:
		ids := make([]ent.Value, 0, len(m.hustler_weapons))
		for id := range m.hustler_weapons {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerClothes:
		ids := make([]ent.Value, 0, len(m.hustler_clothes))
		for id := range m.hustler_clothes {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerVehicles:
		ids := make([]ent.Value, 0, len(m.hustler_vehicles))
		for id := range m.hustler_vehicles {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerWaists:
		ids := make([]ent.Value, 0, len(m.hustler_waists))
		for id := range m.hustler_waists {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerFeet:
		ids := make([]ent.Value, 0, len(m.hustler_feet))
		for id := range m.hustler_feet {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerHands:
		ids := make([]ent.Value, 0, len(m.hustler_hands))
		for id := range m.hustler_hands {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerDrugs:
		ids := make([]ent.Value, 0, len(m.hustler_drugs))
		for id := range m.hustler_drugs {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerNecks:
		ids := make([]ent.Value, 0, len(m.hustler_necks))
		for id := range m.hustler_necks {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerRings:
		ids := make([]ent.Value, 0, len(m.hustler_rings))
		for id := range m.hustler_rings {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerAccessories:
		ids := make([]ent.Value, 0, len(m.hustler_accessories))
		for id := range m.hustler_accessories {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeBase:
		if id := m.base; id != nil {
			return []ent.Value{*id}
		}
	case item.EdgeDerivative:
		ids := make([]ent.Value, 0, len(m.derivative))
		for id := range m.derivative {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 14)
	if m.removedwallets != nil {
		edges = append(edges, item.EdgeWallets)
	}
	if m.removeddopes != nil {
		edges = append(edges, item.EdgeDopes)
	}
	if m.removedhustler_weapons != nil {
		edges = append(edges, item.EdgeHustlerWeapons)
	}
	if m.removedhustler_clothes != nil {
		edges = append(edges, item.EdgeHustlerClothes)
	}
	if m.removedhustler_vehicles != nil {
		edges = append(edges, item.EdgeHustlerVehicles)
	}
	if m.removedhustler_waists != nil {
		edges = append(edges, item.EdgeHustlerWaists)
	}
	if m.removedhustler_feet != nil {
		edges = append(edges, item.EdgeHustlerFeet)
	}
	if m.removedhustler_hands != nil {
		edges = append(edges, item.EdgeHustlerHands)
	}
	if m.removedhustler_drugs != nil {
		edges = append(edges, item.EdgeHustlerDrugs)
	}
	if m.removedhustler_necks != nil {
		edges = append(edges, item.EdgeHustlerNecks)
	}
	if m.removedhustler_rings != nil {
		edges = append(edges, item.EdgeHustlerRings)
	}
	if m.removedhustler_accessories != nil {
		edges = append(edges, item.EdgeHustlerAccessories)
	}
	if m.removedderivative != nil {
		edges = append(edges, item.EdgeDerivative)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeWallets:
		ids := make([]ent.Value, 0, len(m.removedwallets))
		for id := range m.removedwallets {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeDopes:
		ids := make([]ent.Value, 0, len(m.removeddopes))
		for id := range m.removeddopes {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerWeapons:
		ids := make([]ent.Value, 0, len(m.removedhustler_weapons))
		for id := range m.removedhustler_weapons {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerClothes:
		ids := make([]ent.Value, 0, len(m.removedhustler_clothes))
		for id := range m.removedhustler_clothes {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerVehicles:
		ids := make([]ent.Value, 0, len(m.removedhustler_vehicles))
		for id := range m.removedhustler_vehicles {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerWaists:
		ids := make([]ent.Value, 0, len(m.removedhustler_waists))
		for id := range m.removedhustler_waists {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerFeet:
		ids := make([]ent.Value, 0, len(m.removedhustler_feet))
		for id := range m.removedhustler_feet {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerHands:
		ids := make([]ent.Value, 0, len(m.removedhustler_hands))
		for id := range m.removedhustler_hands {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerDrugs:
		ids := make([]ent.Value, 0, len(m.removedhustler_drugs))
		for id := range m.removedhustler_drugs {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerNecks:
		ids := make([]ent.Value, 0, len(m.removedhustler_necks))
		for id := range m.removedhustler_necks {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerRings:
		ids := make([]ent.Value, 0, len(m.removedhustler_rings))
		for id := range m.removedhustler_rings {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerAccessories:
		ids := make([]ent.Value, 0, len(m.removedhustler_accessories))
		for id := range m.removedhustler_accessories {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeDerivative:
		ids := make([]ent.Value, 0, len(m.removedderivative))
		for id := range m.removedderivative {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 14)
	if m.clearedwallets {
		edges = append(edges, item.EdgeWallets)
	}
	if m.cleareddopes {
		edges = append(edges, item.EdgeDopes)
	}
	if m.clearedhustler_weapons {
		edges = append(edges, item.EdgeHustlerWeapons)
	}
	if m.clearedhustler_clothes {
		edges = append(edges, item.EdgeHustlerClothes)
	}
	if m.clearedhustler_vehicles {
		edges = append(edges, item.EdgeHustlerVehicles)
	}
	if m.clearedhustler_waists {
		edges = append(edges, item.EdgeHustlerWaists)
	}
	if m.clearedhustler_feet {
		edges = append(edges, item.EdgeHustlerFeet)
	}
	if m.clearedhustler_hands {
		edges = append(edges, item.EdgeHustlerHands)
	}
	if m.clearedhustler_drugs {
		edges = append(edges, item.EdgeHustlerDrugs)
	}
	if m.clearedhustler_necks {
		edges = append(edges, item.EdgeHustlerNecks)
	}
	if m.clearedhustler_rings {
		edges = append(edges, item.EdgeHustlerRings)
	}
	if m.clearedhustler_accessories {
		edges = append(edges, item.EdgeHustlerAccessories)
	}
	if m.clearedbase {
		edges = append(edges, item.EdgeBase)
	}
	if m.clearedderivative {
		edges = append(edges, item.EdgeDerivative)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ItemMutation) EdgeCleared(name string) bool {
	switch name {
	case item.EdgeWallets:
		return m.clearedwallets
	case item.EdgeDopes:
		return m.cleareddopes
	case item.EdgeHustlerWeapons:
		return m.clearedhustler_weapons
	case item.EdgeHustlerClothes:
		return m.clearedhustler_clothes
	case item.EdgeHustlerVehicles:
		return m.clearedhustler_vehicles
	case item.EdgeHustlerWaists:
		return m.clearedhustler_waists
	case item.EdgeHustlerFeet:
		return m.clearedhustler_feet
	case item.EdgeHustlerHands:
		return m.clearedhustler_hands
	case item.EdgeHustlerDrugs:
		return m.clearedhustler_drugs
	case item.EdgeHustlerNecks:
		return m.clearedhustler_necks
	case item.EdgeHustlerRings:
		return m.clearedhustler_rings
	case item.EdgeHustlerAccessories:
		return m.clearedhustler_accessories
	case item.EdgeBase:
		return m.clearedbase
	case item.EdgeDerivative:
		return m.clearedderivative
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ItemMutation) ClearEdge(name string) error {
	switch name {
	case item.EdgeBase:
		m.ClearBase()
		return nil
	}
	return fmt.Errorf("unknown Item unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ItemMutation) ResetEdge(name string) error {
	switch name {
	case item.EdgeWallets:
		m.ResetWallets()
		return nil
	case item.EdgeDopes:
		m.ResetDopes()
		return nil
	case item.EdgeHustlerWeapons:
		m.ResetHustlerWeapons()
		return nil
	case item.EdgeHustlerClothes:
		m.ResetHustlerClothes()
		return nil
	case item.EdgeHustlerVehicles:
		m.ResetHustlerVehicles()
		return nil
	case item.EdgeHustlerWaists:
		m.ResetHustlerWaists()
		return nil
	case item.EdgeHustlerFeet:
		m.ResetHustlerFeet()
		return nil
	case item.EdgeHustlerHands:
		m.ResetHustlerHands()
		return nil
	case item.EdgeHustlerDrugs:
		m.ResetHustlerDrugs()
		return nil
	case item.EdgeHustlerNecks:
		m.ResetHustlerNecks()
		return nil
	case item.EdgeHustlerRings:
		m.ResetHustlerRings()
		return nil
	case item.EdgeHustlerAccessories:
		m.ResetHustlerAccessories()
		return nil
	case item.EdgeBase:
		m.ResetBase()
		return nil
	case item.EdgeDerivative:
		m.ResetDerivative()
		return nil
	}
	return fmt.Errorf("unknown Item edge %s", name)
}

// ListingMutation represents an operation that mutates the Listing nodes in the graph.
type ListingMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	active                *bool
	source                *listing.Source
	clearedFields         map[string]struct{}
	dope                  *string
	cleareddope           bool
	dope_lastsales        map[string]struct{}
	removeddope_lastsales map[string]struct{}
	cleareddope_lastsales bool
	inputs                map[string]struct{}
	removedinputs         map[string]struct{}
	clearedinputs         bool
	outputs               map[string]struct{}
	removedoutputs        map[string]struct{}
	clearedoutputs        bool
	done                  bool
	oldValue              func(context.Context) (*Listing, error)
	predicates            []predicate.Listing
}

var _ ent.Mutation = (*ListingMutation)(nil)

// listingOption allows management of the mutation configuration using functional options.
type listingOption func(*ListingMutation)

// newListingMutation creates new mutation for the Listing entity.
func newListingMutation(c config, op Op, opts ...listingOption) *ListingMutation {
	m := &ListingMutation{
		config:        c,
		op:            op,
		typ:           TypeListing,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withListingID sets the ID field of the mutation.
func withListingID(id string) listingOption {
	return func(m *ListingMutation) {
		var (
			err   error
			once  sync.Once
			value *Listing
		)
		m.oldValue = func(ctx context.Context) (*Listing, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Listing.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withListing sets the old Listing of the mutation.
func withListing(node *Listing) listingOption {
	return func(m *ListingMutation) {
		m.oldValue = func(context.Context) (*Listing, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ListingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ListingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Listing entities.
func (m *ListingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ListingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ListingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Listing.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActive sets the "active" field.
func (m *ListingMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *ListingMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Listing entity.
// If the Listing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListingMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *ListingMutation) ResetActive() {
	m.active = nil
}

// SetSource sets the "source" field.
func (m *ListingMutation) SetSource(l listing.Source) {
	m.source = &l
}

// Source returns the value of the "source" field in the mutation.
func (m *ListingMutation) Source() (r listing.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Listing entity.
// If the Listing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListingMutation) OldSource(ctx context.Context) (v listing.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ListingMutation) ResetSource() {
	m.source = nil
}

// SetDopeID sets the "dope" edge to the Dope entity by id.
func (m *ListingMutation) SetDopeID(id string) {
	m.dope = &id
}

// ClearDope clears the "dope" edge to the Dope entity.
func (m *ListingMutation) ClearDope() {
	m.cleareddope = true
}

// DopeCleared reports if the "dope" edge to the Dope entity was cleared.
func (m *ListingMutation) DopeCleared() bool {
	return m.cleareddope
}

// DopeID returns the "dope" edge ID in the mutation.
func (m *ListingMutation) DopeID() (id string, exists bool) {
	if m.dope != nil {
		return *m.dope, true
	}
	return
}

// DopeIDs returns the "dope" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DopeID instead. It exists only for internal usage by the builders.
func (m *ListingMutation) DopeIDs() (ids []string) {
	if id := m.dope; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDope resets all changes to the "dope" edge.
func (m *ListingMutation) ResetDope() {
	m.dope = nil
	m.cleareddope = false
}

// AddDopeLastsaleIDs adds the "dope_lastsales" edge to the Dope entity by ids.
func (m *ListingMutation) AddDopeLastsaleIDs(ids ...string) {
	if m.dope_lastsales == nil {
		m.dope_lastsales = make(map[string]struct{})
	}
	for i := range ids {
		m.dope_lastsales[ids[i]] = struct{}{}
	}
}

// ClearDopeLastsales clears the "dope_lastsales" edge to the Dope entity.
func (m *ListingMutation) ClearDopeLastsales() {
	m.cleareddope_lastsales = true
}

// DopeLastsalesCleared reports if the "dope_lastsales" edge to the Dope entity was cleared.
func (m *ListingMutation) DopeLastsalesCleared() bool {
	return m.cleareddope_lastsales
}

// RemoveDopeLastsaleIDs removes the "dope_lastsales" edge to the Dope entity by IDs.
func (m *ListingMutation) RemoveDopeLastsaleIDs(ids ...string) {
	if m.removeddope_lastsales == nil {
		m.removeddope_lastsales = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dope_lastsales, ids[i])
		m.removeddope_lastsales[ids[i]] = struct{}{}
	}
}

// RemovedDopeLastsales returns the removed IDs of the "dope_lastsales" edge to the Dope entity.
func (m *ListingMutation) RemovedDopeLastsalesIDs() (ids []string) {
	for id := range m.removeddope_lastsales {
		ids = append(ids, id)
	}
	return
}

// DopeLastsalesIDs returns the "dope_lastsales" edge IDs in the mutation.
func (m *ListingMutation) DopeLastsalesIDs() (ids []string) {
	for id := range m.dope_lastsales {
		ids = append(ids, id)
	}
	return
}

// ResetDopeLastsales resets all changes to the "dope_lastsales" edge.
func (m *ListingMutation) ResetDopeLastsales() {
	m.dope_lastsales = nil
	m.cleareddope_lastsales = false
	m.removeddope_lastsales = nil
}

// AddInputIDs adds the "inputs" edge to the Asset entity by ids.
func (m *ListingMutation) AddInputIDs(ids ...string) {
	if m.inputs == nil {
		m.inputs = make(map[string]struct{})
	}
	for i := range ids {
		m.inputs[ids[i]] = struct{}{}
	}
}

// ClearInputs clears the "inputs" edge to the Asset entity.
func (m *ListingMutation) ClearInputs() {
	m.clearedinputs = true
}

// InputsCleared reports if the "inputs" edge to the Asset entity was cleared.
func (m *ListingMutation) InputsCleared() bool {
	return m.clearedinputs
}

// RemoveInputIDs removes the "inputs" edge to the Asset entity by IDs.
func (m *ListingMutation) RemoveInputIDs(ids ...string) {
	if m.removedinputs == nil {
		m.removedinputs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.inputs, ids[i])
		m.removedinputs[ids[i]] = struct{}{}
	}
}

// RemovedInputs returns the removed IDs of the "inputs" edge to the Asset entity.
func (m *ListingMutation) RemovedInputsIDs() (ids []string) {
	for id := range m.removedinputs {
		ids = append(ids, id)
	}
	return
}

// InputsIDs returns the "inputs" edge IDs in the mutation.
func (m *ListingMutation) InputsIDs() (ids []string) {
	for id := range m.inputs {
		ids = append(ids, id)
	}
	return
}

// ResetInputs resets all changes to the "inputs" edge.
func (m *ListingMutation) ResetInputs() {
	m.inputs = nil
	m.clearedinputs = false
	m.removedinputs = nil
}

// AddOutputIDs adds the "outputs" edge to the Asset entity by ids.
func (m *ListingMutation) AddOutputIDs(ids ...string) {
	if m.outputs == nil {
		m.outputs = make(map[string]struct{})
	}
	for i := range ids {
		m.outputs[ids[i]] = struct{}{}
	}
}

// ClearOutputs clears the "outputs" edge to the Asset entity.
func (m *ListingMutation) ClearOutputs() {
	m.clearedoutputs = true
}

// OutputsCleared reports if the "outputs" edge to the Asset entity was cleared.
func (m *ListingMutation) OutputsCleared() bool {
	return m.clearedoutputs
}

// RemoveOutputIDs removes the "outputs" edge to the Asset entity by IDs.
func (m *ListingMutation) RemoveOutputIDs(ids ...string) {
	if m.removedoutputs == nil {
		m.removedoutputs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.outputs, ids[i])
		m.removedoutputs[ids[i]] = struct{}{}
	}
}

// RemovedOutputs returns the removed IDs of the "outputs" edge to the Asset entity.
func (m *ListingMutation) RemovedOutputsIDs() (ids []string) {
	for id := range m.removedoutputs {
		ids = append(ids, id)
	}
	return
}

// OutputsIDs returns the "outputs" edge IDs in the mutation.
func (m *ListingMutation) OutputsIDs() (ids []string) {
	for id := range m.outputs {
		ids = append(ids, id)
	}
	return
}

// ResetOutputs resets all changes to the "outputs" edge.
func (m *ListingMutation) ResetOutputs() {
	m.outputs = nil
	m.clearedoutputs = false
	m.removedoutputs = nil
}

// Where appends a list predicates to the ListingMutation builder.
func (m *ListingMutation) Where(ps ...predicate.Listing) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ListingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Listing).
func (m *ListingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ListingMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.active != nil {
		fields = append(fields, listing.FieldActive)
	}
	if m.source != nil {
		fields = append(fields, listing.FieldSource)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ListingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case listing.FieldActive:
		return m.Active()
	case listing.FieldSource:
		return m.Source()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ListingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case listing.FieldActive:
		return m.OldActive(ctx)
	case listing.FieldSource:
		return m.OldSource(ctx)
	}
	return nil, fmt.Errorf("unknown Listing field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ListingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case listing.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case listing.FieldSource:
		v, ok := value.(listing.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	}
	return fmt.Errorf("unknown Listing field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ListingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ListingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ListingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Listing numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ListingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ListingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ListingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Listing nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ListingMutation) ResetField(name string) error {
	switch name {
	case listing.FieldActive:
		m.ResetActive()
		return nil
	case listing.FieldSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown Listing field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ListingMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.dope != nil {
		edges = append(edges, listing.EdgeDope)
	}
	if m.dope_lastsales != nil {
		edges = append(edges, listing.EdgeDopeLastsales)
	}
	if m.inputs != nil {
		edges = append(edges, listing.EdgeInputs)
	}
	if m.outputs != nil {
		edges = append(edges, listing.EdgeOutputs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ListingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case listing.EdgeDope:
		if id := m.dope; id != nil {
			return []ent.Value{*id}
		}
	case listing.EdgeDopeLastsales:
		ids := make([]ent.Value, 0, len(m.dope_lastsales))
		for id := range m.dope_lastsales {
			ids = append(ids, id)
		}
		return ids
	case listing.EdgeInputs:
		ids := make([]ent.Value, 0, len(m.inputs))
		for id := range m.inputs {
			ids = append(ids, id)
		}
		return ids
	case listing.EdgeOutputs:
		ids := make([]ent.Value, 0, len(m.outputs))
		for id := range m.outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ListingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddope_lastsales != nil {
		edges = append(edges, listing.EdgeDopeLastsales)
	}
	if m.removedinputs != nil {
		edges = append(edges, listing.EdgeInputs)
	}
	if m.removedoutputs != nil {
		edges = append(edges, listing.EdgeOutputs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ListingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case listing.EdgeDopeLastsales:
		ids := make([]ent.Value, 0, len(m.removeddope_lastsales))
		for id := range m.removeddope_lastsales {
			ids = append(ids, id)
		}
		return ids
	case listing.EdgeInputs:
		ids := make([]ent.Value, 0, len(m.removedinputs))
		for id := range m.removedinputs {
			ids = append(ids, id)
		}
		return ids
	case listing.EdgeOutputs:
		ids := make([]ent.Value, 0, len(m.removedoutputs))
		for id := range m.removedoutputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ListingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddope {
		edges = append(edges, listing.EdgeDope)
	}
	if m.cleareddope_lastsales {
		edges = append(edges, listing.EdgeDopeLastsales)
	}
	if m.clearedinputs {
		edges = append(edges, listing.EdgeInputs)
	}
	if m.clearedoutputs {
		edges = append(edges, listing.EdgeOutputs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ListingMutation) EdgeCleared(name string) bool {
	switch name {
	case listing.EdgeDope:
		return m.cleareddope
	case listing.EdgeDopeLastsales:
		return m.cleareddope_lastsales
	case listing.EdgeInputs:
		return m.clearedinputs
	case listing.EdgeOutputs:
		return m.clearedoutputs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ListingMutation) ClearEdge(name string) error {
	switch name {
	case listing.EdgeDope:
		m.ClearDope()
		return nil
	}
	return fmt.Errorf("unknown Listing unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ListingMutation) ResetEdge(name string) error {
	switch name {
	case listing.EdgeDope:
		m.ResetDope()
		return nil
	case listing.EdgeDopeLastsales:
		m.ResetDopeLastsales()
		return nil
	case listing.EdgeInputs:
		m.ResetInputs()
		return nil
	case listing.EdgeOutputs:
		m.ResetOutputs()
		return nil
	}
	return fmt.Errorf("unknown Listing edge %s", name)
}

// PaymentTokenMutation represents an operation that mutates the PaymentToken nodes in the graph.
type PaymentTokenMutation struct {
	config
	op            Op
	typ           string
	id            *string
	address       *string
	_type         *string
	symbol        *string
	price         *float64
	addprice      *float64
	clearedFields map[string]struct{}
	asset         map[string]struct{}
	removedasset  map[string]struct{}
	clearedasset  bool
	done          bool
	oldValue      func(context.Context) (*PaymentToken, error)
	predicates    []predicate.PaymentToken
}

var _ ent.Mutation = (*PaymentTokenMutation)(nil)

// paymenttokenOption allows management of the mutation configuration using functional options.
type paymenttokenOption func(*PaymentTokenMutation)

// newPaymentTokenMutation creates new mutation for the PaymentToken entity.
func newPaymentTokenMutation(c config, op Op, opts ...paymenttokenOption) *PaymentTokenMutation {
	m := &PaymentTokenMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentTokenID sets the ID field of the mutation.
func withPaymentTokenID(id string) paymenttokenOption {
	return func(m *PaymentTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentToken
		)
		m.oldValue = func(ctx context.Context) (*PaymentToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentToken sets the old PaymentToken of the mutation.
func withPaymentToken(node *PaymentToken) paymenttokenOption {
	return func(m *PaymentTokenMutation) {
		m.oldValue = func(context.Context) (*PaymentToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentToken entities.
func (m *PaymentTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAddress sets the "address" field.
func (m *PaymentTokenMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *PaymentTokenMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the PaymentToken entity.
// If the PaymentToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTokenMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *PaymentTokenMutation) ResetAddress() {
	m.address = nil
}

// SetType sets the "type" field.
func (m *PaymentTokenMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PaymentTokenMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PaymentToken entity.
// If the PaymentToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTokenMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PaymentTokenMutation) ResetType() {
	m._type = nil
}

// SetSymbol sets the "symbol" field.
func (m *PaymentTokenMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *PaymentTokenMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the PaymentToken entity.
// If the PaymentToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTokenMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *PaymentTokenMutation) ResetSymbol() {
	m.symbol = nil
}

// SetPrice sets the "price" field.
func (m *PaymentTokenMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *PaymentTokenMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the PaymentToken entity.
// If the PaymentToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTokenMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *PaymentTokenMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *PaymentTokenMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *PaymentTokenMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// AddAssetIDs adds the "asset" edge to the Asset entity by ids.
func (m *PaymentTokenMutation) AddAssetIDs(ids ...string) {
	if m.asset == nil {
		m.asset = make(map[string]struct{})
	}
	for i := range ids {
		m.asset[ids[i]] = struct{}{}
	}
}

// ClearAsset clears the "asset" edge to the Asset entity.
func (m *PaymentTokenMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the Asset entity was cleared.
func (m *PaymentTokenMutation) AssetCleared() bool {
	return m.clearedasset
}

// RemoveAssetIDs removes the "asset" edge to the Asset entity by IDs.
func (m *PaymentTokenMutation) RemoveAssetIDs(ids ...string) {
	if m.removedasset == nil {
		m.removedasset = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.asset, ids[i])
		m.removedasset[ids[i]] = struct{}{}
	}
}

// RemovedAsset returns the removed IDs of the "asset" edge to the Asset entity.
func (m *PaymentTokenMutation) RemovedAssetIDs() (ids []string) {
	for id := range m.removedasset {
		ids = append(ids, id)
	}
	return
}

// AssetIDs returns the "asset" edge IDs in the mutation.
func (m *PaymentTokenMutation) AssetIDs() (ids []string) {
	for id := range m.asset {
		ids = append(ids, id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *PaymentTokenMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
	m.removedasset = nil
}

// Where appends a list predicates to the PaymentTokenMutation builder.
func (m *PaymentTokenMutation) Where(ps ...predicate.PaymentToken) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PaymentTokenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PaymentToken).
func (m *PaymentTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentTokenMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.address != nil {
		fields = append(fields, paymenttoken.FieldAddress)
	}
	if m._type != nil {
		fields = append(fields, paymenttoken.FieldType)
	}
	if m.symbol != nil {
		fields = append(fields, paymenttoken.FieldSymbol)
	}
	if m.price != nil {
		fields = append(fields, paymenttoken.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymenttoken.FieldAddress:
		return m.Address()
	case paymenttoken.FieldType:
		return m.GetType()
	case paymenttoken.FieldSymbol:
		return m.Symbol()
	case paymenttoken.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymenttoken.FieldAddress:
		return m.OldAddress(ctx)
	case paymenttoken.FieldType:
		return m.OldType(ctx)
	case paymenttoken.FieldSymbol:
		return m.OldSymbol(ctx)
	case paymenttoken.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymenttoken.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case paymenttoken.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case paymenttoken.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case paymenttoken.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentTokenMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, paymenttoken.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymenttoken.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymenttoken.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PaymentToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentTokenMutation) ResetField(name string) error {
	switch name {
	case paymenttoken.FieldAddress:
		m.ResetAddress()
		return nil
	case paymenttoken.FieldType:
		m.ResetType()
		return nil
	case paymenttoken.FieldSymbol:
		m.ResetSymbol()
		return nil
	case paymenttoken.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown PaymentToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.asset != nil {
		edges = append(edges, paymenttoken.EdgeAsset)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymenttoken.EdgeAsset:
		ids := make([]ent.Value, 0, len(m.asset))
		for id := range m.asset {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedasset != nil {
		edges = append(edges, paymenttoken.EdgeAsset)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentTokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case paymenttoken.EdgeAsset:
		ids := make([]ent.Value, 0, len(m.removedasset))
		for id := range m.removedasset {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedasset {
		edges = append(edges, paymenttoken.EdgeAsset)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case paymenttoken.EdgeAsset:
		return m.clearedasset
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentTokenMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PaymentToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentTokenMutation) ResetEdge(name string) error {
	switch name {
	case paymenttoken.EdgeAsset:
		m.ResetAsset()
		return nil
	}
	return fmt.Errorf("unknown PaymentToken edge %s", name)
}

// SyncStateMutation represents an operation that mutates the SyncState nodes in the graph.
type SyncStateMutation struct {
	config
	op             Op
	typ            string
	id             *string
	start_block    *uint64
	addstart_block *int64
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*SyncState, error)
	predicates     []predicate.SyncState
}

var _ ent.Mutation = (*SyncStateMutation)(nil)

// syncstateOption allows management of the mutation configuration using functional options.
type syncstateOption func(*SyncStateMutation)

// newSyncStateMutation creates new mutation for the SyncState entity.
func newSyncStateMutation(c config, op Op, opts ...syncstateOption) *SyncStateMutation {
	m := &SyncStateMutation{
		config:        c,
		op:            op,
		typ:           TypeSyncState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSyncStateID sets the ID field of the mutation.
func withSyncStateID(id string) syncstateOption {
	return func(m *SyncStateMutation) {
		var (
			err   error
			once  sync.Once
			value *SyncState
		)
		m.oldValue = func(ctx context.Context) (*SyncState, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SyncState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSyncState sets the old SyncState of the mutation.
func withSyncState(node *SyncState) syncstateOption {
	return func(m *SyncStateMutation) {
		m.oldValue = func(context.Context) (*SyncState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SyncStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SyncStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SyncState entities.
func (m *SyncStateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SyncStateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SyncStateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SyncState.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartBlock sets the "start_block" field.
func (m *SyncStateMutation) SetStartBlock(u uint64) {
	m.start_block = &u
	m.addstart_block = nil
}

// StartBlock returns the value of the "start_block" field in the mutation.
func (m *SyncStateMutation) StartBlock() (r uint64, exists bool) {
	v := m.start_block
	if v == nil {
		return
	}
	return *v, true
}

// OldStartBlock returns the old "start_block" field's value of the SyncState entity.
// If the SyncState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncStateMutation) OldStartBlock(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartBlock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartBlock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartBlock: %w", err)
	}
	return oldValue.StartBlock, nil
}

// AddStartBlock adds u to the "start_block" field.
func (m *SyncStateMutation) AddStartBlock(u int64) {
	if m.addstart_block != nil {
		*m.addstart_block += u
	} else {
		m.addstart_block = &u
	}
}

// AddedStartBlock returns the value that was added to the "start_block" field in this mutation.
func (m *SyncStateMutation) AddedStartBlock() (r int64, exists bool) {
	v := m.addstart_block
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartBlock resets all changes to the "start_block" field.
func (m *SyncStateMutation) ResetStartBlock() {
	m.start_block = nil
	m.addstart_block = nil
}

// Where appends a list predicates to the SyncStateMutation builder.
func (m *SyncStateMutation) Where(ps ...predicate.SyncState) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SyncStateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SyncState).
func (m *SyncStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SyncStateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.start_block != nil {
		fields = append(fields, syncstate.FieldStartBlock)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SyncStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case syncstate.FieldStartBlock:
		return m.StartBlock()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SyncStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case syncstate.FieldStartBlock:
		return m.OldStartBlock(ctx)
	}
	return nil, fmt.Errorf("unknown SyncState field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case syncstate.FieldStartBlock:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartBlock(v)
		return nil
	}
	return fmt.Errorf("unknown SyncState field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SyncStateMutation) AddedFields() []string {
	var fields []string
	if m.addstart_block != nil {
		fields = append(fields, syncstate.FieldStartBlock)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SyncStateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case syncstate.FieldStartBlock:
		return m.AddedStartBlock()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case syncstate.FieldStartBlock:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartBlock(v)
		return nil
	}
	return fmt.Errorf("unknown SyncState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SyncStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SyncStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SyncStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SyncState nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SyncStateMutation) ResetField(name string) error {
	switch name {
	case syncstate.FieldStartBlock:
		m.ResetStartBlock()
		return nil
	}
	return fmt.Errorf("unknown SyncState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SyncStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SyncStateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SyncStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SyncStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SyncStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SyncStateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SyncStateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SyncState unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SyncStateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SyncState edge %s", name)
}

// WalletMutation represents an operation that mutates the Wallet nodes in the graph.
type WalletMutation struct {
	config
	op              Op
	typ             string
	id              *string
	paper           *schema.BigInt
	addpaper        *schema.BigInt
	created_at      *time.Time
	clearedFields   map[string]struct{}
	dopes           map[string]struct{}
	removeddopes    map[string]struct{}
	cleareddopes    bool
	items           map[string]struct{}
	removeditems    map[string]struct{}
	cleareditems    bool
	hustlers        map[string]struct{}
	removedhustlers map[string]struct{}
	clearedhustlers bool
	done            bool
	oldValue        func(context.Context) (*Wallet, error)
	predicates      []predicate.Wallet
}

var _ ent.Mutation = (*WalletMutation)(nil)

// walletOption allows management of the mutation configuration using functional options.
type walletOption func(*WalletMutation)

// newWalletMutation creates new mutation for the Wallet entity.
func newWalletMutation(c config, op Op, opts ...walletOption) *WalletMutation {
	m := &WalletMutation{
		config:        c,
		op:            op,
		typ:           TypeWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWalletID sets the ID field of the mutation.
func withWalletID(id string) walletOption {
	return func(m *WalletMutation) {
		var (
			err   error
			once  sync.Once
			value *Wallet
		)
		m.oldValue = func(ctx context.Context) (*Wallet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Wallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWallet sets the old Wallet of the mutation.
func withWallet(node *Wallet) walletOption {
	return func(m *WalletMutation) {
		m.oldValue = func(context.Context) (*Wallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Wallet entities.
func (m *WalletMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WalletMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WalletMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Wallet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPaper sets the "paper" field.
func (m *WalletMutation) SetPaper(si schema.BigInt) {
	m.paper = &si
	m.addpaper = nil
}

// Paper returns the value of the "paper" field in the mutation.
func (m *WalletMutation) Paper() (r schema.BigInt, exists bool) {
	v := m.paper
	if v == nil {
		return
	}
	return *v, true
}

// OldPaper returns the old "paper" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldPaper(ctx context.Context) (v schema.BigInt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaper: %w", err)
	}
	return oldValue.Paper, nil
}

// AddPaper adds si to the "paper" field.
func (m *WalletMutation) AddPaper(si schema.BigInt) {
	if m.addpaper != nil {
		*m.addpaper = m.addpaper.Add(si)
	} else {
		m.addpaper = &si
	}
}

// AddedPaper returns the value that was added to the "paper" field in this mutation.
func (m *WalletMutation) AddedPaper() (r schema.BigInt, exists bool) {
	v := m.addpaper
	if v == nil {
		return
	}
	return *v, true
}

// ResetPaper resets all changes to the "paper" field.
func (m *WalletMutation) ResetPaper() {
	m.paper = nil
	m.addpaper = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WalletMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WalletMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WalletMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddDopeIDs adds the "dopes" edge to the Dope entity by ids.
func (m *WalletMutation) AddDopeIDs(ids ...string) {
	if m.dopes == nil {
		m.dopes = make(map[string]struct{})
	}
	for i := range ids {
		m.dopes[ids[i]] = struct{}{}
	}
}

// ClearDopes clears the "dopes" edge to the Dope entity.
func (m *WalletMutation) ClearDopes() {
	m.cleareddopes = true
}

// DopesCleared reports if the "dopes" edge to the Dope entity was cleared.
func (m *WalletMutation) DopesCleared() bool {
	return m.cleareddopes
}

// RemoveDopeIDs removes the "dopes" edge to the Dope entity by IDs.
func (m *WalletMutation) RemoveDopeIDs(ids ...string) {
	if m.removeddopes == nil {
		m.removeddopes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dopes, ids[i])
		m.removeddopes[ids[i]] = struct{}{}
	}
}

// RemovedDopes returns the removed IDs of the "dopes" edge to the Dope entity.
func (m *WalletMutation) RemovedDopesIDs() (ids []string) {
	for id := range m.removeddopes {
		ids = append(ids, id)
	}
	return
}

// DopesIDs returns the "dopes" edge IDs in the mutation.
func (m *WalletMutation) DopesIDs() (ids []string) {
	for id := range m.dopes {
		ids = append(ids, id)
	}
	return
}

// ResetDopes resets all changes to the "dopes" edge.
func (m *WalletMutation) ResetDopes() {
	m.dopes = nil
	m.cleareddopes = false
	m.removeddopes = nil
}

// AddItemIDs adds the "items" edge to the WalletItems entity by ids.
func (m *WalletMutation) AddItemIDs(ids ...string) {
	if m.items == nil {
		m.items = make(map[string]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the WalletItems entity.
func (m *WalletMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the WalletItems entity was cleared.
func (m *WalletMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the WalletItems entity by IDs.
func (m *WalletMutation) RemoveItemIDs(ids ...string) {
	if m.removeditems == nil {
		m.removeditems = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the WalletItems entity.
func (m *WalletMutation) RemovedItemsIDs() (ids []string) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *WalletMutation) ItemsIDs() (ids []string) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *WalletMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddHustlerIDs adds the "hustlers" edge to the Hustler entity by ids.
func (m *WalletMutation) AddHustlerIDs(ids ...string) {
	if m.hustlers == nil {
		m.hustlers = make(map[string]struct{})
	}
	for i := range ids {
		m.hustlers[ids[i]] = struct{}{}
	}
}

// ClearHustlers clears the "hustlers" edge to the Hustler entity.
func (m *WalletMutation) ClearHustlers() {
	m.clearedhustlers = true
}

// HustlersCleared reports if the "hustlers" edge to the Hustler entity was cleared.
func (m *WalletMutation) HustlersCleared() bool {
	return m.clearedhustlers
}

// RemoveHustlerIDs removes the "hustlers" edge to the Hustler entity by IDs.
func (m *WalletMutation) RemoveHustlerIDs(ids ...string) {
	if m.removedhustlers == nil {
		m.removedhustlers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustlers, ids[i])
		m.removedhustlers[ids[i]] = struct{}{}
	}
}

// RemovedHustlers returns the removed IDs of the "hustlers" edge to the Hustler entity.
func (m *WalletMutation) RemovedHustlersIDs() (ids []string) {
	for id := range m.removedhustlers {
		ids = append(ids, id)
	}
	return
}

// HustlersIDs returns the "hustlers" edge IDs in the mutation.
func (m *WalletMutation) HustlersIDs() (ids []string) {
	for id := range m.hustlers {
		ids = append(ids, id)
	}
	return
}

// ResetHustlers resets all changes to the "hustlers" edge.
func (m *WalletMutation) ResetHustlers() {
	m.hustlers = nil
	m.clearedhustlers = false
	m.removedhustlers = nil
}

// Where appends a list predicates to the WalletMutation builder.
func (m *WalletMutation) Where(ps ...predicate.Wallet) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WalletMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Wallet).
func (m *WalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WalletMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.paper != nil {
		fields = append(fields, wallet.FieldPaper)
	}
	if m.created_at != nil {
		fields = append(fields, wallet.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldPaper:
		return m.Paper()
	case wallet.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wallet.FieldPaper:
		return m.OldPaper(ctx)
	case wallet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Wallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldPaper:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaper(v)
		return nil
	case wallet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WalletMutation) AddedFields() []string {
	var fields []string
	if m.addpaper != nil {
		fields = append(fields, wallet.FieldPaper)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldPaper:
		return m.AddedPaper()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldPaper:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaper(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WalletMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WalletMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Wallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WalletMutation) ResetField(name string) error {
	switch name {
	case wallet.FieldPaper:
		m.ResetPaper()
		return nil
	case wallet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.dopes != nil {
		edges = append(edges, wallet.EdgeDopes)
	}
	if m.items != nil {
		edges = append(edges, wallet.EdgeItems)
	}
	if m.hustlers != nil {
		edges = append(edges, wallet.EdgeHustlers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WalletMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wallet.EdgeDopes:
		ids := make([]ent.Value, 0, len(m.dopes))
		for id := range m.dopes {
			ids = append(ids, id)
		}
		return ids
	case wallet.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case wallet.EdgeHustlers:
		ids := make([]ent.Value, 0, len(m.hustlers))
		for id := range m.hustlers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddopes != nil {
		edges = append(edges, wallet.EdgeDopes)
	}
	if m.removeditems != nil {
		edges = append(edges, wallet.EdgeItems)
	}
	if m.removedhustlers != nil {
		edges = append(edges, wallet.EdgeHustlers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WalletMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case wallet.EdgeDopes:
		ids := make([]ent.Value, 0, len(m.removeddopes))
		for id := range m.removeddopes {
			ids = append(ids, id)
		}
		return ids
	case wallet.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case wallet.EdgeHustlers:
		ids := make([]ent.Value, 0, len(m.removedhustlers))
		for id := range m.removedhustlers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddopes {
		edges = append(edges, wallet.EdgeDopes)
	}
	if m.cleareditems {
		edges = append(edges, wallet.EdgeItems)
	}
	if m.clearedhustlers {
		edges = append(edges, wallet.EdgeHustlers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WalletMutation) EdgeCleared(name string) bool {
	switch name {
	case wallet.EdgeDopes:
		return m.cleareddopes
	case wallet.EdgeItems:
		return m.cleareditems
	case wallet.EdgeHustlers:
		return m.clearedhustlers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WalletMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Wallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WalletMutation) ResetEdge(name string) error {
	switch name {
	case wallet.EdgeDopes:
		m.ResetDopes()
		return nil
	case wallet.EdgeItems:
		m.ResetItems()
		return nil
	case wallet.EdgeHustlers:
		m.ResetHustlers()
		return nil
	}
	return fmt.Errorf("unknown Wallet edge %s", name)
}

// WalletItemsMutation represents an operation that mutates the WalletItems nodes in the graph.
type WalletItemsMutation struct {
	config
	op            Op
	typ           string
	id            *string
	balance       *schema.BigInt
	addbalance    *schema.BigInt
	clearedFields map[string]struct{}
	wallet        *string
	clearedwallet bool
	item          *string
	cleareditem   bool
	done          bool
	oldValue      func(context.Context) (*WalletItems, error)
	predicates    []predicate.WalletItems
}

var _ ent.Mutation = (*WalletItemsMutation)(nil)

// walletitemsOption allows management of the mutation configuration using functional options.
type walletitemsOption func(*WalletItemsMutation)

// newWalletItemsMutation creates new mutation for the WalletItems entity.
func newWalletItemsMutation(c config, op Op, opts ...walletitemsOption) *WalletItemsMutation {
	m := &WalletItemsMutation{
		config:        c,
		op:            op,
		typ:           TypeWalletItems,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWalletItemsID sets the ID field of the mutation.
func withWalletItemsID(id string) walletitemsOption {
	return func(m *WalletItemsMutation) {
		var (
			err   error
			once  sync.Once
			value *WalletItems
		)
		m.oldValue = func(ctx context.Context) (*WalletItems, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WalletItems.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWalletItems sets the old WalletItems of the mutation.
func withWalletItems(node *WalletItems) walletitemsOption {
	return func(m *WalletItemsMutation) {
		m.oldValue = func(context.Context) (*WalletItems, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WalletItemsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WalletItemsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WalletItems entities.
func (m *WalletItemsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WalletItemsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WalletItemsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WalletItems.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBalance sets the "balance" field.
func (m *WalletItemsMutation) SetBalance(si schema.BigInt) {
	m.balance = &si
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *WalletItemsMutation) Balance() (r schema.BigInt, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the WalletItems entity.
// If the WalletItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletItemsMutation) OldBalance(ctx context.Context) (v schema.BigInt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds si to the "balance" field.
func (m *WalletItemsMutation) AddBalance(si schema.BigInt) {
	if m.addbalance != nil {
		*m.addbalance = m.addbalance.Add(si)
	} else {
		m.addbalance = &si
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *WalletItemsMutation) AddedBalance() (r schema.BigInt, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *WalletItemsMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetWalletID sets the "wallet" edge to the Wallet entity by id.
func (m *WalletItemsMutation) SetWalletID(id string) {
	m.wallet = &id
}

// ClearWallet clears the "wallet" edge to the Wallet entity.
func (m *WalletItemsMutation) ClearWallet() {
	m.clearedwallet = true
}

// WalletCleared reports if the "wallet" edge to the Wallet entity was cleared.
func (m *WalletItemsMutation) WalletCleared() bool {
	return m.clearedwallet
}

// WalletID returns the "wallet" edge ID in the mutation.
func (m *WalletItemsMutation) WalletID() (id string, exists bool) {
	if m.wallet != nil {
		return *m.wallet, true
	}
	return
}

// WalletIDs returns the "wallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WalletID instead. It exists only for internal usage by the builders.
func (m *WalletItemsMutation) WalletIDs() (ids []string) {
	if id := m.wallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWallet resets all changes to the "wallet" edge.
func (m *WalletItemsMutation) ResetWallet() {
	m.wallet = nil
	m.clearedwallet = false
}

// SetItemID sets the "item" edge to the Item entity by id.
func (m *WalletItemsMutation) SetItemID(id string) {
	m.item = &id
}

// ClearItem clears the "item" edge to the Item entity.
func (m *WalletItemsMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the Item entity was cleared.
func (m *WalletItemsMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemID returns the "item" edge ID in the mutation.
func (m *WalletItemsMutation) ItemID() (id string, exists bool) {
	if m.item != nil {
		return *m.item, true
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *WalletItemsMutation) ItemIDs() (ids []string) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *WalletItemsMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// Where appends a list predicates to the WalletItemsMutation builder.
func (m *WalletItemsMutation) Where(ps ...predicate.WalletItems) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WalletItemsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WalletItems).
func (m *WalletItemsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WalletItemsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.balance != nil {
		fields = append(fields, walletitems.FieldBalance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WalletItemsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case walletitems.FieldBalance:
		return m.Balance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WalletItemsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case walletitems.FieldBalance:
		return m.OldBalance(ctx)
	}
	return nil, fmt.Errorf("unknown WalletItems field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletItemsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case walletitems.FieldBalance:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	}
	return fmt.Errorf("unknown WalletItems field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WalletItemsMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, walletitems.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WalletItemsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case walletitems.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletItemsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case walletitems.FieldBalance:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown WalletItems numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WalletItemsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WalletItemsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WalletItemsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WalletItems nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WalletItemsMutation) ResetField(name string) error {
	switch name {
	case walletitems.FieldBalance:
		m.ResetBalance()
		return nil
	}
	return fmt.Errorf("unknown WalletItems field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WalletItemsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.wallet != nil {
		edges = append(edges, walletitems.EdgeWallet)
	}
	if m.item != nil {
		edges = append(edges, walletitems.EdgeItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WalletItemsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case walletitems.EdgeWallet:
		if id := m.wallet; id != nil {
			return []ent.Value{*id}
		}
	case walletitems.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WalletItemsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WalletItemsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WalletItemsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedwallet {
		edges = append(edges, walletitems.EdgeWallet)
	}
	if m.cleareditem {
		edges = append(edges, walletitems.EdgeItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WalletItemsMutation) EdgeCleared(name string) bool {
	switch name {
	case walletitems.EdgeWallet:
		return m.clearedwallet
	case walletitems.EdgeItem:
		return m.cleareditem
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WalletItemsMutation) ClearEdge(name string) error {
	switch name {
	case walletitems.EdgeWallet:
		m.ClearWallet()
		return nil
	case walletitems.EdgeItem:
		m.ClearItem()
		return nil
	}
	return fmt.Errorf("unknown WalletItems unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WalletItemsMutation) ResetEdge(name string) error {
	switch name {
	case walletitems.EdgeWallet:
		m.ResetWallet()
		return nil
	case walletitems.EdgeItem:
		m.ResetItem()
		return nil
	}
	return fmt.Errorf("unknown WalletItems edge %s", name)
}
