"Maps a Time GraphQL scalar to a Go time.Time struct."
scalar Time
"Timestamp is a RFC3339 string."
scalar Timestamp
"Bytes32 is a 32 byte binary string, represented as 0x-prefixed hexadecimal."
scalar Bytes32
"Address is a 20 byte Ethereum address, represented as 0x-prefixed hexadecimal."
scalar Address
"""
Bytes is an arbitrary length binary string, represented as 0x-prefixed hexadecimal.
An empty byte string is represented as '0x'. Byte strings must have an even number of hexadecimal nybbles.
"""
scalar Bytes
"BigInt is a large integer represented as a string."
scalar BigInt
"Long is a 64 bit unsigned integer."
scalar Long

interface Node {
  id: ID!
}

"""
ItemType represents the item slot the item belongs to.
"""
enum ItemType {
  WEAPON
  CLOTHES
  VEHCILE
  WAIST
  FOOT
  HAND
  DRUGS
  NECK
  RING
  ACCESSORY
}

"""
ItemTier represents the tier of an item.
"""
enum ItemTier {
  COMMON
  RARE
  CUSTOM
  BLACK_MARKET
}

type RLEs {
  female: String!
  male: String!
}

type Item implements Node {
  id: ID!
  type: ItemType!
  fullname: String!
  name: String!
  namePrefix: String
  nameSuffix: String
  suffix: String
  augmented: Boolean
  tier: ItemTier!
  greatness: Int!
  count: Int!
  rles: RLEs
  svg: String
}

type WalletItems implements Node {
  id: ID!
  balance: BigInt!
  wallet: Wallet!
  item: Item!
}

enum BodyPartSex {
  MALE
  FEMALE
}

enum BodyPartType {
  BODY
  HAIR
  BEARD
}

type BodyPart implements Node {
  id: ID!
  type: BodyPartType!
  sex: BodyPartSex!
  rle: String!
}

enum HustlerType {
  ORIGINAL_GANGSTA
  REGULAR
}

enum HustlerSex {
  MALE
  FEMALE
}

type Hustler implements Node {
  id: ID!
  type: HustlerType!
  name: String
  title: String
  color: String
  background: String
  age: Long!
  sex: HustlerSex!
  viewbox: [Int!]!
  order: [Int!]!
  svg: String
  body: BodyPart
  hair: BodyPart
  beard: BodyPart
  weapon: Item
  clothes: Item
  vehicle: Item
  waist: Item
  foot: Item
  hand: Item
  drug: Item
  neck: Item
  ring: Item
  accessory: Item
}

type Listing implements Node {
  id: ID!
  source: Source
  active: Boolean!
  inputs: [Asset]!
  outputs: [Asset]!
}

enum AssetType {
  DOPE
  ETH
  EQUIPMENT
  HUSTLER
  TURF
  PAPER
}

enum Source {
  OPENSEA
  SWAPMEET
}

type Asset implements Node {
  id: ID!
  address: Address
  type: AssetType
  symbol: String
  amount: BigInt
  assetId: BigInt
  decimals: Int
}

type Dope implements Node {
  id: ID!
  items: [Item!]!
  claimed: Boolean!
  opened: Boolean!
  score: Int!
  rank: Int!
  listings: [Listing]
  lastSale: Listing
}

type Wallet implements Node {
  id: ID!
  dopes: [Dope!]!
  hustlers: [Hustler!]!
  items: [WalletItems!]!
  paper: BigInt!
}

union SearchResult = Dope | Item | Hustler

input SearchWhereInput {
  not: SearchWhereInput
  and: [SearchWhereInput!]
  or: [SearchWhereInput!]

  paperClaimed: Boolean
  forSale: Boolean
  dopeOpened: Boolean
}

enum SearchOrderField {
  RANK
  AFFORDABLE
  LAST_SALE_AMOUNT
}

input SearchOrder {
  direction: OrderDirection
  field: SearchOrderField
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]!
  wallets(
    after: Cursor
    first: Int
    before: Cursor
    last: Int
    orderBy: WalletOrder
    where: WalletWhereInput
  ): WalletConnection!
  dopes(
    after: Cursor
    first: Int
    before: Cursor
    last: Int
    orderBy: DopeOrder
    where: DopeWhereInput
  ): DopeConnection!
  items(
    after: Cursor
    first: Int
    before: Cursor
    last: Int
    orderBy: ItemOrder
    where: ItemWhereInput
  ): ItemConnection!
  hustlers(
    after: Cursor
    first: Int
    before: Cursor
    last: Int
    orderBy: HustlerOrder
    where: HustlerWhereInput
  ): HustlerConnection!
  search(
    query: String!
    orderBy: SearchOrder
    where: SearchWhereInput
  ): [SearchResult]!
}
