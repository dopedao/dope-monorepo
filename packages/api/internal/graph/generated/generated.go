// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/amount"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/bodypart"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/hustler"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/item"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/listing"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/schema"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/search"
	"github.com/dopedao/dope-monorepo/packages/api/internal/graph/model"
	"github.com/dopedao/dope-monorepo/packages/api/jobs/opensea"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Amount() AmountResolver
	Item() ItemResolver
	Listing() ListingResolver
	Query() QueryResolver
	SeaportOrder() SeaportOrderResolver
	SearchEdge() SearchEdgeResolver
	WyvernOrder() WyvernOrderResolver
	GameHustlerRelationWhereInput() GameHustlerRelationWhereInputResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Amount struct {
		Amount func(childComplexity int) int
		ID     func(childComplexity int) int
		Token  func(childComplexity int) int
		Type   func(childComplexity int) int
	}

	BodyPart struct {
		ID   func(childComplexity int) int
		Rle  func(childComplexity int) int
		Sex  func(childComplexity int) int
		Type func(childComplexity int) int
	}

	Dope struct {
		Claimed  func(childComplexity int) int
		ID       func(childComplexity int) int
		Items    func(childComplexity int) int
		LastSale func(childComplexity int) int
		Listings func(childComplexity int) int
		Opened   func(childComplexity int) int
		Rank     func(childComplexity int) int
		Score    func(childComplexity int) int
	}

	DopeConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	DopeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Hustler struct {
		Accessory  func(childComplexity int) int
		Age        func(childComplexity int) int
		Background func(childComplexity int) int
		Beard      func(childComplexity int) int
		Body       func(childComplexity int) int
		Clothes    func(childComplexity int) int
		Color      func(childComplexity int) int
		Drug       func(childComplexity int) int
		Foot       func(childComplexity int) int
		Hair       func(childComplexity int) int
		Hand       func(childComplexity int) int
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		Neck       func(childComplexity int) int
		Order      func(childComplexity int) int
		Ring       func(childComplexity int) int
		Sex        func(childComplexity int) int
		Svg        func(childComplexity int) int
		Title      func(childComplexity int) int
		Type       func(childComplexity int) int
		Vehicle    func(childComplexity int) int
		Viewbox    func(childComplexity int) int
		Waist      func(childComplexity int) int
		Weapon     func(childComplexity int) int
	}

	HustlerConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	HustlerEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Item struct {
		Augmented  func(childComplexity int) int
		Base       func(childComplexity int) int
		Count      func(childComplexity int) int
		Fullname   func(childComplexity int) int
		Greatness  func(childComplexity int) int
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		NamePrefix func(childComplexity int) int
		NameSuffix func(childComplexity int) int
		Rles       func(childComplexity int) int
		Suffix     func(childComplexity int) int
		Svg        func(childComplexity int) int
		Tier       func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	ItemConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ItemEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Listing struct {
		Active       func(childComplexity int) int
		ID           func(childComplexity int) int
		Inputs       func(childComplexity int) int
		Outputs      func(childComplexity int) int
		SeaportOrder func(childComplexity int) int
		Source       func(childComplexity int) int
		WyvernOrder  func(childComplexity int) int
	}

	ListingConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ListingEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Dopes       func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.DopeOrder, where *ent.DopeWhereInput) int
		Hustlers    func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.HustlerOrder, where *ent.HustlerWhereInput) int
		Items       func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ItemOrder, where *ent.ItemWhereInput) int
		Listings    func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ListingOrder, where *ent.ListingWhereInput) int
		Node        func(childComplexity int, id string) int
		Nodes       func(childComplexity int, ids []string) int
		Search      func(childComplexity int, query string, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.SearchOrder, where *ent.SearchWhereInput) int
		WalletItems func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.WalletItemsOrder, where *ent.WalletItemsWhereInput) int
		Wallets     func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.WalletOrder, where *ent.WalletWhereInput) int
	}

	RLEs struct {
		Female func(childComplexity int) int
		Male   func(childComplexity int) int
	}

	SeaportOrder struct {
		CurrentPrice   func(childComplexity int) int
		ExpirationTime func(childComplexity int) int
		ListingTime    func(childComplexity int) int
		Maker          func(childComplexity int) int
		OrderType      func(childComplexity int) int
		Side           func(childComplexity int) int
	}

	SearchConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	SearchEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Wallet struct {
		Dopes    func(childComplexity int) int
		Hustlers func(childComplexity int) int
		ID       func(childComplexity int) int
		Items    func(childComplexity int) int
		Paper    func(childComplexity int) int
	}

	WalletConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	WalletEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	WalletItems struct {
		Balance func(childComplexity int) int
		ID      func(childComplexity int) int
		Item    func(childComplexity int) int
		Wallet  func(childComplexity int) int
	}

	WalletItemsConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	WalletItemsEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	WyvernOrder struct {
		Calldata           func(childComplexity int) int
		CurrentPrice       func(childComplexity int) int
		Exchange           func(childComplexity int) int
		ExpirationTime     func(childComplexity int) int
		Extra              func(childComplexity int) int
		FeeMethod          func(childComplexity int) int
		FeeRecipient       func(childComplexity int) int
		HowToCall          func(childComplexity int) int
		ListingTime        func(childComplexity int) int
		Maker              func(childComplexity int) int
		MakerProtocolFee   func(childComplexity int) int
		MakerRelayerFee    func(childComplexity int) int
		R                  func(childComplexity int) int
		ReplacementPattern func(childComplexity int) int
		S                  func(childComplexity int) int
		SaleKind           func(childComplexity int) int
		Salt               func(childComplexity int) int
		Side               func(childComplexity int) int
		StaticExtradata    func(childComplexity int) int
		StaticTarget       func(childComplexity int) int
		Target             func(childComplexity int) int
		V                  func(childComplexity int) int
	}
}

type AmountResolver interface {
	Token(ctx context.Context, obj *ent.Amount) (model.Token, error)
}
type ItemResolver interface {
	Fullname(ctx context.Context, obj *ent.Item) (string, error)
}
type ListingResolver interface {
	WyvernOrder(ctx context.Context, obj *ent.Listing) (*opensea.WyvernOrder, error)
	SeaportOrder(ctx context.Context, obj *ent.Listing) (*opensea.SeaportOrder, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id string) (ent.Noder, error)
	Nodes(ctx context.Context, ids []string) ([]ent.Noder, error)
	Wallets(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.WalletOrder, where *ent.WalletWhereInput) (*ent.WalletConnection, error)
	Dopes(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.DopeOrder, where *ent.DopeWhereInput) (*ent.DopeConnection, error)
	Items(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ItemOrder, where *ent.ItemWhereInput) (*ent.ItemConnection, error)
	WalletItems(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.WalletItemsOrder, where *ent.WalletItemsWhereInput) (*ent.WalletItemsConnection, error)
	Hustlers(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.HustlerOrder, where *ent.HustlerWhereInput) (*ent.HustlerConnection, error)
	Listings(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ListingOrder, where *ent.ListingWhereInput) (*ent.ListingConnection, error)
	Search(ctx context.Context, query string, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.SearchOrder, where *ent.SearchWhereInput) (*ent.SearchConnection, error)
}
type SeaportOrderResolver interface {
	Maker(ctx context.Context, obj *opensea.SeaportOrder) (string, error)
	CurrentPrice(ctx context.Context, obj *opensea.SeaportOrder) (string, error)
	ListingTime(ctx context.Context, obj *opensea.SeaportOrder) (uint64, error)
	ExpirationTime(ctx context.Context, obj *opensea.SeaportOrder) (uint64, error)
}
type SearchEdgeResolver interface {
	Node(ctx context.Context, obj *ent.SearchEdge) (model.SearchResult, error)
}
type WyvernOrderResolver interface {
	Exchange(ctx context.Context, obj *opensea.WyvernOrder) (string, error)
	ListingTime(ctx context.Context, obj *opensea.WyvernOrder) (uint64, error)
	ExpirationTime(ctx context.Context, obj *opensea.WyvernOrder) (uint64, error)
	Maker(ctx context.Context, obj *opensea.WyvernOrder) (string, error)
	CurrentPrice(ctx context.Context, obj *opensea.WyvernOrder) (string, error)
	MakerRelayerFee(ctx context.Context, obj *opensea.WyvernOrder) (string, error)
	MakerProtocolFee(ctx context.Context, obj *opensea.WyvernOrder) (string, error)
	FeeRecipient(ctx context.Context, obj *opensea.WyvernOrder) (string, error)
	FeeMethod(ctx context.Context, obj *opensea.WyvernOrder) (int, error)
	Side(ctx context.Context, obj *opensea.WyvernOrder) (int, error)
	SaleKind(ctx context.Context, obj *opensea.WyvernOrder) (int, error)
	Target(ctx context.Context, obj *opensea.WyvernOrder) (string, error)
	HowToCall(ctx context.Context, obj *opensea.WyvernOrder) (int, error)
	Calldata(ctx context.Context, obj *opensea.WyvernOrder) (string, error)
	ReplacementPattern(ctx context.Context, obj *opensea.WyvernOrder) (string, error)
	StaticTarget(ctx context.Context, obj *opensea.WyvernOrder) (string, error)
	StaticExtradata(ctx context.Context, obj *opensea.WyvernOrder) (string, error)
	Extra(ctx context.Context, obj *opensea.WyvernOrder) (string, error)
	Salt(ctx context.Context, obj *opensea.WyvernOrder) (string, error)
	V(ctx context.Context, obj *opensea.WyvernOrder) (int, error)
	R(ctx context.Context, obj *opensea.WyvernOrder) (string, error)
	S(ctx context.Context, obj *opensea.WyvernOrder) (string, error)
}

type GameHustlerRelationWhereInputResolver interface {
	Text(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data *int) error
	TextNeq(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data *int) error
	TextIn(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data []int) error
	TextNotIn(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data []int) error
	TextGt(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data *int) error
	TextGte(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data *int) error
	TextLt(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data *int) error
	TextLte(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data *int) error
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Amount.amount":
		if e.complexity.Amount.Amount == nil {
			break
		}

		return e.complexity.Amount.Amount(childComplexity), true

	case "Amount.id":
		if e.complexity.Amount.ID == nil {
			break
		}

		return e.complexity.Amount.ID(childComplexity), true

	case "Amount.token":
		if e.complexity.Amount.Token == nil {
			break
		}

		return e.complexity.Amount.Token(childComplexity), true

	case "Amount.type":
		if e.complexity.Amount.Type == nil {
			break
		}

		return e.complexity.Amount.Type(childComplexity), true

	case "BodyPart.id":
		if e.complexity.BodyPart.ID == nil {
			break
		}

		return e.complexity.BodyPart.ID(childComplexity), true

	case "BodyPart.rle":
		if e.complexity.BodyPart.Rle == nil {
			break
		}

		return e.complexity.BodyPart.Rle(childComplexity), true

	case "BodyPart.sex":
		if e.complexity.BodyPart.Sex == nil {
			break
		}

		return e.complexity.BodyPart.Sex(childComplexity), true

	case "BodyPart.type":
		if e.complexity.BodyPart.Type == nil {
			break
		}

		return e.complexity.BodyPart.Type(childComplexity), true

	case "Dope.claimed":
		if e.complexity.Dope.Claimed == nil {
			break
		}

		return e.complexity.Dope.Claimed(childComplexity), true

	case "Dope.id":
		if e.complexity.Dope.ID == nil {
			break
		}

		return e.complexity.Dope.ID(childComplexity), true

	case "Dope.items":
		if e.complexity.Dope.Items == nil {
			break
		}

		return e.complexity.Dope.Items(childComplexity), true

	case "Dope.lastSale":
		if e.complexity.Dope.LastSale == nil {
			break
		}

		return e.complexity.Dope.LastSale(childComplexity), true

	case "Dope.listings":
		if e.complexity.Dope.Listings == nil {
			break
		}

		return e.complexity.Dope.Listings(childComplexity), true

	case "Dope.opened":
		if e.complexity.Dope.Opened == nil {
			break
		}

		return e.complexity.Dope.Opened(childComplexity), true

	case "Dope.rank":
		if e.complexity.Dope.Rank == nil {
			break
		}

		return e.complexity.Dope.Rank(childComplexity), true

	case "Dope.score":
		if e.complexity.Dope.Score == nil {
			break
		}

		return e.complexity.Dope.Score(childComplexity), true

	case "DopeConnection.edges":
		if e.complexity.DopeConnection.Edges == nil {
			break
		}

		return e.complexity.DopeConnection.Edges(childComplexity), true

	case "DopeConnection.pageInfo":
		if e.complexity.DopeConnection.PageInfo == nil {
			break
		}

		return e.complexity.DopeConnection.PageInfo(childComplexity), true

	case "DopeConnection.totalCount":
		if e.complexity.DopeConnection.TotalCount == nil {
			break
		}

		return e.complexity.DopeConnection.TotalCount(childComplexity), true

	case "DopeEdge.cursor":
		if e.complexity.DopeEdge.Cursor == nil {
			break
		}

		return e.complexity.DopeEdge.Cursor(childComplexity), true

	case "DopeEdge.node":
		if e.complexity.DopeEdge.Node == nil {
			break
		}

		return e.complexity.DopeEdge.Node(childComplexity), true

	case "Hustler.accessory":
		if e.complexity.Hustler.Accessory == nil {
			break
		}

		return e.complexity.Hustler.Accessory(childComplexity), true

	case "Hustler.age":
		if e.complexity.Hustler.Age == nil {
			break
		}

		return e.complexity.Hustler.Age(childComplexity), true

	case "Hustler.background":
		if e.complexity.Hustler.Background == nil {
			break
		}

		return e.complexity.Hustler.Background(childComplexity), true

	case "Hustler.beard":
		if e.complexity.Hustler.Beard == nil {
			break
		}

		return e.complexity.Hustler.Beard(childComplexity), true

	case "Hustler.body":
		if e.complexity.Hustler.Body == nil {
			break
		}

		return e.complexity.Hustler.Body(childComplexity), true

	case "Hustler.clothes":
		if e.complexity.Hustler.Clothes == nil {
			break
		}

		return e.complexity.Hustler.Clothes(childComplexity), true

	case "Hustler.color":
		if e.complexity.Hustler.Color == nil {
			break
		}

		return e.complexity.Hustler.Color(childComplexity), true

	case "Hustler.drug":
		if e.complexity.Hustler.Drug == nil {
			break
		}

		return e.complexity.Hustler.Drug(childComplexity), true

	case "Hustler.foot":
		if e.complexity.Hustler.Foot == nil {
			break
		}

		return e.complexity.Hustler.Foot(childComplexity), true

	case "Hustler.hair":
		if e.complexity.Hustler.Hair == nil {
			break
		}

		return e.complexity.Hustler.Hair(childComplexity), true

	case "Hustler.hand":
		if e.complexity.Hustler.Hand == nil {
			break
		}

		return e.complexity.Hustler.Hand(childComplexity), true

	case "Hustler.id":
		if e.complexity.Hustler.ID == nil {
			break
		}

		return e.complexity.Hustler.ID(childComplexity), true

	case "Hustler.name":
		if e.complexity.Hustler.Name == nil {
			break
		}

		return e.complexity.Hustler.Name(childComplexity), true

	case "Hustler.neck":
		if e.complexity.Hustler.Neck == nil {
			break
		}

		return e.complexity.Hustler.Neck(childComplexity), true

	case "Hustler.order":
		if e.complexity.Hustler.Order == nil {
			break
		}

		return e.complexity.Hustler.Order(childComplexity), true

	case "Hustler.ring":
		if e.complexity.Hustler.Ring == nil {
			break
		}

		return e.complexity.Hustler.Ring(childComplexity), true

	case "Hustler.sex":
		if e.complexity.Hustler.Sex == nil {
			break
		}

		return e.complexity.Hustler.Sex(childComplexity), true

	case "Hustler.svg":
		if e.complexity.Hustler.Svg == nil {
			break
		}

		return e.complexity.Hustler.Svg(childComplexity), true

	case "Hustler.title":
		if e.complexity.Hustler.Title == nil {
			break
		}

		return e.complexity.Hustler.Title(childComplexity), true

	case "Hustler.type":
		if e.complexity.Hustler.Type == nil {
			break
		}

		return e.complexity.Hustler.Type(childComplexity), true

	case "Hustler.vehicle":
		if e.complexity.Hustler.Vehicle == nil {
			break
		}

		return e.complexity.Hustler.Vehicle(childComplexity), true

	case "Hustler.viewbox":
		if e.complexity.Hustler.Viewbox == nil {
			break
		}

		return e.complexity.Hustler.Viewbox(childComplexity), true

	case "Hustler.waist":
		if e.complexity.Hustler.Waist == nil {
			break
		}

		return e.complexity.Hustler.Waist(childComplexity), true

	case "Hustler.weapon":
		if e.complexity.Hustler.Weapon == nil {
			break
		}

		return e.complexity.Hustler.Weapon(childComplexity), true

	case "HustlerConnection.edges":
		if e.complexity.HustlerConnection.Edges == nil {
			break
		}

		return e.complexity.HustlerConnection.Edges(childComplexity), true

	case "HustlerConnection.pageInfo":
		if e.complexity.HustlerConnection.PageInfo == nil {
			break
		}

		return e.complexity.HustlerConnection.PageInfo(childComplexity), true

	case "HustlerConnection.totalCount":
		if e.complexity.HustlerConnection.TotalCount == nil {
			break
		}

		return e.complexity.HustlerConnection.TotalCount(childComplexity), true

	case "HustlerEdge.cursor":
		if e.complexity.HustlerEdge.Cursor == nil {
			break
		}

		return e.complexity.HustlerEdge.Cursor(childComplexity), true

	case "HustlerEdge.node":
		if e.complexity.HustlerEdge.Node == nil {
			break
		}

		return e.complexity.HustlerEdge.Node(childComplexity), true

	case "Item.augmented":
		if e.complexity.Item.Augmented == nil {
			break
		}

		return e.complexity.Item.Augmented(childComplexity), true

	case "Item.base":
		if e.complexity.Item.Base == nil {
			break
		}

		return e.complexity.Item.Base(childComplexity), true

	case "Item.count":
		if e.complexity.Item.Count == nil {
			break
		}

		return e.complexity.Item.Count(childComplexity), true

	case "Item.fullname":
		if e.complexity.Item.Fullname == nil {
			break
		}

		return e.complexity.Item.Fullname(childComplexity), true

	case "Item.greatness":
		if e.complexity.Item.Greatness == nil {
			break
		}

		return e.complexity.Item.Greatness(childComplexity), true

	case "Item.id":
		if e.complexity.Item.ID == nil {
			break
		}

		return e.complexity.Item.ID(childComplexity), true

	case "Item.name":
		if e.complexity.Item.Name == nil {
			break
		}

		return e.complexity.Item.Name(childComplexity), true

	case "Item.namePrefix":
		if e.complexity.Item.NamePrefix == nil {
			break
		}

		return e.complexity.Item.NamePrefix(childComplexity), true

	case "Item.nameSuffix":
		if e.complexity.Item.NameSuffix == nil {
			break
		}

		return e.complexity.Item.NameSuffix(childComplexity), true

	case "Item.rles":
		if e.complexity.Item.Rles == nil {
			break
		}

		return e.complexity.Item.Rles(childComplexity), true

	case "Item.suffix":
		if e.complexity.Item.Suffix == nil {
			break
		}

		return e.complexity.Item.Suffix(childComplexity), true

	case "Item.svg":
		if e.complexity.Item.Svg == nil {
			break
		}

		return e.complexity.Item.Svg(childComplexity), true

	case "Item.tier":
		if e.complexity.Item.Tier == nil {
			break
		}

		return e.complexity.Item.Tier(childComplexity), true

	case "Item.type":
		if e.complexity.Item.Type == nil {
			break
		}

		return e.complexity.Item.Type(childComplexity), true

	case "ItemConnection.edges":
		if e.complexity.ItemConnection.Edges == nil {
			break
		}

		return e.complexity.ItemConnection.Edges(childComplexity), true

	case "ItemConnection.pageInfo":
		if e.complexity.ItemConnection.PageInfo == nil {
			break
		}

		return e.complexity.ItemConnection.PageInfo(childComplexity), true

	case "ItemConnection.totalCount":
		if e.complexity.ItemConnection.TotalCount == nil {
			break
		}

		return e.complexity.ItemConnection.TotalCount(childComplexity), true

	case "ItemEdge.cursor":
		if e.complexity.ItemEdge.Cursor == nil {
			break
		}

		return e.complexity.ItemEdge.Cursor(childComplexity), true

	case "ItemEdge.node":
		if e.complexity.ItemEdge.Node == nil {
			break
		}

		return e.complexity.ItemEdge.Node(childComplexity), true

	case "Listing.active":
		if e.complexity.Listing.Active == nil {
			break
		}

		return e.complexity.Listing.Active(childComplexity), true

	case "Listing.id":
		if e.complexity.Listing.ID == nil {
			break
		}

		return e.complexity.Listing.ID(childComplexity), true

	case "Listing.inputs":
		if e.complexity.Listing.Inputs == nil {
			break
		}

		return e.complexity.Listing.Inputs(childComplexity), true

	case "Listing.outputs":
		if e.complexity.Listing.Outputs == nil {
			break
		}

		return e.complexity.Listing.Outputs(childComplexity), true

	case "Listing.seaportOrder":
		if e.complexity.Listing.SeaportOrder == nil {
			break
		}

		return e.complexity.Listing.SeaportOrder(childComplexity), true

	case "Listing.source":
		if e.complexity.Listing.Source == nil {
			break
		}

		return e.complexity.Listing.Source(childComplexity), true

	case "Listing.wyvernOrder":
		if e.complexity.Listing.WyvernOrder == nil {
			break
		}

		return e.complexity.Listing.WyvernOrder(childComplexity), true

	case "ListingConnection.edges":
		if e.complexity.ListingConnection.Edges == nil {
			break
		}

		return e.complexity.ListingConnection.Edges(childComplexity), true

	case "ListingConnection.pageInfo":
		if e.complexity.ListingConnection.PageInfo == nil {
			break
		}

		return e.complexity.ListingConnection.PageInfo(childComplexity), true

	case "ListingConnection.totalCount":
		if e.complexity.ListingConnection.TotalCount == nil {
			break
		}

		return e.complexity.ListingConnection.TotalCount(childComplexity), true

	case "ListingEdge.cursor":
		if e.complexity.ListingEdge.Cursor == nil {
			break
		}

		return e.complexity.ListingEdge.Cursor(childComplexity), true

	case "ListingEdge.node":
		if e.complexity.ListingEdge.Node == nil {
			break
		}

		return e.complexity.ListingEdge.Node(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.dopes":
		if e.complexity.Query.Dopes == nil {
			break
		}

		args, err := ec.field_Query_dopes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Dopes(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.DopeOrder), args["where"].(*ent.DopeWhereInput)), true

	case "Query.hustlers":
		if e.complexity.Query.Hustlers == nil {
			break
		}

		args, err := ec.field_Query_hustlers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Hustlers(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.HustlerOrder), args["where"].(*ent.HustlerWhereInput)), true

	case "Query.items":
		if e.complexity.Query.Items == nil {
			break
		}

		args, err := ec.field_Query_items_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Items(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.ItemOrder), args["where"].(*ent.ItemWhereInput)), true

	case "Query.listings":
		if e.complexity.Query.Listings == nil {
			break
		}

		args, err := ec.field_Query_listings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Listings(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.ListingOrder), args["where"].(*ent.ListingWhereInput)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(string)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]string)), true

	case "Query.search":
		if e.complexity.Query.Search == nil {
			break
		}

		args, err := ec.field_Query_search_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Search(childComplexity, args["query"].(string), args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.SearchOrder), args["where"].(*ent.SearchWhereInput)), true

	case "Query.walletItems":
		if e.complexity.Query.WalletItems == nil {
			break
		}

		args, err := ec.field_Query_walletItems_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.WalletItems(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.WalletItemsOrder), args["where"].(*ent.WalletItemsWhereInput)), true

	case "Query.wallets":
		if e.complexity.Query.Wallets == nil {
			break
		}

		args, err := ec.field_Query_wallets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Wallets(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.WalletOrder), args["where"].(*ent.WalletWhereInput)), true

	case "RLEs.female":
		if e.complexity.RLEs.Female == nil {
			break
		}

		return e.complexity.RLEs.Female(childComplexity), true

	case "RLEs.male":
		if e.complexity.RLEs.Male == nil {
			break
		}

		return e.complexity.RLEs.Male(childComplexity), true

	case "SeaportOrder.currentPrice":
		if e.complexity.SeaportOrder.CurrentPrice == nil {
			break
		}

		return e.complexity.SeaportOrder.CurrentPrice(childComplexity), true

	case "SeaportOrder.expirationTime":
		if e.complexity.SeaportOrder.ExpirationTime == nil {
			break
		}

		return e.complexity.SeaportOrder.ExpirationTime(childComplexity), true

	case "SeaportOrder.listingTime":
		if e.complexity.SeaportOrder.ListingTime == nil {
			break
		}

		return e.complexity.SeaportOrder.ListingTime(childComplexity), true

	case "SeaportOrder.maker":
		if e.complexity.SeaportOrder.Maker == nil {
			break
		}

		return e.complexity.SeaportOrder.Maker(childComplexity), true

	case "SeaportOrder.orderType":
		if e.complexity.SeaportOrder.OrderType == nil {
			break
		}

		return e.complexity.SeaportOrder.OrderType(childComplexity), true

	case "SeaportOrder.side":
		if e.complexity.SeaportOrder.Side == nil {
			break
		}

		return e.complexity.SeaportOrder.Side(childComplexity), true

	case "SearchConnection.edges":
		if e.complexity.SearchConnection.Edges == nil {
			break
		}

		return e.complexity.SearchConnection.Edges(childComplexity), true

	case "SearchConnection.pageInfo":
		if e.complexity.SearchConnection.PageInfo == nil {
			break
		}

		return e.complexity.SearchConnection.PageInfo(childComplexity), true

	case "SearchConnection.totalCount":
		if e.complexity.SearchConnection.TotalCount == nil {
			break
		}

		return e.complexity.SearchConnection.TotalCount(childComplexity), true

	case "SearchEdge.cursor":
		if e.complexity.SearchEdge.Cursor == nil {
			break
		}

		return e.complexity.SearchEdge.Cursor(childComplexity), true

	case "SearchEdge.node":
		if e.complexity.SearchEdge.Node == nil {
			break
		}

		return e.complexity.SearchEdge.Node(childComplexity), true

	case "Wallet.dopes":
		if e.complexity.Wallet.Dopes == nil {
			break
		}

		return e.complexity.Wallet.Dopes(childComplexity), true

	case "Wallet.hustlers":
		if e.complexity.Wallet.Hustlers == nil {
			break
		}

		return e.complexity.Wallet.Hustlers(childComplexity), true

	case "Wallet.id":
		if e.complexity.Wallet.ID == nil {
			break
		}

		return e.complexity.Wallet.ID(childComplexity), true

	case "Wallet.items":
		if e.complexity.Wallet.Items == nil {
			break
		}

		return e.complexity.Wallet.Items(childComplexity), true

	case "Wallet.paper":
		if e.complexity.Wallet.Paper == nil {
			break
		}

		return e.complexity.Wallet.Paper(childComplexity), true

	case "WalletConnection.edges":
		if e.complexity.WalletConnection.Edges == nil {
			break
		}

		return e.complexity.WalletConnection.Edges(childComplexity), true

	case "WalletConnection.pageInfo":
		if e.complexity.WalletConnection.PageInfo == nil {
			break
		}

		return e.complexity.WalletConnection.PageInfo(childComplexity), true

	case "WalletConnection.totalCount":
		if e.complexity.WalletConnection.TotalCount == nil {
			break
		}

		return e.complexity.WalletConnection.TotalCount(childComplexity), true

	case "WalletEdge.cursor":
		if e.complexity.WalletEdge.Cursor == nil {
			break
		}

		return e.complexity.WalletEdge.Cursor(childComplexity), true

	case "WalletEdge.node":
		if e.complexity.WalletEdge.Node == nil {
			break
		}

		return e.complexity.WalletEdge.Node(childComplexity), true

	case "WalletItems.balance":
		if e.complexity.WalletItems.Balance == nil {
			break
		}

		return e.complexity.WalletItems.Balance(childComplexity), true

	case "WalletItems.id":
		if e.complexity.WalletItems.ID == nil {
			break
		}

		return e.complexity.WalletItems.ID(childComplexity), true

	case "WalletItems.item":
		if e.complexity.WalletItems.Item == nil {
			break
		}

		return e.complexity.WalletItems.Item(childComplexity), true

	case "WalletItems.wallet":
		if e.complexity.WalletItems.Wallet == nil {
			break
		}

		return e.complexity.WalletItems.Wallet(childComplexity), true

	case "WalletItemsConnection.edges":
		if e.complexity.WalletItemsConnection.Edges == nil {
			break
		}

		return e.complexity.WalletItemsConnection.Edges(childComplexity), true

	case "WalletItemsConnection.pageInfo":
		if e.complexity.WalletItemsConnection.PageInfo == nil {
			break
		}

		return e.complexity.WalletItemsConnection.PageInfo(childComplexity), true

	case "WalletItemsConnection.totalCount":
		if e.complexity.WalletItemsConnection.TotalCount == nil {
			break
		}

		return e.complexity.WalletItemsConnection.TotalCount(childComplexity), true

	case "WalletItemsEdge.cursor":
		if e.complexity.WalletItemsEdge.Cursor == nil {
			break
		}

		return e.complexity.WalletItemsEdge.Cursor(childComplexity), true

	case "WalletItemsEdge.node":
		if e.complexity.WalletItemsEdge.Node == nil {
			break
		}

		return e.complexity.WalletItemsEdge.Node(childComplexity), true

	case "WyvernOrder.calldata":
		if e.complexity.WyvernOrder.Calldata == nil {
			break
		}

		return e.complexity.WyvernOrder.Calldata(childComplexity), true

	case "WyvernOrder.currentPrice":
		if e.complexity.WyvernOrder.CurrentPrice == nil {
			break
		}

		return e.complexity.WyvernOrder.CurrentPrice(childComplexity), true

	case "WyvernOrder.exchange":
		if e.complexity.WyvernOrder.Exchange == nil {
			break
		}

		return e.complexity.WyvernOrder.Exchange(childComplexity), true

	case "WyvernOrder.expirationTime":
		if e.complexity.WyvernOrder.ExpirationTime == nil {
			break
		}

		return e.complexity.WyvernOrder.ExpirationTime(childComplexity), true

	case "WyvernOrder.extra":
		if e.complexity.WyvernOrder.Extra == nil {
			break
		}

		return e.complexity.WyvernOrder.Extra(childComplexity), true

	case "WyvernOrder.feeMethod":
		if e.complexity.WyvernOrder.FeeMethod == nil {
			break
		}

		return e.complexity.WyvernOrder.FeeMethod(childComplexity), true

	case "WyvernOrder.feeRecipient":
		if e.complexity.WyvernOrder.FeeRecipient == nil {
			break
		}

		return e.complexity.WyvernOrder.FeeRecipient(childComplexity), true

	case "WyvernOrder.howToCall":
		if e.complexity.WyvernOrder.HowToCall == nil {
			break
		}

		return e.complexity.WyvernOrder.HowToCall(childComplexity), true

	case "WyvernOrder.listingTime":
		if e.complexity.WyvernOrder.ListingTime == nil {
			break
		}

		return e.complexity.WyvernOrder.ListingTime(childComplexity), true

	case "WyvernOrder.maker":
		if e.complexity.WyvernOrder.Maker == nil {
			break
		}

		return e.complexity.WyvernOrder.Maker(childComplexity), true

	case "WyvernOrder.makerProtocolFee":
		if e.complexity.WyvernOrder.MakerProtocolFee == nil {
			break
		}

		return e.complexity.WyvernOrder.MakerProtocolFee(childComplexity), true

	case "WyvernOrder.makerRelayerFee":
		if e.complexity.WyvernOrder.MakerRelayerFee == nil {
			break
		}

		return e.complexity.WyvernOrder.MakerRelayerFee(childComplexity), true

	case "WyvernOrder.r":
		if e.complexity.WyvernOrder.R == nil {
			break
		}

		return e.complexity.WyvernOrder.R(childComplexity), true

	case "WyvernOrder.replacementPattern":
		if e.complexity.WyvernOrder.ReplacementPattern == nil {
			break
		}

		return e.complexity.WyvernOrder.ReplacementPattern(childComplexity), true

	case "WyvernOrder.s":
		if e.complexity.WyvernOrder.S == nil {
			break
		}

		return e.complexity.WyvernOrder.S(childComplexity), true

	case "WyvernOrder.saleKind":
		if e.complexity.WyvernOrder.SaleKind == nil {
			break
		}

		return e.complexity.WyvernOrder.SaleKind(childComplexity), true

	case "WyvernOrder.salt":
		if e.complexity.WyvernOrder.Salt == nil {
			break
		}

		return e.complexity.WyvernOrder.Salt(childComplexity), true

	case "WyvernOrder.side":
		if e.complexity.WyvernOrder.Side == nil {
			break
		}

		return e.complexity.WyvernOrder.Side(childComplexity), true

	case "WyvernOrder.staticExtradata":
		if e.complexity.WyvernOrder.StaticExtradata == nil {
			break
		}

		return e.complexity.WyvernOrder.StaticExtradata(childComplexity), true

	case "WyvernOrder.staticTarget":
		if e.complexity.WyvernOrder.StaticTarget == nil {
			break
		}

		return e.complexity.WyvernOrder.StaticTarget(childComplexity), true

	case "WyvernOrder.target":
		if e.complexity.WyvernOrder.Target == nil {
			break
		}

		return e.complexity.WyvernOrder.Target(childComplexity), true

	case "WyvernOrder.v":
		if e.complexity.WyvernOrder.V == nil {
			break
		}

		return e.complexity.WyvernOrder.V(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "graph/ent.graphql", Input: `"""
ItemWhereInput is used for filtering Item objects.
Input was generated by ent.
"""
input ItemWhereInput {
  not: ItemWhereInput
  and: [ItemWhereInput!]
  or: [ItemWhereInput!]
  
  """type field predicates"""
  type: ItemType
  typeNEQ: ItemType
  typeIn: [ItemType!]
  typeNotIn: [ItemType!]
  
  """name_prefix field predicates"""
  namePrefix: String
  namePrefixNEQ: String
  namePrefixIn: [String!]
  namePrefixNotIn: [String!]
  namePrefixGT: String
  namePrefixGTE: String
  namePrefixLT: String
  namePrefixLTE: String
  namePrefixContains: String
  namePrefixHasPrefix: String
  namePrefixHasSuffix: String
  namePrefixIsNil: Boolean
  namePrefixNotNil: Boolean
  namePrefixEqualFold: String
  namePrefixContainsFold: String
  
  """name_suffix field predicates"""
  nameSuffix: String
  nameSuffixNEQ: String
  nameSuffixIn: [String!]
  nameSuffixNotIn: [String!]
  nameSuffixGT: String
  nameSuffixGTE: String
  nameSuffixLT: String
  nameSuffixLTE: String
  nameSuffixContains: String
  nameSuffixHasPrefix: String
  nameSuffixHasSuffix: String
  nameSuffixIsNil: Boolean
  nameSuffixNotNil: Boolean
  nameSuffixEqualFold: String
  nameSuffixContainsFold: String
  
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  
  """suffix field predicates"""
  suffix: String
  suffixNEQ: String
  suffixIn: [String!]
  suffixNotIn: [String!]
  suffixGT: String
  suffixGTE: String
  suffixLT: String
  suffixLTE: String
  suffixContains: String
  suffixHasPrefix: String
  suffixHasSuffix: String
  suffixIsNil: Boolean
  suffixNotNil: Boolean
  suffixEqualFold: String
  suffixContainsFold: String
  
  """augmented field predicates"""
  augmented: Boolean
  augmentedNEQ: Boolean
  augmentedIsNil: Boolean
  augmentedNotNil: Boolean
  
  """count field predicates"""
  count: Int
  countNEQ: Int
  countIn: [Int!]
  countNotIn: [Int!]
  countGT: Int
  countGTE: Int
  countLT: Int
  countLTE: Int
  countIsNil: Boolean
  countNotNil: Boolean
  
  """tier field predicates"""
  tier: ItemTier
  tierNEQ: ItemTier
  tierIn: [ItemTier!]
  tierNotIn: [ItemTier!]
  tierIsNil: Boolean
  tierNotNil: Boolean
  
  """greatness field predicates"""
  greatness: Int
  greatnessNEQ: Int
  greatnessIn: [Int!]
  greatnessNotIn: [Int!]
  greatnessGT: Int
  greatnessGTE: Int
  greatnessLT: Int
  greatnessLTE: Int
  greatnessIsNil: Boolean
  greatnessNotNil: Boolean
  
  """svg field predicates"""
  svg: String
  svgNEQ: String
  svgIn: [String!]
  svgNotIn: [String!]
  svgGT: String
  svgGTE: String
  svgLT: String
  svgLTE: String
  svgContains: String
  svgHasPrefix: String
  svgHasSuffix: String
  svgIsNil: Boolean
  svgNotNil: Boolean
  svgEqualFold: String
  svgContainsFold: String
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  
  """wallets edge predicates"""
  hasWallets: Boolean
  hasWalletsWith: [WalletItemsWhereInput!]
  
  """dopes edge predicates"""
  hasDopes: Boolean
  hasDopesWith: [DopeWhereInput!]
  
  """hustler_weapons edge predicates"""
  hasHustlerWeapons: Boolean
  hasHustlerWeaponsWith: [HustlerWhereInput!]
  
  """hustler_clothes edge predicates"""
  hasHustlerClothes: Boolean
  hasHustlerClothesWith: [HustlerWhereInput!]
  
  """hustler_vehicles edge predicates"""
  hasHustlerVehicles: Boolean
  hasHustlerVehiclesWith: [HustlerWhereInput!]
  
  """hustler_waists edge predicates"""
  hasHustlerWaists: Boolean
  hasHustlerWaistsWith: [HustlerWhereInput!]
  
  """hustler_feet edge predicates"""
  hasHustlerFeet: Boolean
  hasHustlerFeetWith: [HustlerWhereInput!]
  
  """hustler_hands edge predicates"""
  hasHustlerHands: Boolean
  hasHustlerHandsWith: [HustlerWhereInput!]
  
  """hustler_drugs edge predicates"""
  hasHustlerDrugs: Boolean
  hasHustlerDrugsWith: [HustlerWhereInput!]
  
  """hustler_necks edge predicates"""
  hasHustlerNecks: Boolean
  hasHustlerNecksWith: [HustlerWhereInput!]
  
  """hustler_rings edge predicates"""
  hasHustlerRings: Boolean
  hasHustlerRingsWith: [HustlerWhereInput!]
  
  """hustler_accessories edge predicates"""
  hasHustlerAccessories: Boolean
  hasHustlerAccessoriesWith: [HustlerWhereInput!]
  
  """base edge predicates"""
  hasBase: Boolean
  hasBaseWith: [ItemWhereInput!]
  
  """derivative edge predicates"""
  hasDerivative: Boolean
  hasDerivativeWith: [ItemWhereInput!]
  
  """index edge predicates"""
  hasIndex: Boolean
  hasIndexWith: [SearchWhereInput!]
}

"""
SyncStateWhereInput is used for filtering SyncState objects.
Input was generated by ent.
"""
input SyncStateWhereInput {
  not: SyncStateWhereInput
  and: [SyncStateWhereInput!]
  or: [SyncStateWhereInput!]
  
  """start_block field predicates"""
  startBlock: Long
  startBlockNEQ: Long
  startBlockIn: [Long!]
  startBlockNotIn: [Long!]
  startBlockGT: Long
  startBlockGTE: Long
  startBlockLT: Long
  startBlockLTE: Long
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
}

"""
WalletWhereInput is used for filtering Wallet objects.
Input was generated by ent.
"""
input WalletWhereInput {
  not: WalletWhereInput
  and: [WalletWhereInput!]
  or: [WalletWhereInput!]
  
  """paper field predicates"""
  paper: BigInt
  paperNEQ: BigInt
  paperIn: [BigInt!]
  paperNotIn: [BigInt!]
  paperGT: BigInt
  paperGTE: BigInt
  paperLT: BigInt
  paperLTE: BigInt
  
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  
  """dopes edge predicates"""
  hasDopes: Boolean
  hasDopesWith: [DopeWhereInput!]
  
  """items edge predicates"""
  hasItems: Boolean
  hasItemsWith: [WalletItemsWhereInput!]
  
  """hustlers edge predicates"""
  hasHustlers: Boolean
  hasHustlersWith: [HustlerWhereInput!]
}

"""
WalletItemsWhereInput is used for filtering WalletItems objects.
Input was generated by ent.
"""
input WalletItemsWhereInput {
  not: WalletItemsWhereInput
  and: [WalletItemsWhereInput!]
  or: [WalletItemsWhereInput!]
  
  """balance field predicates"""
  balance: BigInt
  balanceNEQ: BigInt
  balanceIn: [BigInt!]
  balanceNotIn: [BigInt!]
  balanceGT: BigInt
  balanceGTE: BigInt
  balanceLT: BigInt
  balanceLTE: BigInt
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  
  """wallet edge predicates"""
  hasWallet: Boolean
  hasWalletWith: [WalletWhereInput!]
  
  """item edge predicates"""
  hasItem: Boolean
  hasItemWith: [ItemWhereInput!]
}

"""
BodyPartWhereInput is used for filtering BodyPart objects.
Input was generated by ent.
"""
input BodyPartWhereInput {
  not: BodyPartWhereInput
  and: [BodyPartWhereInput!]
  or: [BodyPartWhereInput!]
  
  """type field predicates"""
  type: BodyPartType
  typeNEQ: BodyPartType
  typeIn: [BodyPartType!]
  typeNotIn: [BodyPartType!]
  
  """sex field predicates"""
  sex: BodyPartSex
  sexNEQ: BodyPartSex
  sexIn: [BodyPartSex!]
  sexNotIn: [BodyPartSex!]
  
  """rle field predicates"""
  rle: String
  rleNEQ: String
  rleIn: [String!]
  rleNotIn: [String!]
  rleGT: String
  rleGTE: String
  rleLT: String
  rleLTE: String
  rleContains: String
  rleHasPrefix: String
  rleHasSuffix: String
  rleEqualFold: String
  rleContainsFold: String
  
  """sprite field predicates"""
  sprite: String
  spriteNEQ: String
  spriteIn: [String!]
  spriteNotIn: [String!]
  spriteGT: String
  spriteGTE: String
  spriteLT: String
  spriteLTE: String
  spriteContains: String
  spriteHasPrefix: String
  spriteHasSuffix: String
  spriteIsNil: Boolean
  spriteNotNil: Boolean
  spriteEqualFold: String
  spriteContainsFold: String
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  
  """hustler_bodies edge predicates"""
  hasHustlerBodies: Boolean
  hasHustlerBodiesWith: [HustlerWhereInput!]
  
  """hustler_hairs edge predicates"""
  hasHustlerHairs: Boolean
  hasHustlerHairsWith: [HustlerWhereInput!]
  
  """hustler_beards edge predicates"""
  hasHustlerBeards: Boolean
  hasHustlerBeardsWith: [HustlerWhereInput!]
}

"""
DopeWhereInput is used for filtering Dope objects.
Input was generated by ent.
"""
input DopeWhereInput {
  not: DopeWhereInput
  and: [DopeWhereInput!]
  or: [DopeWhereInput!]
  
  """claimed field predicates"""
  claimed: Boolean
  claimedNEQ: Boolean
  
  """opened field predicates"""
  opened: Boolean
  openedNEQ: Boolean
  
  """score field predicates"""
  score: Int
  scoreNEQ: Int
  scoreIn: [Int!]
  scoreNotIn: [Int!]
  scoreGT: Int
  scoreGTE: Int
  scoreLT: Int
  scoreLTE: Int
  scoreIsNil: Boolean
  scoreNotNil: Boolean
  
  """rank field predicates"""
  rank: Int
  rankNEQ: Int
  rankIn: [Int!]
  rankNotIn: [Int!]
  rankGT: Int
  rankGTE: Int
  rankLT: Int
  rankLTE: Int
  rankIsNil: Boolean
  rankNotNil: Boolean
  
  """order field predicates"""
  order: Int
  orderNEQ: Int
  orderIn: [Int!]
  orderNotIn: [Int!]
  orderGT: Int
  orderGTE: Int
  orderLT: Int
  orderLTE: Int
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  
  """wallet edge predicates"""
  hasWallet: Boolean
  hasWalletWith: [WalletWhereInput!]
  
  """last_sale edge predicates"""
  hasLastSale: Boolean
  hasLastSaleWith: [ListingWhereInput!]
  
  """listings edge predicates"""
  hasListings: Boolean
  hasListingsWith: [ListingWhereInput!]
  
  """items edge predicates"""
  hasItems: Boolean
  hasItemsWith: [ItemWhereInput!]
  
  """index edge predicates"""
  hasIndex: Boolean
  hasIndexWith: [SearchWhereInput!]
}

"""
HustlerWhereInput is used for filtering Hustler objects.
Input was generated by ent.
"""
input HustlerWhereInput {
  not: HustlerWhereInput
  and: [HustlerWhereInput!]
  or: [HustlerWhereInput!]
  
  """type field predicates"""
  type: HustlerType
  typeNEQ: HustlerType
  typeIn: [HustlerType!]
  typeNotIn: [HustlerType!]
  
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameIsNil: Boolean
  nameNotNil: Boolean
  nameEqualFold: String
  nameContainsFold: String
  
  """title field predicates"""
  title: String
  titleNEQ: String
  titleIn: [String!]
  titleNotIn: [String!]
  titleGT: String
  titleGTE: String
  titleLT: String
  titleLTE: String
  titleContains: String
  titleHasPrefix: String
  titleHasSuffix: String
  titleIsNil: Boolean
  titleNotNil: Boolean
  titleEqualFold: String
  titleContainsFold: String
  
  """color field predicates"""
  color: String
  colorNEQ: String
  colorIn: [String!]
  colorNotIn: [String!]
  colorGT: String
  colorGTE: String
  colorLT: String
  colorLTE: String
  colorContains: String
  colorHasPrefix: String
  colorHasSuffix: String
  colorIsNil: Boolean
  colorNotNil: Boolean
  colorEqualFold: String
  colorContainsFold: String
  
  """background field predicates"""
  background: String
  backgroundNEQ: String
  backgroundIn: [String!]
  backgroundNotIn: [String!]
  backgroundGT: String
  backgroundGTE: String
  backgroundLT: String
  backgroundLTE: String
  backgroundContains: String
  backgroundHasPrefix: String
  backgroundHasSuffix: String
  backgroundIsNil: Boolean
  backgroundNotNil: Boolean
  backgroundEqualFold: String
  backgroundContainsFold: String
  
  """age field predicates"""
  age: Long
  ageNEQ: Long
  ageIn: [Long!]
  ageNotIn: [Long!]
  ageGT: Long
  ageGTE: Long
  ageLT: Long
  ageLTE: Long
  
  """sex field predicates"""
  sex: HustlerSex
  sexNEQ: HustlerSex
  sexIn: [HustlerSex!]
  sexNotIn: [HustlerSex!]
  
  """svg field predicates"""
  svg: String
  svgNEQ: String
  svgIn: [String!]
  svgNotIn: [String!]
  svgGT: String
  svgGTE: String
  svgLT: String
  svgLTE: String
  svgContains: String
  svgHasPrefix: String
  svgHasSuffix: String
  svgIsNil: Boolean
  svgNotNil: Boolean
  svgEqualFold: String
  svgContainsFold: String
  
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  
  """wallet edge predicates"""
  hasWallet: Boolean
  hasWalletWith: [WalletWhereInput!]
  
  """weapon edge predicates"""
  hasWeapon: Boolean
  hasWeaponWith: [ItemWhereInput!]
  
  """clothes edge predicates"""
  hasClothes: Boolean
  hasClothesWith: [ItemWhereInput!]
  
  """vehicle edge predicates"""
  hasVehicle: Boolean
  hasVehicleWith: [ItemWhereInput!]
  
  """waist edge predicates"""
  hasWaist: Boolean
  hasWaistWith: [ItemWhereInput!]
  
  """foot edge predicates"""
  hasFoot: Boolean
  hasFootWith: [ItemWhereInput!]
  
  """hand edge predicates"""
  hasHand: Boolean
  hasHandWith: [ItemWhereInput!]
  
  """drug edge predicates"""
  hasDrug: Boolean
  hasDrugWith: [ItemWhereInput!]
  
  """neck edge predicates"""
  hasNeck: Boolean
  hasNeckWith: [ItemWhereInput!]
  
  """ring edge predicates"""
  hasRing: Boolean
  hasRingWith: [ItemWhereInput!]
  
  """accessory edge predicates"""
  hasAccessory: Boolean
  hasAccessoryWith: [ItemWhereInput!]
  
  """body edge predicates"""
  hasBody: Boolean
  hasBodyWith: [BodyPartWhereInput!]
  
  """hair edge predicates"""
  hasHair: Boolean
  hasHairWith: [BodyPartWhereInput!]
  
  """beard edge predicates"""
  hasBeard: Boolean
  hasBeardWith: [BodyPartWhereInput!]
  
  """index edge predicates"""
  hasIndex: Boolean
  hasIndexWith: [SearchWhereInput!]
}

"""
EventWhereInput is used for filtering Event objects.
Input was generated by ent.
"""
input EventWhereInput {
  not: EventWhereInput
  and: [EventWhereInput!]
  or: [EventWhereInput!]
  
  """index field predicates"""
  index: Long
  indexNEQ: Long
  indexIn: [Long!]
  indexNotIn: [Long!]
  indexGT: Long
  indexGTE: Long
  indexLT: Long
  indexLTE: Long
  
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
}

"""
ListingWhereInput is used for filtering Listing objects.
Input was generated by ent.
"""
input ListingWhereInput {
  not: ListingWhereInput
  and: [ListingWhereInput!]
  or: [ListingWhereInput!]
  
  """active field predicates"""
  active: Boolean
  activeNEQ: Boolean
  
  """source field predicates"""
  source: Source
  sourceNEQ: Source
  sourceIn: [Source!]
  sourceNotIn: [Source!]
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  
  """dope edge predicates"""
  hasDope: Boolean
  hasDopeWith: [DopeWhereInput!]
  
  """dope_lastsales edge predicates"""
  hasDopeLastsales: Boolean
  hasDopeLastsalesWith: [DopeWhereInput!]
  
  """inputs edge predicates"""
  hasInputs: Boolean
  hasInputsWith: [AmountWhereInput!]
  
  """outputs edge predicates"""
  hasOutputs: Boolean
  hasOutputsWith: [AmountWhereInput!]
}

"""
AmountWhereInput is used for filtering Amount objects.
Input was generated by ent.
"""
input AmountWhereInput {
  not: AmountWhereInput
  and: [AmountWhereInput!]
  or: [AmountWhereInput!]
  
  """type field predicates"""
  type: AmountType
  typeNEQ: AmountType
  typeIn: [AmountType!]
  typeNotIn: [AmountType!]
  
  """amount field predicates"""
  amount: BigInt
  amountNEQ: BigInt
  amountIn: [BigInt!]
  amountNotIn: [BigInt!]
  amountGT: BigInt
  amountGTE: BigInt
  amountLT: BigInt
  amountLTE: BigInt
  
  """asset_id field predicates"""
  assetID: BigInt
  assetIDNEQ: BigInt
  assetIDIn: [BigInt!]
  assetIDNotIn: [BigInt!]
  assetIDGT: BigInt
  assetIDGTE: BigInt
  assetIDLT: BigInt
  assetIDLTE: BigInt
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  
  """listing_input edge predicates"""
  hasListingInput: Boolean
  hasListingInputWith: [ListingWhereInput!]
  
  """listing_output edge predicates"""
  hasListingOutput: Boolean
  hasListingOutputWith: [ListingWhereInput!]
}

"""
SearchResultWhereInput is used for filtering SearchResult objects.
Input was generated by ent.
"""
input SearchResultWhereInput {
  not: SearchResultWhereInput
  and: [SearchResultWhereInput!]
  or: [SearchResultWhereInput!]
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  
  """dope edge predicates"""
  hasDope: Boolean
  hasDopeWith: [DopeWhereInput!]
  
  """item edge predicates"""
  hasItem: Boolean
  hasItemWith: [ItemWhereInput!]
  
  """hustler edge predicates"""
  hasHustler: Boolean
  hasHustlerWith: [HustlerWhereInput!]
}

"""
SearchIndexWhereInput is used for filtering SearchIndex objects.
Input was generated by ent.
"""
input SearchIndexWhereInput {
  not: SearchIndexWhereInput
  and: [SearchIndexWhereInput!]
  or: [SearchIndexWhereInput!]
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  
  """dope edge predicates"""
  hasDope: Boolean
  hasDopeWith: [DopeWhereInput!]
  
  """item edge predicates"""
  hasItem: Boolean
  hasItemWith: [ItemWhereInput!]
  
  """hustler edge predicates"""
  hasHustler: Boolean
  hasHustlerWith: [HustlerWhereInput!]
}

"""
SearchWhereInput is used for filtering Search objects.
Input was generated by ent.
"""
input SearchWhereInput {
  not: SearchWhereInput
  and: [SearchWhereInput!]
  or: [SearchWhereInput!]
  
  """type field predicates"""
  type: SearchType
  typeNEQ: SearchType
  typeIn: [SearchType!]
  typeNotIn: [SearchType!]
  
  """greatness field predicates"""
  greatness: Int
  greatnessNEQ: Int
  greatnessIn: [Int!]
  greatnessNotIn: [Int!]
  greatnessGT: Int
  greatnessGTE: Int
  greatnessLT: Int
  greatnessLTE: Int
  greatnessIsNil: Boolean
  greatnessNotNil: Boolean
  
  """claimed field predicates"""
  claimed: Boolean
  claimedNEQ: Boolean
  
  """opened field predicates"""
  opened: Boolean
  openedNEQ: Boolean
  
  """sale_active field predicates"""
  saleActive: Boolean
  saleActiveNEQ: Boolean
  
  """sale_price field predicates"""
  salePrice: BigInt
  salePriceNEQ: BigInt
  salePriceIn: [BigInt!]
  salePriceNotIn: [BigInt!]
  salePriceGT: BigInt
  salePriceGTE: BigInt
  salePriceLT: BigInt
  salePriceLTE: BigInt
  
  """last_sale_price field predicates"""
  lastSalePrice: BigInt
  lastSalePriceNEQ: BigInt
  lastSalePriceIn: [BigInt!]
  lastSalePriceNotIn: [BigInt!]
  lastSalePriceGT: BigInt
  lastSalePriceGTE: BigInt
  lastSalePriceLT: BigInt
  lastSalePriceLTE: BigInt
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  
  """dope edge predicates"""
  hasDope: Boolean
  hasDopeWith: [DopeWhereInput!]
  
  """item edge predicates"""
  hasItem: Boolean
  hasItemWith: [ItemWhereInput!]
  
  """hustler edge predicates"""
  hasHustler: Boolean
  hasHustlerWith: [HustlerWhereInput!]
}

"""
GameHustlerWhereInput is used for filtering GameHustler objects.
Input was generated by ent.
"""
input GameHustlerWhereInput {
  not: GameHustlerWhereInput
  and: [GameHustlerWhereInput!]
  or: [GameHustlerWhereInput!]
  
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  
  """relations edge predicates"""
  hasRelations: Boolean
  hasRelationsWith: [GameHustlerRelationWhereInput!]
  
  """items edge predicates"""
  hasItems: Boolean
  hasItemsWith: [GameHustlerItemWhereInput!]
  
  """quests edge predicates"""
  hasQuests: Boolean
  hasQuestsWith: [GameHustlerQuestWhereInput!]
}

"""
GameHustlerItemWhereInput is used for filtering GameHustlerItem objects.
Input was generated by ent.
"""
input GameHustlerItemWhereInput {
  not: GameHustlerItemWhereInput
  and: [GameHustlerItemWhereInput!]
  or: [GameHustlerItemWhereInput!]
  
  """item field predicates"""
  item: String
  itemNEQ: String
  itemIn: [String!]
  itemNotIn: [String!]
  itemGT: String
  itemGTE: String
  itemLT: String
  itemLTE: String
  itemContains: String
  itemHasPrefix: String
  itemHasSuffix: String
  itemEqualFold: String
  itemContainsFold: String
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  
  """hustler edge predicates"""
  hasHustler: Boolean
  hasHustlerWith: [GameHustlerWhereInput!]
}

"""
GameHustlerRelationWhereInput is used for filtering GameHustlerRelation objects.
Input was generated by ent.
"""
input GameHustlerRelationWhereInput {
  not: GameHustlerRelationWhereInput
  and: [GameHustlerRelationWhereInput!]
  or: [GameHustlerRelationWhereInput!]
  
  """citizen field predicates"""
  citizen: String
  citizenNEQ: String
  citizenIn: [String!]
  citizenNotIn: [String!]
  citizenGT: String
  citizenGTE: String
  citizenLT: String
  citizenLTE: String
  citizenContains: String
  citizenHasPrefix: String
  citizenHasSuffix: String
  citizenEqualFold: String
  citizenContainsFold: String
  
  """conversation field predicates"""
  conversation: String
  conversationNEQ: String
  conversationIn: [String!]
  conversationNotIn: [String!]
  conversationGT: String
  conversationGTE: String
  conversationLT: String
  conversationLTE: String
  conversationContains: String
  conversationHasPrefix: String
  conversationHasSuffix: String
  conversationEqualFold: String
  conversationContainsFold: String
  
  """text field predicates"""
  text: Int
  textNEQ: Int
  textIn: [Int!]
  textNotIn: [Int!]
  textGT: Int
  textGTE: Int
  textLT: Int
  textLTE: Int
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  
  """hustler edge predicates"""
  hasHustler: Boolean
  hasHustlerWith: [GameHustlerWhereInput!]
}

"""
GameHustlerQuestWhereInput is used for filtering GameHustlerQuest objects.
Input was generated by ent.
"""
input GameHustlerQuestWhereInput {
  not: GameHustlerQuestWhereInput
  and: [GameHustlerQuestWhereInput!]
  or: [GameHustlerQuestWhereInput!]
  
  """quest field predicates"""
  quest: String
  questNEQ: String
  questIn: [String!]
  questNotIn: [String!]
  questGT: String
  questGTE: String
  questLT: String
  questLTE: String
  questContains: String
  questHasPrefix: String
  questHasSuffix: String
  questEqualFold: String
  questContainsFold: String
  
  """completed field predicates"""
  completed: Boolean
  completedNEQ: Boolean
  
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  
  """hustler edge predicates"""
  hasHustler: Boolean
  hasHustlerWith: [GameHustlerWhereInput!]
}
`, BuiltIn: false},
	{Name: "graph/relay.graphql", Input: `# Define a Relay Cursor type:
# https://relay.dev/graphql/connections.htm#sec-Cursor
scalar Cursor

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: Cursor
  endCursor: Cursor
}

enum OrderDirection {
  ASC
  DESC
}

type HustlerConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [HustlerEdge]
}

type HustlerEdge {
  node: Hustler
  cursor: Cursor!
}

input HustlerOrder {
  direction: OrderDirection!
}

type ItemConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ItemEdge]
}

type ItemEdge {
  node: Item
  cursor: Cursor!
}

enum ItemOrderField {
  GREATNESS
}

input ItemOrder {
  direction: OrderDirection!
  field: ItemOrderField
}

type DopeConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [DopeEdge]
}

type DopeEdge {
  node: Dope
  cursor: Cursor!
}

enum DopeOrderField {
  ID
  RANK
}

input DopeOrder {
  direction: OrderDirection!
  field: DopeOrderField
}

type WalletConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [WalletEdge]
}

type WalletEdge {
  node: Wallet
  cursor: Cursor!
}

input WalletOrder {
  direction: OrderDirection!
}

type ListingConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ListingEdge]
}

type ListingEdge {
  node: Listing
  cursor: Cursor!
}

input ListingOrder {
  direction: OrderDirection!
}

enum SearchType {
  DOPE
  ITEM
  HUSTLER
}

enum SearchOrderField {
  GREATNESS
  SALE_PRICE
  LAST_SALE_PRICE
}

input SearchOrder {
  direction: OrderDirection
  field: SearchOrderField
}

type SearchConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [SearchEdge]
}

type SearchEdge {
  node: SearchResult
  cursor: Cursor!
}

type WalletItemsConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [WalletItemsEdge]
}

type WalletItemsEdge {
  node: WalletItems
  cursor: Cursor!
}

input WalletItemsOrder {
  direction: OrderDirection!
}`, BuiltIn: false},
	{Name: "graph/schema.graphql", Input: `# Had to add these to get gqlgen to stop complaining
scalar Type
scalar Sex
scalar Tier

"Maps a Time GraphQL scalar to a Go time.Time struct."
scalar Time
"Timestamp is a RFC3339 string."
scalar Timestamp
"Bytes32 is a 32 byte binary string, represented as 0x-prefixed hexadecimal."
scalar Bytes32
"Address is a 20 byte Ethereum address, represented as 0x-prefixed hexadecimal."
scalar Address
"""
Bytes is an arbitrary length binary string, represented as 0x-prefixed hexadecimal.
An empty byte string is represented as '0x'. Byte strings must have an even number of hexadecimal nybbles.
"""
scalar Bytes
"BigInt is a large integer represented as a string."
scalar BigInt
"Long is a 64 bit unsigned integer."
scalar Long

interface Node {
  id: ID!
}

"""
ItemType represents the item slot the item belongs to.
"""
enum ItemType {
  WEAPON
  CLOTHES
  VEHCILE
  WAIST
  FOOT
  HAND
  DRUGS
  NECK
  RING
  ACCESSORY
}

"""
ItemTier represents the tier of an item.
"""
enum ItemTier {
  COMMON
  RARE
  CUSTOM
  BLACK_MARKET
}

type RLEs {
  female: String!
  male: String!
}

type Item implements Node {
  id: ID!
  type: ItemType!
  fullname: String!
  name: String!
  namePrefix: String
  nameSuffix: String
  suffix: String
  augmented: Boolean
  tier: ItemTier!
  greatness: Int!
  count: Int!
  rles: RLEs
  svg: String
  base: Item
}

type WalletItems implements Node {
  id: ID!
  balance: BigInt!
  wallet: Wallet!
  item: Item!
}

enum BodyPartSex {
  MALE
  FEMALE
}

enum BodyPartType {
  BODY
  HAIR
  BEARD
}

type BodyPart implements Node {
  id: ID!
  type: BodyPartType!
  sex: BodyPartSex!
  rle: String!
}

enum HustlerType {
  ORIGINAL_GANGSTA
  REGULAR
}

enum HustlerSex {
  MALE
  FEMALE
}

type Hustler implements Node {
  id: ID!
  type: HustlerType!
  name: String
  title: String
  color: String
  background: String
  age: Long!
  sex: HustlerSex!
  viewbox: [Int!]!
  order: [Int!]!
  svg: String
  body: BodyPart
  hair: BodyPart
  beard: BodyPart
  weapon: Item
  clothes: Item
  vehicle: Item
  waist: Item
  foot: Item
  hand: Item
  drug: Item
  neck: Item
  ring: Item
  accessory: Item
}

# type Position {
#   currentMap: String!
#   x: Float!
#   y: Float!
# }

# type GameHustlerQuest implements Node {
#   quest: String!
#   completed: Boolean!
# }

# type GameHustlerItem implements Node {
#   item: String!
#   count: Int!
# }

# type GameHustlerRelation implements Node {

#   citizen: String!
#   conversation: Int!
#   text: Int!
# }

# type GameHustler implements Node {
#   id: ID!
#   hustler: Hustler!
#   lastPosition: Position!
#   relations: [GameHustlerCitizen!]!
#   inventory: [GameHustlerItem!]!
#   quests: [GameHustlerQuest!]!
# }

type Listing implements Node {
  id: ID!
  source: Source
  active: Boolean!
  inputs: [Amount]!
  outputs: [Amount]!
  wyvernOrder: WyvernOrder
  seaportOrder: SeaportOrder
}

enum Source {
  OPENSEA
  SWAPMEET
}

# OpenSea old-style order from old contract
type WyvernOrder {
  exchange: Address!
  listingTime: Long!
  expirationTime: Long!
  maker: Address!
  currentPrice: String!
  makerRelayerFee: String!
  makerProtocolFee: String!
  feeRecipient: String!
  feeMethod: Int!
  side: Int!
  saleKind: Int!
  target: Address!
  howToCall: Int!
  calldata: Bytes!
  replacementPattern: Bytes!
  staticTarget: String!
  staticExtradata: Bytes!
  extra: String!
  salt: String!
  v: Int!
  r: Bytes!
  s: Bytes!
}

# OpenSea new-style order
type SeaportOrder {
  maker: Address!
  currentPrice: String!
  listingTime: Long!
  expirationTime: Long!
  side: String!
  orderType: String!
}


enum AmountType {
  DOPE
  ETH
  EQUIPMENT
  HUSTLER
  PAPER
  TURF
}

union Token = Dope | Item | Hustler

type Amount implements Node {
  id: ID!
  type: AmountType!
  token: Token
  amount: BigInt!
}

type Dope implements Node {
  id: ID!
  items: [Item!]!
  claimed: Boolean!
  opened: Boolean!
  score: Int!
  rank: Int!
  listings: [Listing]
  lastSale: Listing
}

type Wallet implements Node {
  id: ID!
  dopes: [Dope!]!
  hustlers: [Hustler!]!
  items: [WalletItems!]!
  paper: BigInt!
}

union SearchResult = Dope | Item | Hustler

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]!
  wallets(
    after: Cursor
    first: Int
    before: Cursor
    last: Int
    orderBy: WalletOrder
    where: WalletWhereInput
  ): WalletConnection!
  dopes(
    after: Cursor
    first: Int
    before: Cursor
    last: Int
    orderBy: DopeOrder
    where: DopeWhereInput
  ): DopeConnection!
  items(
    after: Cursor
    first: Int
    before: Cursor
    last: Int
    orderBy: ItemOrder
    where: ItemWhereInput
  ): ItemConnection!
  walletItems(
    after: Cursor
    first: Int
    before: Cursor
    last: Int
    orderBy: WalletItemsOrder
    where: WalletItemsWhereInput
  ): WalletItemsConnection!
  hustlers(
    after: Cursor
    first: Int
    before: Cursor
    last: Int
    orderBy: HustlerOrder
    where: HustlerWhereInput
  ): HustlerConnection!
  listings(
    after: Cursor
    first: Int
    before: Cursor
    last: Int
    orderBy: ListingOrder
    where: ListingWhereInput
  ): ListingConnection!
  search(
    query: String!
    after: Cursor
    first: Int
    before: Cursor
    last: Int
    orderBy: SearchOrder
    where: SearchWhereInput
  ): SearchConnection!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_dopes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.DopeOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalODopeOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.DopeWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalODopeWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_hustlers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.HustlerOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOHustlerOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.HustlerWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_items_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.ItemOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOItemOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.ItemWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_listings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.ListingOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOListingOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.ListingWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOListingWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_nodes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg0, err = ec.unmarshalNID2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_search_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	var arg1 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg3, err = ec.unmarshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg4
	var arg5 *ent.SearchOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg5, err = ec.unmarshalOSearchOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg5
	var arg6 *ent.SearchWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg6, err = ec.unmarshalOSearchWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_walletItems_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.WalletItemsOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOWalletItemsOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.WalletItemsWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOWalletItemsWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_wallets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.WalletOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOWalletOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.WalletWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOWalletWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Amount_id(ctx context.Context, field graphql.CollectedField, obj *ent.Amount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Amount_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Amount_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Amount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Amount_type(ctx context.Context, field graphql.CollectedField, obj *ent.Amount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Amount_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(amount.Type)
	fc.Result = res
	return ec.marshalNAmountType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋamountᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Amount_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Amount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AmountType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Amount_token(ctx context.Context, field graphql.CollectedField, obj *ent.Amount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Amount_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Amount().Token(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Token)
	fc.Result = res
	return ec.marshalOToken2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Amount_token(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Amount",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Token does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Amount_amount(ctx context.Context, field graphql.CollectedField, obj *ent.Amount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Amount_amount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(schema.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Amount_amount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Amount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPart_id(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPart) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPart_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPart_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPart",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPart_type(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPart) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPart_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bodypart.Type)
	fc.Result = res
	return ec.marshalNBodyPartType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPart_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPart",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BodyPartType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPart_sex(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPart) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPart_sex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bodypart.Sex)
	fc.Result = res
	return ec.marshalNBodyPartSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPart_sex(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPart",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BodyPartSex does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPart_rle(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPart) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPart_rle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPart_rle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPart",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_id(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_items(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Item)
	fc.Result = res
	return ec.marshalNItem2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_claimed(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_claimed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Claimed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_claimed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_opened(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_opened(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Opened, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_opened(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_score(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_score(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Score, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_score(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_rank(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_rank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_rank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_listings(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_listings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Listings(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Listing)
	fc.Result = res
	return ec.marshalOListing2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListing(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_listings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Listing_id(ctx, field)
			case "source":
				return ec.fieldContext_Listing_source(ctx, field)
			case "active":
				return ec.fieldContext_Listing_active(ctx, field)
			case "inputs":
				return ec.fieldContext_Listing_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Listing_outputs(ctx, field)
			case "wyvernOrder":
				return ec.fieldContext_Listing_wyvernOrder(ctx, field)
			case "seaportOrder":
				return ec.fieldContext_Listing_seaportOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Listing", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_lastSale(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_lastSale(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSale(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Listing)
	fc.Result = res
	return ec.marshalOListing2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListing(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_lastSale(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Listing_id(ctx, field)
			case "source":
				return ec.fieldContext_Listing_source(ctx, field)
			case "active":
				return ec.fieldContext_Listing_active(ctx, field)
			case "inputs":
				return ec.fieldContext_Listing_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Listing_outputs(ctx, field)
			case "wyvernOrder":
				return ec.fieldContext_Listing_wyvernOrder(ctx, field)
			case "seaportOrder":
				return ec.fieldContext_Listing_seaportOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Listing", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DopeConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.DopeConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DopeConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DopeConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DopeConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DopeConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.DopeConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DopeConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DopeConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DopeConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DopeConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.DopeConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DopeConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.DopeEdge)
	fc.Result = res
	return ec.marshalODopeEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DopeConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DopeConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_DopeEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_DopeEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DopeEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DopeEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.DopeEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DopeEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Dope)
	fc.Result = res
	return ec.marshalODope2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDope(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DopeEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DopeEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Dope_id(ctx, field)
			case "items":
				return ec.fieldContext_Dope_items(ctx, field)
			case "claimed":
				return ec.fieldContext_Dope_claimed(ctx, field)
			case "opened":
				return ec.fieldContext_Dope_opened(ctx, field)
			case "score":
				return ec.fieldContext_Dope_score(ctx, field)
			case "rank":
				return ec.fieldContext_Dope_rank(ctx, field)
			case "listings":
				return ec.fieldContext_Dope_listings(ctx, field)
			case "lastSale":
				return ec.fieldContext_Dope_lastSale(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dope", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DopeEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.DopeEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DopeEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DopeEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DopeEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_id(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_type(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(hustler.Type)
	fc.Result = res
	return ec.marshalNHustlerType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HustlerType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_name(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_title(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_color(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Color, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_color(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_background(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_background(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Background, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_background(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_age(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_age(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Age, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNLong2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_age(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Long does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_sex(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_sex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(hustler.Sex)
	fc.Result = res
	return ec.marshalNHustlerSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_sex(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HustlerSex does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_viewbox(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_viewbox(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewbox, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2ᚕintᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_viewbox(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_order(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2ᚕintᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_order(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_svg(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_svg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Svg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_svg(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_body(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_body(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Body(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.BodyPart)
	fc.Result = res
	return ec.marshalOBodyPart2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPart(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_body(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BodyPart_id(ctx, field)
			case "type":
				return ec.fieldContext_BodyPart_type(ctx, field)
			case "sex":
				return ec.fieldContext_BodyPart_sex(ctx, field)
			case "rle":
				return ec.fieldContext_BodyPart_rle(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyPart", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_hair(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_hair(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hair(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.BodyPart)
	fc.Result = res
	return ec.marshalOBodyPart2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPart(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_hair(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BodyPart_id(ctx, field)
			case "type":
				return ec.fieldContext_BodyPart_type(ctx, field)
			case "sex":
				return ec.fieldContext_BodyPart_sex(ctx, field)
			case "rle":
				return ec.fieldContext_BodyPart_rle(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyPart", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_beard(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_beard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Beard(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.BodyPart)
	fc.Result = res
	return ec.marshalOBodyPart2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPart(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_beard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BodyPart_id(ctx, field)
			case "type":
				return ec.fieldContext_BodyPart_type(ctx, field)
			case "sex":
				return ec.fieldContext_BodyPart_sex(ctx, field)
			case "rle":
				return ec.fieldContext_BodyPart_rle(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyPart", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_weapon(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_weapon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weapon(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_weapon(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_clothes(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_clothes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Clothes(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_clothes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_vehicle(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_vehicle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vehicle(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_vehicle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_waist(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_waist(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Waist(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_waist(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_foot(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_foot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Foot(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_foot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_hand(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_hand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hand(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_hand(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_drug(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_drug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Drug(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_drug(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_neck(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_neck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Neck(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_neck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_ring(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_ring(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ring(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_ring(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_accessory(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_accessory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accessory(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_accessory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HustlerConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.HustlerConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HustlerConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HustlerConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HustlerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HustlerConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.HustlerConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HustlerConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HustlerConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HustlerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HustlerConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.HustlerConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HustlerConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.HustlerEdge)
	fc.Result = res
	return ec.marshalOHustlerEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HustlerConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HustlerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_HustlerEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_HustlerEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HustlerEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HustlerEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.HustlerEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HustlerEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustler(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HustlerEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HustlerEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HustlerEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.HustlerEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HustlerEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HustlerEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HustlerEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_id(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_type(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(item.Type)
	fc.Result = res
	return ec.marshalNItemType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_fullname(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_fullname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Item().Fullname(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_fullname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_name(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_namePrefix(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_namePrefix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NamePrefix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_namePrefix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_nameSuffix(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_nameSuffix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NameSuffix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_nameSuffix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_suffix(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_suffix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Suffix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_suffix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_augmented(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_augmented(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Augmented, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_augmented(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_tier(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_tier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(item.Tier)
	fc.Result = res
	return ec.marshalNItemTier2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_tier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemTier does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_greatness(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_greatness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Greatness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_greatness(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_count(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_rles(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_rles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(schema.RLEs)
	fc.Result = res
	return ec.marshalORLEs2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐRLEs(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_rles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "female":
				return ec.fieldContext_RLEs_female(ctx, field)
			case "male":
				return ec.fieldContext_RLEs_male(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RLEs", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_svg(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_svg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Svg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_svg(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_base(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_base(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Base(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_base(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.ItemConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.ItemConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.ItemConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ItemEdge)
	fc.Result = res
	return ec.marshalOItemEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_ItemEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_ItemEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.ItemEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.ItemEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Listing_id(ctx context.Context, field graphql.CollectedField, obj *ent.Listing) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Listing_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Listing_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Listing",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Listing_source(ctx context.Context, field graphql.CollectedField, obj *ent.Listing) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Listing_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(listing.Source)
	fc.Result = res
	return ec.marshalOSource2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋlistingᚐSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Listing_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Listing",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Source does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Listing_active(ctx context.Context, field graphql.CollectedField, obj *ent.Listing) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Listing_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Listing_active(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Listing",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Listing_inputs(ctx context.Context, field graphql.CollectedField, obj *ent.Listing) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Listing_inputs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Inputs(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Amount)
	fc.Result = res
	return ec.marshalNAmount2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐAmount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Listing_inputs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Listing",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Amount_id(ctx, field)
			case "type":
				return ec.fieldContext_Amount_type(ctx, field)
			case "token":
				return ec.fieldContext_Amount_token(ctx, field)
			case "amount":
				return ec.fieldContext_Amount_amount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Amount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Listing_outputs(ctx context.Context, field graphql.CollectedField, obj *ent.Listing) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Listing_outputs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Outputs(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Amount)
	fc.Result = res
	return ec.marshalNAmount2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐAmount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Listing_outputs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Listing",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Amount_id(ctx, field)
			case "type":
				return ec.fieldContext_Amount_type(ctx, field)
			case "token":
				return ec.fieldContext_Amount_token(ctx, field)
			case "amount":
				return ec.fieldContext_Amount_amount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Amount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Listing_wyvernOrder(ctx context.Context, field graphql.CollectedField, obj *ent.Listing) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Listing_wyvernOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Listing().WyvernOrder(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*opensea.WyvernOrder)
	fc.Result = res
	return ec.marshalOWyvernOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋjobsᚋopenseaᚐWyvernOrder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Listing_wyvernOrder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Listing",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exchange":
				return ec.fieldContext_WyvernOrder_exchange(ctx, field)
			case "listingTime":
				return ec.fieldContext_WyvernOrder_listingTime(ctx, field)
			case "expirationTime":
				return ec.fieldContext_WyvernOrder_expirationTime(ctx, field)
			case "maker":
				return ec.fieldContext_WyvernOrder_maker(ctx, field)
			case "currentPrice":
				return ec.fieldContext_WyvernOrder_currentPrice(ctx, field)
			case "makerRelayerFee":
				return ec.fieldContext_WyvernOrder_makerRelayerFee(ctx, field)
			case "makerProtocolFee":
				return ec.fieldContext_WyvernOrder_makerProtocolFee(ctx, field)
			case "feeRecipient":
				return ec.fieldContext_WyvernOrder_feeRecipient(ctx, field)
			case "feeMethod":
				return ec.fieldContext_WyvernOrder_feeMethod(ctx, field)
			case "side":
				return ec.fieldContext_WyvernOrder_side(ctx, field)
			case "saleKind":
				return ec.fieldContext_WyvernOrder_saleKind(ctx, field)
			case "target":
				return ec.fieldContext_WyvernOrder_target(ctx, field)
			case "howToCall":
				return ec.fieldContext_WyvernOrder_howToCall(ctx, field)
			case "calldata":
				return ec.fieldContext_WyvernOrder_calldata(ctx, field)
			case "replacementPattern":
				return ec.fieldContext_WyvernOrder_replacementPattern(ctx, field)
			case "staticTarget":
				return ec.fieldContext_WyvernOrder_staticTarget(ctx, field)
			case "staticExtradata":
				return ec.fieldContext_WyvernOrder_staticExtradata(ctx, field)
			case "extra":
				return ec.fieldContext_WyvernOrder_extra(ctx, field)
			case "salt":
				return ec.fieldContext_WyvernOrder_salt(ctx, field)
			case "v":
				return ec.fieldContext_WyvernOrder_v(ctx, field)
			case "r":
				return ec.fieldContext_WyvernOrder_r(ctx, field)
			case "s":
				return ec.fieldContext_WyvernOrder_s(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WyvernOrder", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Listing_seaportOrder(ctx context.Context, field graphql.CollectedField, obj *ent.Listing) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Listing_seaportOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Listing().SeaportOrder(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*opensea.SeaportOrder)
	fc.Result = res
	return ec.marshalOSeaportOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋjobsᚋopenseaᚐSeaportOrder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Listing_seaportOrder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Listing",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maker":
				return ec.fieldContext_SeaportOrder_maker(ctx, field)
			case "currentPrice":
				return ec.fieldContext_SeaportOrder_currentPrice(ctx, field)
			case "listingTime":
				return ec.fieldContext_SeaportOrder_listingTime(ctx, field)
			case "expirationTime":
				return ec.fieldContext_SeaportOrder_expirationTime(ctx, field)
			case "side":
				return ec.fieldContext_SeaportOrder_side(ctx, field)
			case "orderType":
				return ec.fieldContext_SeaportOrder_orderType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SeaportOrder", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListingConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.ListingConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListingConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListingConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListingConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListingConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.ListingConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListingConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListingConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListingConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListingConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.ListingConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListingConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ListingEdge)
	fc.Result = res
	return ec.marshalOListingEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListingConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListingConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_ListingEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_ListingEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListingEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListingEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.ListingEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListingEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Listing)
	fc.Result = res
	return ec.marshalOListing2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListing(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListingEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListingEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Listing_id(ctx, field)
			case "source":
				return ec.fieldContext_Listing_source(ctx, field)
			case "active":
				return ec.fieldContext_Listing_active(ctx, field)
			case "inputs":
				return ec.fieldContext_Listing_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Listing_outputs(ctx, field)
			case "wyvernOrder":
				return ec.fieldContext_Listing_wyvernOrder(ctx, field)
			case "seaportOrder":
				return ec.fieldContext_Listing_seaportOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Listing", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListingEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.ListingEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListingEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListingEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListingEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Cursor)
	fc.Result = res
	return ec.marshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Cursor)
	fc.Result = res
	return ec.marshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(ent.Noder)
	fc.Result = res
	return ec.marshalONode2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Nodes(rctx, fc.Args["ids"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ent.Noder)
	fc.Result = res
	return ec.marshalNNode2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_wallets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_wallets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Wallets(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.WalletOrder), fc.Args["where"].(*ent.WalletWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.WalletConnection)
	fc.Result = res
	return ec.marshalNWalletConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_wallets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_WalletConnection_totalCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_WalletConnection_pageInfo(ctx, field)
			case "edges":
				return ec.fieldContext_WalletConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WalletConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_wallets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_dopes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_dopes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Dopes(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.DopeOrder), fc.Args["where"].(*ent.DopeWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.DopeConnection)
	fc.Result = res
	return ec.marshalNDopeConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_dopes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_DopeConnection_totalCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_DopeConnection_pageInfo(ctx, field)
			case "edges":
				return ec.fieldContext_DopeConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DopeConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_dopes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_items(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Items(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.ItemOrder), fc.Args["where"].(*ent.ItemWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ItemConnection)
	fc.Result = res
	return ec.marshalNItemConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ItemConnection_totalCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ItemConnection_pageInfo(ctx, field)
			case "edges":
				return ec.fieldContext_ItemConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_items_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_walletItems(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_walletItems(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().WalletItems(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.WalletItemsOrder), fc.Args["where"].(*ent.WalletItemsWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.WalletItemsConnection)
	fc.Result = res
	return ec.marshalNWalletItemsConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_walletItems(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_WalletItemsConnection_totalCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_WalletItemsConnection_pageInfo(ctx, field)
			case "edges":
				return ec.fieldContext_WalletItemsConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WalletItemsConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_walletItems_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_hustlers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hustlers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Hustlers(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.HustlerOrder), fc.Args["where"].(*ent.HustlerWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.HustlerConnection)
	fc.Result = res
	return ec.marshalNHustlerConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hustlers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_HustlerConnection_totalCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_HustlerConnection_pageInfo(ctx, field)
			case "edges":
				return ec.fieldContext_HustlerConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HustlerConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hustlers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_listings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Listings(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.ListingOrder), fc.Args["where"].(*ent.ListingWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ListingConnection)
	fc.Result = res
	return ec.marshalNListingConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_ListingConnection_totalCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ListingConnection_pageInfo(ctx, field)
			case "edges":
				return ec.fieldContext_ListingConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListingConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_listings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_search(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_search(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Search(rctx, fc.Args["query"].(string), fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.SearchOrder), fc.Args["where"].(*ent.SearchWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.SearchConnection)
	fc.Result = res
	return ec.marshalNSearchConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_search(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_SearchConnection_totalCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_SearchConnection_pageInfo(ctx, field)
			case "edges":
				return ec.fieldContext_SearchConnection_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_search_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RLEs_female(ctx context.Context, field graphql.CollectedField, obj *schema.RLEs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RLEs_female(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Female, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RLEs_female(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RLEs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RLEs_male(ctx context.Context, field graphql.CollectedField, obj *schema.RLEs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RLEs_male(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Male, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RLEs_male(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RLEs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SeaportOrder_maker(ctx context.Context, field graphql.CollectedField, obj *opensea.SeaportOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SeaportOrder_maker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SeaportOrder().Maker(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SeaportOrder_maker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SeaportOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SeaportOrder_currentPrice(ctx context.Context, field graphql.CollectedField, obj *opensea.SeaportOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SeaportOrder_currentPrice(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SeaportOrder().CurrentPrice(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SeaportOrder_currentPrice(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SeaportOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SeaportOrder_listingTime(ctx context.Context, field graphql.CollectedField, obj *opensea.SeaportOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SeaportOrder_listingTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SeaportOrder().ListingTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNLong2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SeaportOrder_listingTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SeaportOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Long does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SeaportOrder_expirationTime(ctx context.Context, field graphql.CollectedField, obj *opensea.SeaportOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SeaportOrder_expirationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SeaportOrder().ExpirationTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNLong2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SeaportOrder_expirationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SeaportOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Long does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SeaportOrder_side(ctx context.Context, field graphql.CollectedField, obj *opensea.SeaportOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SeaportOrder_side(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Side, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SeaportOrder_side(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SeaportOrder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SeaportOrder_orderType(ctx context.Context, field graphql.CollectedField, obj *opensea.SeaportOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SeaportOrder_orderType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SeaportOrder_orderType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SeaportOrder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.SearchConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.SearchConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.SearchConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.SearchEdge)
	fc.Result = res
	return ec.marshalOSearchEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_SearchEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_SearchEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.SearchEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SearchEdge().Node(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.SearchResult)
	fc.Result = res
	return ec.marshalOSearchResult2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchEdge",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SearchResult does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.SearchEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_id(ctx context.Context, field graphql.CollectedField, obj *ent.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_dopes(ctx context.Context, field graphql.CollectedField, obj *ent.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_dopes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dopes(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Dope)
	fc.Result = res
	return ec.marshalNDope2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_dopes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Dope_id(ctx, field)
			case "items":
				return ec.fieldContext_Dope_items(ctx, field)
			case "claimed":
				return ec.fieldContext_Dope_claimed(ctx, field)
			case "opened":
				return ec.fieldContext_Dope_opened(ctx, field)
			case "score":
				return ec.fieldContext_Dope_score(ctx, field)
			case "rank":
				return ec.fieldContext_Dope_rank(ctx, field)
			case "listings":
				return ec.fieldContext_Dope_listings(ctx, field)
			case "lastSale":
				return ec.fieldContext_Dope_lastSale(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dope", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_hustlers(ctx context.Context, field graphql.CollectedField, obj *ent.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_hustlers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hustlers(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Hustler)
	fc.Result = res
	return ec.marshalNHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_hustlers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_items(ctx context.Context, field graphql.CollectedField, obj *ent.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.WalletItems)
	fc.Result = res
	return ec.marshalNWalletItems2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WalletItems_id(ctx, field)
			case "balance":
				return ec.fieldContext_WalletItems_balance(ctx, field)
			case "wallet":
				return ec.fieldContext_WalletItems_wallet(ctx, field)
			case "item":
				return ec.fieldContext_WalletItems_item(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WalletItems", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_paper(ctx context.Context, field graphql.CollectedField, obj *ent.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_paper(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Paper, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(schema.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_paper(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.WalletConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.WalletConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.WalletConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.WalletEdge)
	fc.Result = res
	return ec.marshalOWalletEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_WalletEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_WalletEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WalletEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.WalletEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Wallet)
	fc.Result = res
	return ec.marshalOWallet2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWallet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Wallet_id(ctx, field)
			case "dopes":
				return ec.fieldContext_Wallet_dopes(ctx, field)
			case "hustlers":
				return ec.fieldContext_Wallet_hustlers(ctx, field)
			case "items":
				return ec.fieldContext_Wallet_items(ctx, field)
			case "paper":
				return ec.fieldContext_Wallet_paper(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Wallet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.WalletEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItems_id(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItems) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItems_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItems_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItems",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItems_balance(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItems) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItems_balance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(schema.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItems_balance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItems",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItems_wallet(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItems) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItems_wallet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Wallet(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Wallet)
	fc.Result = res
	return ec.marshalNWallet2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWallet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItems_wallet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItems",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Wallet_id(ctx, field)
			case "dopes":
				return ec.fieldContext_Wallet_dopes(ctx, field)
			case "hustlers":
				return ec.fieldContext_Wallet_hustlers(ctx, field)
			case "items":
				return ec.fieldContext_Wallet_items(ctx, field)
			case "paper":
				return ec.fieldContext_Wallet_paper(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Wallet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItems_item(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItems) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItems_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Item(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalNItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItems_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItems",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItemsConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItemsConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItemsConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItemsConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItemsConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItemsConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItemsConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItemsConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItemsConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItemsConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItemsConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItemsConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItemsConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.WalletItemsEdge)
	fc.Result = res
	return ec.marshalOWalletItemsEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItemsConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItemsConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_WalletItemsEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_WalletItemsEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WalletItemsEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItemsEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItemsEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItemsEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.WalletItems)
	fc.Result = res
	return ec.marshalOWalletItems2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItems(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItemsEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItemsEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WalletItems_id(ctx, field)
			case "balance":
				return ec.fieldContext_WalletItems_balance(ctx, field)
			case "wallet":
				return ec.fieldContext_WalletItems_wallet(ctx, field)
			case "item":
				return ec.fieldContext_WalletItems_item(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WalletItems", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItemsEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItemsEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItemsEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItemsEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItemsEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_exchange(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_exchange(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().Exchange(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_exchange(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_listingTime(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_listingTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().ListingTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNLong2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_listingTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Long does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_expirationTime(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_expirationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().ExpirationTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNLong2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_expirationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Long does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_maker(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_maker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().Maker(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_maker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_currentPrice(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_currentPrice(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().CurrentPrice(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_currentPrice(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_makerRelayerFee(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_makerRelayerFee(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().MakerRelayerFee(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_makerRelayerFee(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_makerProtocolFee(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_makerProtocolFee(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().MakerProtocolFee(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_makerProtocolFee(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_feeRecipient(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_feeRecipient(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().FeeRecipient(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_feeRecipient(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_feeMethod(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_feeMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().FeeMethod(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_feeMethod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_side(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_side(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().Side(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_side(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_saleKind(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_saleKind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().SaleKind(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_saleKind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_target(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_target(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().Target(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_target(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_howToCall(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_howToCall(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().HowToCall(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_howToCall(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_calldata(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_calldata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().Calldata(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNBytes2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_calldata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_replacementPattern(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_replacementPattern(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().ReplacementPattern(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNBytes2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_replacementPattern(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_staticTarget(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_staticTarget(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().StaticTarget(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_staticTarget(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_staticExtradata(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_staticExtradata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().StaticExtradata(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNBytes2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_staticExtradata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_extra(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_extra(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().Extra(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_extra(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_salt(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_salt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().Salt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_salt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_v(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_v(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().V(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_v(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_r(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_r(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().R(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNBytes2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_r(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WyvernOrder_s(ctx context.Context, field graphql.CollectedField, obj *opensea.WyvernOrder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WyvernOrder_s(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WyvernOrder().S(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNBytes2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WyvernOrder_s(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WyvernOrder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAmountWhereInput(ctx context.Context, obj interface{}) (ent.AmountWhereInput, error) {
	var it ent.AmountWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOAmountWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐAmountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOAmountWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐAmountWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOAmountWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐAmountWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOAmountType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋamountᚐType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			it.TypeNEQ, err = ec.unmarshalOAmountType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋamountᚐType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			it.TypeIn, err = ec.unmarshalOAmountType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋamountᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			it.TypeNotIn, err = ec.unmarshalOAmountType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋamountᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "amount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			it.Amount, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNEQ"))
			it.AmountNEQ, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountIn"))
			it.AmountIn, err = ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNotIn"))
			it.AmountNotIn, err = ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGT"))
			it.AmountGT, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGTE"))
			it.AmountGTE, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLT"))
			it.AmountLT, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLTE"))
			it.AmountLTE, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetID"))
			it.AssetID, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIDNEQ"))
			it.AssetIDNEQ, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIDIn"))
			it.AssetIDIn, err = ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIDNotIn"))
			it.AssetIDNotIn, err = ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIDGT"))
			it.AssetIDGT, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIDGTE"))
			it.AssetIDGTE, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIDLT"))
			it.AssetIDLT, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIDLTE"))
			it.AssetIDLTE, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasListingInput":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasListingInput"))
			it.HasListingInput, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasListingInputWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasListingInputWith"))
			it.HasListingInputWith, err = ec.unmarshalOListingWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasListingOutput":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasListingOutput"))
			it.HasListingOutput, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasListingOutputWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasListingOutputWith"))
			it.HasListingOutputWith, err = ec.unmarshalOListingWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBodyPartWhereInput(ctx context.Context, obj interface{}) (ent.BodyPartWhereInput, error) {
	var it ent.BodyPartWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOBodyPartWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOBodyPartWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOBodyPartWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOBodyPartType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			it.TypeNEQ, err = ec.unmarshalOBodyPartType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			it.TypeIn, err = ec.unmarshalOBodyPartType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			it.TypeNotIn, err = ec.unmarshalOBodyPartType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "sex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sex"))
			it.Sex, err = ec.unmarshalOBodyPartSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx, v)
			if err != nil {
				return it, err
			}
		case "sexNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sexNEQ"))
			it.SexNEQ, err = ec.unmarshalOBodyPartSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx, v)
			if err != nil {
				return it, err
			}
		case "sexIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sexIn"))
			it.SexIn, err = ec.unmarshalOBodyPartSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSexᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "sexNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sexNotIn"))
			it.SexNotIn, err = ec.unmarshalOBodyPartSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSexᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "rle":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rle"))
			it.Rle, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rleNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleNEQ"))
			it.RleNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rleIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleIn"))
			it.RleIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "rleNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleNotIn"))
			it.RleNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "rleGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleGT"))
			it.RleGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rleGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleGTE"))
			it.RleGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rleLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleLT"))
			it.RleLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rleLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleLTE"))
			it.RleLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rleContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleContains"))
			it.RleContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rleHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleHasPrefix"))
			it.RleHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rleHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleHasSuffix"))
			it.RleHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rleEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleEqualFold"))
			it.RleEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rleContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleContainsFold"))
			it.RleContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sprite":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sprite"))
			it.Sprite, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "spriteNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteNEQ"))
			it.SpriteNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "spriteIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteIn"))
			it.SpriteIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "spriteNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteNotIn"))
			it.SpriteNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "spriteGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteGT"))
			it.SpriteGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "spriteGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteGTE"))
			it.SpriteGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "spriteLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteLT"))
			it.SpriteLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "spriteLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteLTE"))
			it.SpriteLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "spriteContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteContains"))
			it.SpriteContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "spriteHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteHasPrefix"))
			it.SpriteHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "spriteHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteHasSuffix"))
			it.SpriteHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "spriteIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteIsNil"))
			it.SpriteIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "spriteNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteNotNil"))
			it.SpriteNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "spriteEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteEqualFold"))
			it.SpriteEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "spriteContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteContainsFold"))
			it.SpriteContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerBodies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerBodies"))
			it.HasHustlerBodies, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerBodiesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerBodiesWith"))
			it.HasHustlerBodiesWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerHairs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerHairs"))
			it.HasHustlerHairs, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerHairsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerHairsWith"))
			it.HasHustlerHairsWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerBeards":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerBeards"))
			it.HasHustlerBeards, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerBeardsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerBeardsWith"))
			it.HasHustlerBeardsWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDopeOrder(ctx context.Context, obj interface{}) (ent.DopeOrder, error) {
	var it ent.DopeOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalODopeOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDopeWhereInput(ctx context.Context, obj interface{}) (ent.DopeWhereInput, error) {
	var it ent.DopeWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalODopeWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "claimed":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimed"))
			it.Claimed, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "claimedNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimedNEQ"))
			it.ClaimedNEQ, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "opened":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opened"))
			it.Opened, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "openedNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("openedNEQ"))
			it.OpenedNEQ, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "score":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			it.Score, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "scoreNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreNEQ"))
			it.ScoreNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "scoreIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreIn"))
			it.ScoreIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "scoreNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreNotIn"))
			it.ScoreNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "scoreGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreGT"))
			it.ScoreGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "scoreGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreGTE"))
			it.ScoreGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "scoreLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreLT"))
			it.ScoreLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "scoreLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreLTE"))
			it.ScoreLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "scoreIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreIsNil"))
			it.ScoreIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "scoreNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreNotNil"))
			it.ScoreNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "rank":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rank"))
			it.Rank, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "rankNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankNEQ"))
			it.RankNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "rankIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankIn"))
			it.RankIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "rankNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankNotIn"))
			it.RankNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "rankGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankGT"))
			it.RankGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "rankGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankGTE"))
			it.RankGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "rankLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankLT"))
			it.RankLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "rankLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankLTE"))
			it.RankLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "rankIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankIsNil"))
			it.RankIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "rankNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankNotNil"))
			it.RankNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "order":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			it.Order, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "orderNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNEQ"))
			it.OrderNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "orderIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderIn"))
			it.OrderIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "orderNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNotIn"))
			it.OrderNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "orderGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGT"))
			it.OrderGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "orderGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGTE"))
			it.OrderGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "orderLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLT"))
			it.OrderLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "orderLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLTE"))
			it.OrderLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWallet":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWallet"))
			it.HasWallet, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWalletWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWalletWith"))
			it.HasWalletWith, err = ec.unmarshalOWalletWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLastSale":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLastSale"))
			it.HasLastSale, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLastSaleWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLastSaleWith"))
			it.HasLastSaleWith, err = ec.unmarshalOListingWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasListings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasListings"))
			it.HasListings, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasListingsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasListingsWith"))
			it.HasListingsWith, err = ec.unmarshalOListingWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItems":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItems"))
			it.HasItems, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItemsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItemsWith"))
			it.HasItemsWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasIndex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIndex"))
			it.HasIndex, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasIndexWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIndexWith"))
			it.HasIndexWith, err = ec.unmarshalOSearchWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventWhereInput(ctx context.Context, obj interface{}) (ent.EventWhereInput, error) {
	var it ent.EventWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOEventWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐEventWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOEventWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐEventWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOEventWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐEventWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "index":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("index"))
			it.Index, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "indexNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexNEQ"))
			it.IndexNEQ, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "indexIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexIn"))
			it.IndexIn, err = ec.unmarshalOLong2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indexNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexNotIn"))
			it.IndexNotIn, err = ec.unmarshalOLong2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indexGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexGT"))
			it.IndexGT, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "indexGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexGTE"))
			it.IndexGTE, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "indexLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexLT"))
			it.IndexLT, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "indexLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexLTE"))
			it.IndexLTE, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			it.UpdatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			it.UpdatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			it.UpdatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			it.UpdatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			it.UpdatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			it.UpdatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			it.UpdatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGameHustlerItemWhereInput(ctx context.Context, obj interface{}) (ent.GameHustlerItemWhereInput, error) {
	var it ent.GameHustlerItemWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOGameHustlerItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOGameHustlerItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOGameHustlerItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "item":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("item"))
			it.Item, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemNEQ"))
			it.ItemNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemIn"))
			it.ItemIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemNotIn"))
			it.ItemNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemGT"))
			it.ItemGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemGTE"))
			it.ItemGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemLT"))
			it.ItemLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemLTE"))
			it.ItemLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemContains"))
			it.ItemContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemHasPrefix"))
			it.ItemHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemHasSuffix"))
			it.ItemHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemEqualFold"))
			it.ItemEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemContainsFold"))
			it.ItemContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustler":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustler"))
			it.HasHustler, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWith"))
			it.HasHustlerWith, err = ec.unmarshalOGameHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGameHustlerQuestWhereInput(ctx context.Context, obj interface{}) (ent.GameHustlerQuestWhereInput, error) {
	var it ent.GameHustlerQuestWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOGameHustlerQuestWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOGameHustlerQuestWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOGameHustlerQuestWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "quest":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quest"))
			it.Quest, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "questNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questNEQ"))
			it.QuestNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "questIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questIn"))
			it.QuestIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "questNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questNotIn"))
			it.QuestNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "questGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questGT"))
			it.QuestGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "questGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questGTE"))
			it.QuestGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "questLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questLT"))
			it.QuestLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "questLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questLTE"))
			it.QuestLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "questContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questContains"))
			it.QuestContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "questHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questHasPrefix"))
			it.QuestHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "questHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questHasSuffix"))
			it.QuestHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "questEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questEqualFold"))
			it.QuestEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "questContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questContainsFold"))
			it.QuestContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "completed":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("completed"))
			it.Completed, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "completedNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("completedNEQ"))
			it.CompletedNEQ, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustler":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustler"))
			it.HasHustler, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWith"))
			it.HasHustlerWith, err = ec.unmarshalOGameHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGameHustlerRelationWhereInput(ctx context.Context, obj interface{}) (ent.GameHustlerRelationWhereInput, error) {
	var it ent.GameHustlerRelationWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOGameHustlerRelationWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOGameHustlerRelationWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOGameHustlerRelationWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "citizen":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizen"))
			it.Citizen, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "citizenNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenNEQ"))
			it.CitizenNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "citizenIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenIn"))
			it.CitizenIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "citizenNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenNotIn"))
			it.CitizenNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "citizenGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenGT"))
			it.CitizenGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "citizenGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenGTE"))
			it.CitizenGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "citizenLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenLT"))
			it.CitizenLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "citizenLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenLTE"))
			it.CitizenLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "citizenContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenContains"))
			it.CitizenContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "citizenHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenHasPrefix"))
			it.CitizenHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "citizenHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenHasSuffix"))
			it.CitizenHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "citizenEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenEqualFold"))
			it.CitizenEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "citizenContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenContainsFold"))
			it.CitizenContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "conversation":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversation"))
			it.Conversation, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "conversationNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationNEQ"))
			it.ConversationNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "conversationIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationIn"))
			it.ConversationIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "conversationNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationNotIn"))
			it.ConversationNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "conversationGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationGT"))
			it.ConversationGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "conversationGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationGTE"))
			it.ConversationGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "conversationLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationLT"))
			it.ConversationLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "conversationLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationLTE"))
			it.ConversationLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "conversationContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationContains"))
			it.ConversationContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "conversationHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationHasPrefix"))
			it.ConversationHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "conversationHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationHasSuffix"))
			it.ConversationHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "conversationEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationEqualFold"))
			it.ConversationEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "conversationContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationContainsFold"))
			it.ConversationContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().Text(ctx, &it, data); err != nil {
				return it, err
			}
		case "textNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("textNEQ"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().TextNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "textIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("textIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().TextIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "textNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("textNotIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().TextNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "textGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("textGT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().TextGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "textGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("textGTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().TextGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "textLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("textLT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().TextLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "textLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("textLTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().TextLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustler":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustler"))
			it.HasHustler, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWith"))
			it.HasHustlerWith, err = ec.unmarshalOGameHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGameHustlerWhereInput(ctx context.Context, obj interface{}) (ent.GameHustlerWhereInput, error) {
	var it ent.GameHustlerWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOGameHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOGameHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOGameHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRelations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRelations"))
			it.HasRelations, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRelationsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRelationsWith"))
			it.HasRelationsWith, err = ec.unmarshalOGameHustlerRelationWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItems":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItems"))
			it.HasItems, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItemsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItemsWith"))
			it.HasItemsWith, err = ec.unmarshalOGameHustlerItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasQuests":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasQuests"))
			it.HasQuests, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasQuestsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasQuestsWith"))
			it.HasQuestsWith, err = ec.unmarshalOGameHustlerQuestWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHustlerOrder(ctx context.Context, obj interface{}) (ent.HustlerOrder, error) {
	var it ent.HustlerOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHustlerWhereInput(ctx context.Context, obj interface{}) (ent.HustlerWhereInput, error) {
	var it ent.HustlerWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOHustlerType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			it.TypeNEQ, err = ec.unmarshalOHustlerType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			it.TypeIn, err = ec.unmarshalOHustlerType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			it.TypeNotIn, err = ec.unmarshalOHustlerType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIsNil"))
			it.NameIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotNil"))
			it.NameNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "title":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			it.Title, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNEQ"))
			it.TitleNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleIn"))
			it.TitleIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNotIn"))
			it.TitleNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGT"))
			it.TitleGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGTE"))
			it.TitleGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLT"))
			it.TitleLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLTE"))
			it.TitleLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContains"))
			it.TitleContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasPrefix"))
			it.TitleHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasSuffix"))
			it.TitleHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleIsNil"))
			it.TitleIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNotNil"))
			it.TitleNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleEqualFold"))
			it.TitleEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContainsFold"))
			it.TitleContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "color":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			it.Color, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "colorNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorNEQ"))
			it.ColorNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "colorIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorIn"))
			it.ColorIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "colorNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorNotIn"))
			it.ColorNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "colorGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorGT"))
			it.ColorGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "colorGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorGTE"))
			it.ColorGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "colorLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorLT"))
			it.ColorLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "colorLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorLTE"))
			it.ColorLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "colorContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorContains"))
			it.ColorContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "colorHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorHasPrefix"))
			it.ColorHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "colorHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorHasSuffix"))
			it.ColorHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "colorIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorIsNil"))
			it.ColorIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "colorNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorNotNil"))
			it.ColorNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "colorEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorEqualFold"))
			it.ColorEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "colorContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorContainsFold"))
			it.ColorContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "background":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("background"))
			it.Background, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "backgroundNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundNEQ"))
			it.BackgroundNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "backgroundIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundIn"))
			it.BackgroundIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "backgroundNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundNotIn"))
			it.BackgroundNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "backgroundGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundGT"))
			it.BackgroundGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "backgroundGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundGTE"))
			it.BackgroundGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "backgroundLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundLT"))
			it.BackgroundLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "backgroundLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundLTE"))
			it.BackgroundLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "backgroundContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundContains"))
			it.BackgroundContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "backgroundHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundHasPrefix"))
			it.BackgroundHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "backgroundHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundHasSuffix"))
			it.BackgroundHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "backgroundIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundIsNil"))
			it.BackgroundIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "backgroundNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundNotNil"))
			it.BackgroundNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "backgroundEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundEqualFold"))
			it.BackgroundEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "backgroundContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundContainsFold"))
			it.BackgroundContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "age":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("age"))
			it.Age, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "ageNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageNEQ"))
			it.AgeNEQ, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "ageIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageIn"))
			it.AgeIn, err = ec.unmarshalOLong2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "ageNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageNotIn"))
			it.AgeNotIn, err = ec.unmarshalOLong2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "ageGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageGT"))
			it.AgeGT, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "ageGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageGTE"))
			it.AgeGTE, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "ageLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageLT"))
			it.AgeLT, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "ageLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageLTE"))
			it.AgeLTE, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "sex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sex"))
			it.Sex, err = ec.unmarshalOHustlerSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx, v)
			if err != nil {
				return it, err
			}
		case "sexNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sexNEQ"))
			it.SexNEQ, err = ec.unmarshalOHustlerSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx, v)
			if err != nil {
				return it, err
			}
		case "sexIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sexIn"))
			it.SexIn, err = ec.unmarshalOHustlerSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSexᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "sexNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sexNotIn"))
			it.SexNotIn, err = ec.unmarshalOHustlerSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSexᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "svg":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svg"))
			it.Svg, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgNEQ"))
			it.SvgNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgIn"))
			it.SvgIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgNotIn"))
			it.SvgNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgGT"))
			it.SvgGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgGTE"))
			it.SvgGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgLT"))
			it.SvgLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgLTE"))
			it.SvgLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgContains"))
			it.SvgContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgHasPrefix"))
			it.SvgHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgHasSuffix"))
			it.SvgHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgIsNil"))
			it.SvgIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgNotNil"))
			it.SvgNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgEqualFold"))
			it.SvgEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgContainsFold"))
			it.SvgContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWallet":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWallet"))
			it.HasWallet, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWalletWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWalletWith"))
			it.HasWalletWith, err = ec.unmarshalOWalletWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWeapon":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeapon"))
			it.HasWeapon, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWeaponWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeaponWith"))
			it.HasWeaponWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasClothes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasClothes"))
			it.HasClothes, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasClothesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasClothesWith"))
			it.HasClothesWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasVehicle":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasVehicle"))
			it.HasVehicle, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasVehicleWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasVehicleWith"))
			it.HasVehicleWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWaist":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWaist"))
			it.HasWaist, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWaistWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWaistWith"))
			it.HasWaistWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasFoot":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasFoot"))
			it.HasFoot, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasFootWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasFootWith"))
			it.HasFootWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHand":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHand"))
			it.HasHand, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHandWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHandWith"))
			it.HasHandWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDrug":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDrug"))
			it.HasDrug, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDrugWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDrugWith"))
			it.HasDrugWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasNeck":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasNeck"))
			it.HasNeck, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasNeckWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasNeckWith"))
			it.HasNeckWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRing":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRing"))
			it.HasRing, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRingWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRingWith"))
			it.HasRingWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAccessory":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccessory"))
			it.HasAccessory, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAccessoryWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccessoryWith"))
			it.HasAccessoryWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasBody":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBody"))
			it.HasBody, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasBodyWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBodyWith"))
			it.HasBodyWith, err = ec.unmarshalOBodyPartWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHair":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHair"))
			it.HasHair, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHairWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHairWith"))
			it.HasHairWith, err = ec.unmarshalOBodyPartWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasBeard":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBeard"))
			it.HasBeard, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasBeardWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBeardWith"))
			it.HasBeardWith, err = ec.unmarshalOBodyPartWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasIndex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIndex"))
			it.HasIndex, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasIndexWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIndexWith"))
			it.HasIndexWith, err = ec.unmarshalOSearchWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputItemOrder(ctx context.Context, obj interface{}) (ent.ItemOrder, error) {
	var it ent.ItemOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalOItemOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputItemWhereInput(ctx context.Context, obj interface{}) (ent.ItemWhereInput, error) {
	var it ent.ItemWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOItemType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			it.TypeNEQ, err = ec.unmarshalOItemType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			it.TypeIn, err = ec.unmarshalOItemType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			it.TypeNotIn, err = ec.unmarshalOItemType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "namePrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefix"))
			it.NamePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namePrefixNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixNEQ"))
			it.NamePrefixNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namePrefixIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixIn"))
			it.NamePrefixIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "namePrefixNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixNotIn"))
			it.NamePrefixNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "namePrefixGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixGT"))
			it.NamePrefixGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namePrefixGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixGTE"))
			it.NamePrefixGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namePrefixLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixLT"))
			it.NamePrefixLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namePrefixLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixLTE"))
			it.NamePrefixLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namePrefixContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixContains"))
			it.NamePrefixContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namePrefixHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixHasPrefix"))
			it.NamePrefixHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namePrefixHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixHasSuffix"))
			it.NamePrefixHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namePrefixIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixIsNil"))
			it.NamePrefixIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "namePrefixNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixNotNil"))
			it.NamePrefixNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "namePrefixEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixEqualFold"))
			it.NamePrefixEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namePrefixContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixContainsFold"))
			it.NamePrefixContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffix"))
			it.NameSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameSuffixNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixNEQ"))
			it.NameSuffixNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameSuffixIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixIn"))
			it.NameSuffixIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameSuffixNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixNotIn"))
			it.NameSuffixNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameSuffixGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixGT"))
			it.NameSuffixGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameSuffixGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixGTE"))
			it.NameSuffixGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameSuffixLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixLT"))
			it.NameSuffixLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameSuffixLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixLTE"))
			it.NameSuffixLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameSuffixContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixContains"))
			it.NameSuffixContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameSuffixHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixHasPrefix"))
			it.NameSuffixHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameSuffixHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixHasSuffix"))
			it.NameSuffixHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameSuffixIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixIsNil"))
			it.NameSuffixIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameSuffixNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixNotNil"))
			it.NameSuffixNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameSuffixEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixEqualFold"))
			it.NameSuffixEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameSuffixContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixContainsFold"))
			it.NameSuffixContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffix"))
			it.Suffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffixNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixNEQ"))
			it.SuffixNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffixIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixIn"))
			it.SuffixIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffixNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixNotIn"))
			it.SuffixNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffixGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixGT"))
			it.SuffixGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffixGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixGTE"))
			it.SuffixGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffixLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixLT"))
			it.SuffixLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffixLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixLTE"))
			it.SuffixLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffixContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixContains"))
			it.SuffixContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffixHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixHasPrefix"))
			it.SuffixHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffixHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixHasSuffix"))
			it.SuffixHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffixIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixIsNil"))
			it.SuffixIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffixNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixNotNil"))
			it.SuffixNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffixEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixEqualFold"))
			it.SuffixEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "suffixContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixContainsFold"))
			it.SuffixContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "augmented":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("augmented"))
			it.Augmented, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "augmentedNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("augmentedNEQ"))
			it.AugmentedNEQ, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "augmentedIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("augmentedIsNil"))
			it.AugmentedIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "augmentedNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("augmentedNotNil"))
			it.AugmentedNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "count":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			it.Count, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "countNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countNEQ"))
			it.CountNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "countIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countIn"))
			it.CountIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "countNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countNotIn"))
			it.CountNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "countGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countGT"))
			it.CountGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "countGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countGTE"))
			it.CountGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "countLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countLT"))
			it.CountLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "countLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countLTE"))
			it.CountLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "countIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countIsNil"))
			it.CountIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "countNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countNotNil"))
			it.CountNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "tier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tier"))
			it.Tier, err = ec.unmarshalOItemTier2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierNEQ"))
			it.TierNEQ, err = ec.unmarshalOItemTier2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierIn"))
			it.TierIn, err = ec.unmarshalOItemTier2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTierᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierNotIn"))
			it.TierNotIn, err = ec.unmarshalOItemTier2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTierᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierIsNil"))
			it.TierIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierNotNil"))
			it.TierNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatness":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatness"))
			it.Greatness, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessNEQ"))
			it.GreatnessNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessIn"))
			it.GreatnessIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessNotIn"))
			it.GreatnessNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessGT"))
			it.GreatnessGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessGTE"))
			it.GreatnessGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessLT"))
			it.GreatnessLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessLTE"))
			it.GreatnessLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessIsNil"))
			it.GreatnessIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessNotNil"))
			it.GreatnessNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "svg":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svg"))
			it.Svg, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgNEQ"))
			it.SvgNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgIn"))
			it.SvgIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgNotIn"))
			it.SvgNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgGT"))
			it.SvgGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgGTE"))
			it.SvgGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgLT"))
			it.SvgLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgLTE"))
			it.SvgLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgContains"))
			it.SvgContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgHasPrefix"))
			it.SvgHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgHasSuffix"))
			it.SvgHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgIsNil"))
			it.SvgIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgNotNil"))
			it.SvgNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgEqualFold"))
			it.SvgEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "svgContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgContainsFold"))
			it.SvgContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWallets":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWallets"))
			it.HasWallets, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWalletsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWalletsWith"))
			it.HasWalletsWith, err = ec.unmarshalOWalletItemsWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDopes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDopes"))
			it.HasDopes, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDopesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDopesWith"))
			it.HasDopesWith, err = ec.unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerWeapons":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWeapons"))
			it.HasHustlerWeapons, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerWeaponsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWeaponsWith"))
			it.HasHustlerWeaponsWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerClothes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerClothes"))
			it.HasHustlerClothes, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerClothesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerClothesWith"))
			it.HasHustlerClothesWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerVehicles":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerVehicles"))
			it.HasHustlerVehicles, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerVehiclesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerVehiclesWith"))
			it.HasHustlerVehiclesWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerWaists":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWaists"))
			it.HasHustlerWaists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerWaistsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWaistsWith"))
			it.HasHustlerWaistsWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerFeet":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerFeet"))
			it.HasHustlerFeet, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerFeetWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerFeetWith"))
			it.HasHustlerFeetWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerHands":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerHands"))
			it.HasHustlerHands, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerHandsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerHandsWith"))
			it.HasHustlerHandsWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerDrugs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerDrugs"))
			it.HasHustlerDrugs, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerDrugsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerDrugsWith"))
			it.HasHustlerDrugsWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerNecks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerNecks"))
			it.HasHustlerNecks, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerNecksWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerNecksWith"))
			it.HasHustlerNecksWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerRings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerRings"))
			it.HasHustlerRings, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerRingsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerRingsWith"))
			it.HasHustlerRingsWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerAccessories":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerAccessories"))
			it.HasHustlerAccessories, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerAccessoriesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerAccessoriesWith"))
			it.HasHustlerAccessoriesWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasBase":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBase"))
			it.HasBase, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasBaseWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBaseWith"))
			it.HasBaseWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDerivative":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDerivative"))
			it.HasDerivative, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDerivativeWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDerivativeWith"))
			it.HasDerivativeWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasIndex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIndex"))
			it.HasIndex, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasIndexWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIndexWith"))
			it.HasIndexWith, err = ec.unmarshalOSearchWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListingOrder(ctx context.Context, obj interface{}) (ent.ListingOrder, error) {
	var it ent.ListingOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListingWhereInput(ctx context.Context, obj interface{}) (ent.ListingWhereInput, error) {
	var it ent.ListingWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOListingWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOListingWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOListingWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			it.Active, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "activeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("activeNEQ"))
			it.ActiveNEQ, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "source":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source"))
			it.Source, err = ec.unmarshalOSource2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋlistingᚐSource(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceNEQ"))
			it.SourceNEQ, err = ec.unmarshalOSource2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋlistingᚐSource(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceIn"))
			it.SourceIn, err = ec.unmarshalOSource2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋlistingᚐSourceᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceNotIn"))
			it.SourceNotIn, err = ec.unmarshalOSource2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋlistingᚐSourceᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDope":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDope"))
			it.HasDope, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDopeWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDopeWith"))
			it.HasDopeWith, err = ec.unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDopeLastsales":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDopeLastsales"))
			it.HasDopeLastsales, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDopeLastsalesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDopeLastsalesWith"))
			it.HasDopeLastsalesWith, err = ec.unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasInputs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInputs"))
			it.HasInputs, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasInputsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInputsWith"))
			it.HasInputsWith, err = ec.unmarshalOAmountWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐAmountWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOutputs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOutputs"))
			it.HasOutputs, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOutputsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOutputsWith"))
			it.HasOutputsWith, err = ec.unmarshalOAmountWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐAmountWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchIndexWhereInput(ctx context.Context, obj interface{}) (model.SearchIndexWhereInput, error) {
	var it model.SearchIndexWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOSearchIndexWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchIndexWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOSearchIndexWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchIndexWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOSearchIndexWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchIndexWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNeq, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDope":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDope"))
			it.HasDope, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDopeWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDopeWith"))
			it.HasDopeWith, err = ec.unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItem":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItem"))
			it.HasItem, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItemWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItemWith"))
			it.HasItemWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustler":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustler"))
			it.HasHustler, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWith"))
			it.HasHustlerWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchOrder(ctx context.Context, obj interface{}) (ent.SearchOrder, error) {
	var it ent.SearchOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalOOrderDirection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalOSearchOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchResultWhereInput(ctx context.Context, obj interface{}) (model.SearchResultWhereInput, error) {
	var it model.SearchResultWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOSearchResultWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchResultWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOSearchResultWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchResultWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOSearchResultWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchResultWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNeq, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDope":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDope"))
			it.HasDope, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDopeWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDopeWith"))
			it.HasDopeWith, err = ec.unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItem":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItem"))
			it.HasItem, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItemWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItemWith"))
			it.HasItemWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustler":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustler"))
			it.HasHustler, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWith"))
			it.HasHustlerWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchWhereInput(ctx context.Context, obj interface{}) (ent.SearchWhereInput, error) {
	var it ent.SearchWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOSearchWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOSearchWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOSearchWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOSearchType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			it.TypeNEQ, err = ec.unmarshalOSearchType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			it.TypeIn, err = ec.unmarshalOSearchType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			it.TypeNotIn, err = ec.unmarshalOSearchType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatness":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatness"))
			it.Greatness, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessNEQ"))
			it.GreatnessNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessIn"))
			it.GreatnessIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessNotIn"))
			it.GreatnessNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessGT"))
			it.GreatnessGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessGTE"))
			it.GreatnessGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessLT"))
			it.GreatnessLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessLTE"))
			it.GreatnessLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessIsNil"))
			it.GreatnessIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "greatnessNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessNotNil"))
			it.GreatnessNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "claimed":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimed"))
			it.Claimed, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "claimedNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimedNEQ"))
			it.ClaimedNEQ, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "opened":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opened"))
			it.Opened, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "openedNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("openedNEQ"))
			it.OpenedNEQ, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "saleActive":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("saleActive"))
			it.SaleActive, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "saleActiveNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("saleActiveNEQ"))
			it.SaleActiveNEQ, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "salePrice":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePrice"))
			it.SalePrice, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "salePriceNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceNEQ"))
			it.SalePriceNEQ, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "salePriceIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceIn"))
			it.SalePriceIn, err = ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "salePriceNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceNotIn"))
			it.SalePriceNotIn, err = ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "salePriceGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceGT"))
			it.SalePriceGT, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "salePriceGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceGTE"))
			it.SalePriceGTE, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "salePriceLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceLT"))
			it.SalePriceLT, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "salePriceLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceLTE"))
			it.SalePriceLTE, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSalePrice":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSalePrice"))
			it.LastSalePrice, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSalePriceNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSalePriceNEQ"))
			it.LastSalePriceNEQ, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSalePriceIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSalePriceIn"))
			it.LastSalePriceIn, err = ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSalePriceNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSalePriceNotIn"))
			it.LastSalePriceNotIn, err = ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSalePriceGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSalePriceGT"))
			it.LastSalePriceGT, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSalePriceGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSalePriceGTE"))
			it.LastSalePriceGTE, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSalePriceLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSalePriceLT"))
			it.LastSalePriceLT, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSalePriceLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSalePriceLTE"))
			it.LastSalePriceLTE, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDope":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDope"))
			it.HasDope, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDopeWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDopeWith"))
			it.HasDopeWith, err = ec.unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItem":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItem"))
			it.HasItem, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItemWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItemWith"))
			it.HasItemWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustler":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustler"))
			it.HasHustler, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlerWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWith"))
			it.HasHustlerWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSyncStateWhereInput(ctx context.Context, obj interface{}) (ent.SyncStateWhereInput, error) {
	var it ent.SyncStateWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOSyncStateWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSyncStateWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOSyncStateWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSyncStateWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOSyncStateWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSyncStateWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "startBlock":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlock"))
			it.StartBlock, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "startBlockNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlockNEQ"))
			it.StartBlockNEQ, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "startBlockIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlockIn"))
			it.StartBlockIn, err = ec.unmarshalOLong2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "startBlockNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlockNotIn"))
			it.StartBlockNotIn, err = ec.unmarshalOLong2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "startBlockGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlockGT"))
			it.StartBlockGT, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "startBlockGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlockGTE"))
			it.StartBlockGTE, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "startBlockLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlockLT"))
			it.StartBlockLT, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "startBlockLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlockLTE"))
			it.StartBlockLTE, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWalletItemsOrder(ctx context.Context, obj interface{}) (ent.WalletItemsOrder, error) {
	var it ent.WalletItemsOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWalletItemsWhereInput(ctx context.Context, obj interface{}) (ent.WalletItemsWhereInput, error) {
	var it ent.WalletItemsWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOWalletItemsWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOWalletItemsWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOWalletItemsWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "balance":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balance"))
			it.Balance, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceNEQ"))
			it.BalanceNEQ, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIn"))
			it.BalanceIn, err = ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceNotIn"))
			it.BalanceNotIn, err = ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceGT"))
			it.BalanceGT, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceGTE"))
			it.BalanceGTE, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceLT"))
			it.BalanceLT, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceLTE"))
			it.BalanceLTE, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWallet":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWallet"))
			it.HasWallet, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWalletWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWalletWith"))
			it.HasWalletWith, err = ec.unmarshalOWalletWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItem":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItem"))
			it.HasItem, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItemWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItemWith"))
			it.HasItemWith, err = ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWalletOrder(ctx context.Context, obj interface{}) (ent.WalletOrder, error) {
	var it ent.WalletOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWalletWhereInput(ctx context.Context, obj interface{}) (ent.WalletWhereInput, error) {
	var it ent.WalletWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOWalletWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOWalletWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOWalletWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "paper":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paper"))
			it.Paper, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "paperNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paperNEQ"))
			it.PaperNEQ, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "paperIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paperIn"))
			it.PaperIn, err = ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "paperNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paperNotIn"))
			it.PaperNotIn, err = ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "paperGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paperGT"))
			it.PaperGT, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "paperGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paperGTE"))
			it.PaperGTE, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "paperLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paperLT"))
			it.PaperLT, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "paperLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paperLTE"))
			it.PaperLTE, err = ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDopes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDopes"))
			it.HasDopes, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDopesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDopesWith"))
			it.HasDopesWith, err = ec.unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItems":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItems"))
			it.HasItems, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItemsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItemsWith"))
			it.HasItemsWith, err = ec.unmarshalOWalletItemsWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlers"))
			it.HasHustlers, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasHustlersWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlersWith"))
			it.HasHustlersWith, err = ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj ent.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.Item:
		if obj == nil {
			return graphql.Null
		}
		return ec._Item(ctx, sel, obj)
	case *ent.WalletItems:
		if obj == nil {
			return graphql.Null
		}
		return ec._WalletItems(ctx, sel, obj)
	case *ent.BodyPart:
		if obj == nil {
			return graphql.Null
		}
		return ec._BodyPart(ctx, sel, obj)
	case *ent.Hustler:
		if obj == nil {
			return graphql.Null
		}
		return ec._Hustler(ctx, sel, obj)
	case *ent.Listing:
		if obj == nil {
			return graphql.Null
		}
		return ec._Listing(ctx, sel, obj)
	case *ent.Amount:
		if obj == nil {
			return graphql.Null
		}
		return ec._Amount(ctx, sel, obj)
	case *ent.Dope:
		if obj == nil {
			return graphql.Null
		}
		return ec._Dope(ctx, sel, obj)
	case *ent.Wallet:
		if obj == nil {
			return graphql.Null
		}
		return ec._Wallet(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SearchResult(ctx context.Context, sel ast.SelectionSet, obj model.SearchResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.Dope:
		if obj == nil {
			return graphql.Null
		}
		return ec._Dope(ctx, sel, obj)
	case *ent.Item:
		if obj == nil {
			return graphql.Null
		}
		return ec._Item(ctx, sel, obj)
	case *ent.Hustler:
		if obj == nil {
			return graphql.Null
		}
		return ec._Hustler(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Token(ctx context.Context, sel ast.SelectionSet, obj model.Token) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.Dope:
		if obj == nil {
			return graphql.Null
		}
		return ec._Dope(ctx, sel, obj)
	case *ent.Item:
		if obj == nil {
			return graphql.Null
		}
		return ec._Item(ctx, sel, obj)
	case *ent.Hustler:
		if obj == nil {
			return graphql.Null
		}
		return ec._Hustler(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var amountImplementors = []string{"Amount", "Node"}

func (ec *executionContext) _Amount(ctx context.Context, sel ast.SelectionSet, obj *ent.Amount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, amountImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Amount")
		case "id":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Amount_id(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Amount_type(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "token":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Amount_token(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "amount":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Amount_amount(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var bodyPartImplementors = []string{"BodyPart", "Node"}

func (ec *executionContext) _BodyPart(ctx context.Context, sel ast.SelectionSet, obj *ent.BodyPart) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bodyPartImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BodyPart")
		case "id":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._BodyPart_id(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._BodyPart_type(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sex":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._BodyPart_sex(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rle":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._BodyPart_rle(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dopeImplementors = []string{"Dope", "Token", "Node", "SearchResult"}

func (ec *executionContext) _Dope(ctx context.Context, sel ast.SelectionSet, obj *ent.Dope) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dopeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Dope")
		case "id":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Dope_id(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "items":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dope_items(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "claimed":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Dope_claimed(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "opened":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Dope_opened(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "score":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Dope_score(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "rank":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Dope_rank(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "listings":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dope_listings(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "lastSale":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dope_lastSale(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dopeConnectionImplementors = []string{"DopeConnection"}

func (ec *executionContext) _DopeConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.DopeConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dopeConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DopeConnection")
		case "totalCount":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._DopeConnection_totalCount(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._DopeConnection_pageInfo(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edges":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._DopeConnection_edges(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dopeEdgeImplementors = []string{"DopeEdge"}

func (ec *executionContext) _DopeEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.DopeEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dopeEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DopeEdge")
		case "node":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._DopeEdge_node(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "cursor":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._DopeEdge_cursor(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var hustlerImplementors = []string{"Hustler", "Node", "Token", "SearchResult"}

func (ec *executionContext) _Hustler(ctx context.Context, sel ast.SelectionSet, obj *ent.Hustler) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hustlerImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Hustler")
		case "id":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Hustler_id(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Hustler_type(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Hustler_name(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "title":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Hustler_title(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "color":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Hustler_color(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "background":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Hustler_background(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "age":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Hustler_age(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "sex":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Hustler_sex(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "viewbox":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Hustler_viewbox(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "order":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Hustler_order(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "svg":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Hustler_svg(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "body":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_body(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hair":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_hair(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "beard":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_beard(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "weapon":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_weapon(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "clothes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_clothes(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "vehicle":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_vehicle(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "waist":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_waist(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "foot":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_foot(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hand":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_hand(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "drug":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_drug(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "neck":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_neck(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ring":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_ring(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "accessory":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_accessory(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var hustlerConnectionImplementors = []string{"HustlerConnection"}

func (ec *executionContext) _HustlerConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.HustlerConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hustlerConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HustlerConnection")
		case "totalCount":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._HustlerConnection_totalCount(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._HustlerConnection_pageInfo(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edges":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._HustlerConnection_edges(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var hustlerEdgeImplementors = []string{"HustlerEdge"}

func (ec *executionContext) _HustlerEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.HustlerEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hustlerEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HustlerEdge")
		case "node":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._HustlerEdge_node(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "cursor":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._HustlerEdge_cursor(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var itemImplementors = []string{"Item", "Node", "Token", "SearchResult"}

func (ec *executionContext) _Item(ctx context.Context, sel ast.SelectionSet, obj *ent.Item) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Item")
		case "id":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Item_id(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Item_type(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "fullname":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_fullname(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "name":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Item_name(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "namePrefix":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Item_namePrefix(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "nameSuffix":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Item_nameSuffix(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "suffix":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Item_suffix(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "augmented":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Item_augmented(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "tier":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Item_tier(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "greatness":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Item_greatness(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "count":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Item_count(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "rles":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Item_rles(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "svg":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Item_svg(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "base":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_base(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var itemConnectionImplementors = []string{"ItemConnection"}

func (ec *executionContext) _ItemConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.ItemConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ItemConnection")
		case "totalCount":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._ItemConnection_totalCount(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._ItemConnection_pageInfo(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edges":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._ItemConnection_edges(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var itemEdgeImplementors = []string{"ItemEdge"}

func (ec *executionContext) _ItemEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.ItemEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ItemEdge")
		case "node":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._ItemEdge_node(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "cursor":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._ItemEdge_cursor(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listingImplementors = []string{"Listing", "Node"}

func (ec *executionContext) _Listing(ctx context.Context, sel ast.SelectionSet, obj *ent.Listing) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listingImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Listing")
		case "id":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Listing_id(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "source":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Listing_source(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "active":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Listing_active(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "inputs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Listing_inputs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "outputs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Listing_outputs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "wyvernOrder":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Listing_wyvernOrder(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "seaportOrder":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Listing_seaportOrder(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listingConnectionImplementors = []string{"ListingConnection"}

func (ec *executionContext) _ListingConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.ListingConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listingConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListingConnection")
		case "totalCount":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._ListingConnection_totalCount(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._ListingConnection_pageInfo(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edges":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._ListingConnection_edges(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listingEdgeImplementors = []string{"ListingEdge"}

func (ec *executionContext) _ListingEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.ListingEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listingEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListingEdge")
		case "node":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._ListingEdge_node(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "cursor":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._ListingEdge_cursor(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *ent.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._PageInfo_hasNextPage(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hasPreviousPage":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._PageInfo_hasPreviousPage(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startCursor":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._PageInfo_startCursor(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "endCursor":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._PageInfo_endCursor(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "nodes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "wallets":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_wallets(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "dopes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_dopes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "items":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_items(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "walletItems":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_walletItems(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "hustlers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hustlers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "listings":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "search":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_search(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			}

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, innerFunc)

		case "__schema":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			}

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, innerFunc)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var rLEsImplementors = []string{"RLEs"}

func (ec *executionContext) _RLEs(ctx context.Context, sel ast.SelectionSet, obj *schema.RLEs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rLEsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RLEs")
		case "female":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._RLEs_female(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "male":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._RLEs_male(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var seaportOrderImplementors = []string{"SeaportOrder"}

func (ec *executionContext) _SeaportOrder(ctx context.Context, sel ast.SelectionSet, obj *opensea.SeaportOrder) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, seaportOrderImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SeaportOrder")
		case "maker":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SeaportOrder_maker(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "currentPrice":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SeaportOrder_currentPrice(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "listingTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SeaportOrder_listingTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "expirationTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SeaportOrder_expirationTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "side":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._SeaportOrder_side(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "orderType":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._SeaportOrder_orderType(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var searchConnectionImplementors = []string{"SearchConnection"}

func (ec *executionContext) _SearchConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.SearchConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchConnection")
		case "totalCount":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._SearchConnection_totalCount(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._SearchConnection_pageInfo(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edges":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._SearchConnection_edges(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var searchEdgeImplementors = []string{"SearchEdge"}

func (ec *executionContext) _SearchEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.SearchEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchEdge")
		case "node":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SearchEdge_node(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "cursor":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._SearchEdge_cursor(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var walletImplementors = []string{"Wallet", "Node"}

func (ec *executionContext) _Wallet(ctx context.Context, sel ast.SelectionSet, obj *ent.Wallet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, walletImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Wallet")
		case "id":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Wallet_id(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dopes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Wallet_dopes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hustlers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Wallet_hustlers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "items":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Wallet_items(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "paper":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Wallet_paper(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var walletConnectionImplementors = []string{"WalletConnection"}

func (ec *executionContext) _WalletConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.WalletConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, walletConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WalletConnection")
		case "totalCount":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._WalletConnection_totalCount(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._WalletConnection_pageInfo(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edges":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._WalletConnection_edges(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var walletEdgeImplementors = []string{"WalletEdge"}

func (ec *executionContext) _WalletEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.WalletEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, walletEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WalletEdge")
		case "node":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._WalletEdge_node(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "cursor":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._WalletEdge_cursor(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var walletItemsImplementors = []string{"WalletItems", "Node"}

func (ec *executionContext) _WalletItems(ctx context.Context, sel ast.SelectionSet, obj *ent.WalletItems) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, walletItemsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WalletItems")
		case "id":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._WalletItems_id(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "balance":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._WalletItems_balance(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "wallet":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WalletItems_wallet(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "item":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WalletItems_item(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var walletItemsConnectionImplementors = []string{"WalletItemsConnection"}

func (ec *executionContext) _WalletItemsConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.WalletItemsConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, walletItemsConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WalletItemsConnection")
		case "totalCount":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._WalletItemsConnection_totalCount(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._WalletItemsConnection_pageInfo(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edges":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._WalletItemsConnection_edges(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var walletItemsEdgeImplementors = []string{"WalletItemsEdge"}

func (ec *executionContext) _WalletItemsEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.WalletItemsEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, walletItemsEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WalletItemsEdge")
		case "node":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._WalletItemsEdge_node(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "cursor":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._WalletItemsEdge_cursor(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var wyvernOrderImplementors = []string{"WyvernOrder"}

func (ec *executionContext) _WyvernOrder(ctx context.Context, sel ast.SelectionSet, obj *opensea.WyvernOrder) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wyvernOrderImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WyvernOrder")
		case "exchange":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_exchange(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "listingTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_listingTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "expirationTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_expirationTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "maker":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_maker(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "currentPrice":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_currentPrice(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "makerRelayerFee":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_makerRelayerFee(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "makerProtocolFee":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_makerProtocolFee(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "feeRecipient":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_feeRecipient(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "feeMethod":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_feeMethod(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "side":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_side(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "saleKind":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_saleKind(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "target":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_target(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "howToCall":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_howToCall(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "calldata":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_calldata(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "replacementPattern":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_replacementPattern(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "staticTarget":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_staticTarget(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "staticExtradata":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_staticExtradata(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "extra":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_extra(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "salt":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_salt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "v":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_v(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "r":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_r(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "s":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WyvernOrder_s(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Directive_name(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Directive_description(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "locations":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Directive_locations(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Directive_args(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Directive_isRepeatable(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___EnumValue_name(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___EnumValue_description(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "isDeprecated":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___EnumValue_isDeprecated(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___EnumValue_deprecationReason(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Field_name(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Field_description(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "args":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Field_args(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Field_type(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Field_isDeprecated(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Field_deprecationReason(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___InputValue_name(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___InputValue_description(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "type":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___InputValue_type(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___InputValue_defaultValue(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Schema_description(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "types":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Schema_types(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Schema_queryType(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Schema_mutationType(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "subscriptionType":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Schema_subscriptionType(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "directives":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Schema_directives(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Type_kind(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Type_name(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "description":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Type_description(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "fields":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Type_fields(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "interfaces":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Type_interfaces(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "possibleTypes":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Type_possibleTypes(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "enumValues":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Type_enumValues(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "inputFields":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Type_inputFields(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "ofType":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Type_ofType(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "specifiedByURL":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec.___Type_specifiedByURL(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddress2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddress2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNAmount2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐAmount(ctx context.Context, sel ast.SelectionSet, v []*ent.Amount) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAmount2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐAmount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNAmountType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋamountᚐType(ctx context.Context, v interface{}) (amount.Type, error) {
	var res amount.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAmountType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋamountᚐType(ctx context.Context, sel ast.SelectionSet, v amount.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNAmountWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐAmountWhereInput(ctx context.Context, v interface{}) (*ent.AmountWhereInput, error) {
	res, err := ec.unmarshalInputAmountWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBigInt2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx context.Context, v interface{}) (schema.BigInt, error) {
	var res schema.BigInt
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBigInt2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx context.Context, sel ast.SelectionSet, v schema.BigInt) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBodyPartSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx context.Context, v interface{}) (bodypart.Sex, error) {
	var res bodypart.Sex
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBodyPartSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx context.Context, sel ast.SelectionSet, v bodypart.Sex) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBodyPartType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx context.Context, v interface{}) (bodypart.Type, error) {
	var res bodypart.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBodyPartType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx context.Context, sel ast.SelectionSet, v bodypart.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBodyPartWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInput(ctx context.Context, v interface{}) (*ent.BodyPartWhereInput, error) {
	res, err := ec.unmarshalInputBodyPartWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBytes2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBytes2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNCursor2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx context.Context, v interface{}) (ent.Cursor, error) {
	var res ent.Cursor
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx context.Context, sel ast.SelectionSet, v ent.Cursor) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDope2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Dope) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDope2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDope(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDope2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDope(ctx context.Context, sel ast.SelectionSet, v *ent.Dope) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Dope(ctx, sel, v)
}

func (ec *executionContext) marshalNDopeConnection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeConnection(ctx context.Context, sel ast.SelectionSet, v ent.DopeConnection) graphql.Marshaler {
	return ec._DopeConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNDopeConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeConnection(ctx context.Context, sel ast.SelectionSet, v *ent.DopeConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DopeConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDopeWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInput(ctx context.Context, v interface{}) (*ent.DopeWhereInput, error) {
	res, err := ec.unmarshalInputDopeWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEventWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐEventWhereInput(ctx context.Context, v interface{}) (*ent.EventWhereInput, error) {
	res, err := ec.unmarshalInputEventWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNGameHustlerItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerItemWhereInput, error) {
	res, err := ec.unmarshalInputGameHustlerItemWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNGameHustlerQuestWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerQuestWhereInput, error) {
	res, err := ec.unmarshalInputGameHustlerQuestWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNGameHustlerRelationWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerRelationWhereInput, error) {
	res, err := ec.unmarshalInputGameHustlerRelationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNGameHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerWhereInput, error) {
	res, err := ec.unmarshalInputGameHustlerWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Hustler) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHustler2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustler(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHustler2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustler(ctx context.Context, sel ast.SelectionSet, v *ent.Hustler) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Hustler(ctx, sel, v)
}

func (ec *executionContext) marshalNHustlerConnection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerConnection(ctx context.Context, sel ast.SelectionSet, v ent.HustlerConnection) graphql.Marshaler {
	return ec._HustlerConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNHustlerConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerConnection(ctx context.Context, sel ast.SelectionSet, v *ent.HustlerConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HustlerConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHustlerSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx context.Context, v interface{}) (hustler.Sex, error) {
	var res hustler.Sex
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHustlerSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx context.Context, sel ast.SelectionSet, v hustler.Sex) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNHustlerType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx context.Context, v interface{}) (hustler.Type, error) {
	var res hustler.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHustlerType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx context.Context, sel ast.SelectionSet, v hustler.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInput(ctx context.Context, v interface{}) (*ent.HustlerWhereInput, error) {
	res, err := ec.unmarshalInputHustlerWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2ᚕintᚄ(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNItem2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Item) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx context.Context, sel ast.SelectionSet, v *ent.Item) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Item(ctx, sel, v)
}

func (ec *executionContext) marshalNItemConnection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemConnection(ctx context.Context, sel ast.SelectionSet, v ent.ItemConnection) graphql.Marshaler {
	return ec._ItemConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNItemConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemConnection(ctx context.Context, sel ast.SelectionSet, v *ent.ItemConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ItemConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNItemTier2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx context.Context, v interface{}) (item.Tier, error) {
	var res item.Tier
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemTier2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx context.Context, sel ast.SelectionSet, v item.Tier) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNItemType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx context.Context, v interface{}) (item.Type, error) {
	var res item.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx context.Context, sel ast.SelectionSet, v item.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInput(ctx context.Context, v interface{}) (*ent.ItemWhereInput, error) {
	res, err := ec.unmarshalInputItemWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNListingConnection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingConnection(ctx context.Context, sel ast.SelectionSet, v ent.ListingConnection) graphql.Marshaler {
	return ec._ListingConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNListingConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingConnection(ctx context.Context, sel ast.SelectionSet, v *ent.ListingConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ListingConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNListingWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingWhereInput(ctx context.Context, v interface{}) (*ent.ListingWhereInput, error) {
	res, err := ec.unmarshalInputListingWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNLong2uint64(ctx context.Context, v interface{}) (uint64, error) {
	res, err := model.UnmarshalUint64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLong2uint64(ctx context.Context, sel ast.SelectionSet, v uint64) graphql.Marshaler {
	res := model.MarshalUint64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNNode2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐNoder(ctx context.Context, sel ast.SelectionSet, v []ent.Noder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONode2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐNoder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNOrderDirection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐOrderDirection(ctx context.Context, v interface{}) (ent.OrderDirection, error) {
	var res ent.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐOrderDirection(ctx context.Context, sel ast.SelectionSet, v ent.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐPageInfo(ctx context.Context, sel ast.SelectionSet, v ent.PageInfo) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNSearchConnection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchConnection(ctx context.Context, sel ast.SelectionSet, v ent.SearchConnection) graphql.Marshaler {
	return ec._SearchConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSearchConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchConnection(ctx context.Context, sel ast.SelectionSet, v *ent.SearchConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SearchConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSearchIndexWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchIndexWhereInput(ctx context.Context, v interface{}) (*model.SearchIndexWhereInput, error) {
	res, err := ec.unmarshalInputSearchIndexWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSearchResultWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchResultWhereInput(ctx context.Context, v interface{}) (*model.SearchResultWhereInput, error) {
	res, err := ec.unmarshalInputSearchResultWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSearchType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx context.Context, v interface{}) (search.Type, error) {
	var res search.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSearchType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx context.Context, sel ast.SelectionSet, v search.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSearchWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInput(ctx context.Context, v interface{}) (*ent.SearchWhereInput, error) {
	res, err := ec.unmarshalInputSearchWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSource2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋlistingᚐSource(ctx context.Context, v interface{}) (listing.Source, error) {
	var res listing.Source
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSource2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋlistingᚐSource(ctx context.Context, sel ast.SelectionSet, v listing.Source) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNSyncStateWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSyncStateWhereInput(ctx context.Context, v interface{}) (*ent.SyncStateWhereInput, error) {
	res, err := ec.unmarshalInputSyncStateWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNWallet2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWallet(ctx context.Context, sel ast.SelectionSet, v *ent.Wallet) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Wallet(ctx, sel, v)
}

func (ec *executionContext) marshalNWalletConnection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletConnection(ctx context.Context, sel ast.SelectionSet, v ent.WalletConnection) graphql.Marshaler {
	return ec._WalletConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNWalletConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletConnection(ctx context.Context, sel ast.SelectionSet, v *ent.WalletConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WalletConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNWalletItems2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.WalletItems) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWalletItems2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItems(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWalletItems2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItems(ctx context.Context, sel ast.SelectionSet, v *ent.WalletItems) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WalletItems(ctx, sel, v)
}

func (ec *executionContext) marshalNWalletItemsConnection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsConnection(ctx context.Context, sel ast.SelectionSet, v ent.WalletItemsConnection) graphql.Marshaler {
	return ec._WalletItemsConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNWalletItemsConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsConnection(ctx context.Context, sel ast.SelectionSet, v *ent.WalletItemsConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WalletItemsConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWalletItemsWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInput(ctx context.Context, v interface{}) (*ent.WalletItemsWhereInput, error) {
	res, err := ec.unmarshalInputWalletItemsWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNWalletWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInput(ctx context.Context, v interface{}) (*ent.WalletWhereInput, error) {
	res, err := ec.unmarshalInputWalletWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAmount2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐAmount(ctx context.Context, sel ast.SelectionSet, v *ent.Amount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Amount(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAmountType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋamountᚐTypeᚄ(ctx context.Context, v interface{}) ([]amount.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]amount.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAmountType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋamountᚐType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAmountType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋamountᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []amount.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAmountType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋamountᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAmountType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋamountᚐType(ctx context.Context, v interface{}) (*amount.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(amount.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAmountType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋamountᚐType(ctx context.Context, sel ast.SelectionSet, v *amount.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOAmountWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐAmountWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.AmountWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.AmountWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAmountWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐAmountWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOAmountWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐAmountWhereInput(ctx context.Context, v interface{}) (*ent.AmountWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAmountWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx context.Context, v interface{}) ([]schema.BigInt, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]schema.BigInt, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBigInt2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx context.Context, sel ast.SelectionSet, v []schema.BigInt) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNBigInt2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx context.Context, v interface{}) (*schema.BigInt, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(schema.BigInt)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx context.Context, sel ast.SelectionSet, v *schema.BigInt) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOBodyPart2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPart(ctx context.Context, sel ast.SelectionSet, v *ent.BodyPart) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BodyPart(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBodyPartSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSexᚄ(ctx context.Context, v interface{}) ([]bodypart.Sex, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]bodypart.Sex, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBodyPartSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOBodyPartSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSexᚄ(ctx context.Context, sel ast.SelectionSet, v []bodypart.Sex) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBodyPartSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBodyPartSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx context.Context, v interface{}) (*bodypart.Sex, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(bodypart.Sex)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBodyPartSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx context.Context, sel ast.SelectionSet, v *bodypart.Sex) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBodyPartType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐTypeᚄ(ctx context.Context, v interface{}) ([]bodypart.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]bodypart.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBodyPartType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOBodyPartType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []bodypart.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBodyPartType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBodyPartType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx context.Context, v interface{}) (*bodypart.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(bodypart.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBodyPartType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx context.Context, sel ast.SelectionSet, v *bodypart.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBodyPartWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.BodyPartWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.BodyPartWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBodyPartWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOBodyPartWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInput(ctx context.Context, v interface{}) (*ent.BodyPartWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBodyPartWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx context.Context, v interface{}) (*ent.Cursor, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ent.Cursor)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐCursor(ctx context.Context, sel ast.SelectionSet, v *ent.Cursor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalODope2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDope(ctx context.Context, sel ast.SelectionSet, v *ent.Dope) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Dope(ctx, sel, v)
}

func (ec *executionContext) marshalODopeEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.DopeEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODopeEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalODopeEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeEdge(ctx context.Context, sel ast.SelectionSet, v *ent.DopeEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DopeEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalODopeOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeOrder(ctx context.Context, v interface{}) (*ent.DopeOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDopeOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODopeOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeOrderField(ctx context.Context, v interface{}) (*ent.DopeOrderField, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ent.DopeOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODopeOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.DopeOrderField) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.DopeWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.DopeWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDopeWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalODopeWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInput(ctx context.Context, v interface{}) (*ent.DopeWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDopeWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOEventWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐEventWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.EventWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.EventWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEventWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐEventWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOEventWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐEventWhereInput(ctx context.Context, v interface{}) (*ent.EventWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGameHustlerItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.GameHustlerItemWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GameHustlerItemWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGameHustlerItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGameHustlerItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerItemWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGameHustlerItemWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGameHustlerQuestWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.GameHustlerQuestWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GameHustlerQuestWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGameHustlerQuestWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGameHustlerQuestWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerQuestWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGameHustlerQuestWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGameHustlerRelationWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.GameHustlerRelationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GameHustlerRelationWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGameHustlerRelationWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGameHustlerRelationWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerRelationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGameHustlerRelationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGameHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.GameHustlerWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GameHustlerWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGameHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGameHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGameHustlerWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHustler2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustler(ctx context.Context, sel ast.SelectionSet, v *ent.Hustler) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Hustler(ctx, sel, v)
}

func (ec *executionContext) marshalOHustlerEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.HustlerEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOHustlerEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOHustlerEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerEdge(ctx context.Context, sel ast.SelectionSet, v *ent.HustlerEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HustlerEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHustlerOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerOrder(ctx context.Context, v interface{}) (*ent.HustlerOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputHustlerOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOHustlerSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSexᚄ(ctx context.Context, v interface{}) ([]hustler.Sex, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]hustler.Sex, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHustlerSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOHustlerSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSexᚄ(ctx context.Context, sel ast.SelectionSet, v []hustler.Sex) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHustlerSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOHustlerSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx context.Context, v interface{}) (*hustler.Sex, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(hustler.Sex)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHustlerSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx context.Context, sel ast.SelectionSet, v *hustler.Sex) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOHustlerType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐTypeᚄ(ctx context.Context, v interface{}) ([]hustler.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]hustler.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHustlerType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOHustlerType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []hustler.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHustlerType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOHustlerType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx context.Context, v interface{}) (*hustler.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(hustler.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHustlerType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx context.Context, sel ast.SelectionSet, v *hustler.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.HustlerWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.HustlerWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInput(ctx context.Context, v interface{}) (*ent.HustlerWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputHustlerWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOID2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚕintᚄ(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx context.Context, sel ast.SelectionSet, v *ent.Item) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Item(ctx, sel, v)
}

func (ec *executionContext) marshalOItemEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.ItemEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOItemEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOItemEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemEdge(ctx context.Context, sel ast.SelectionSet, v *ent.ItemEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ItemEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOItemOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemOrder(ctx context.Context, v interface{}) (*ent.ItemOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputItemOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOItemOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemOrderField(ctx context.Context, v interface{}) (*ent.ItemOrderField, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ent.ItemOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOItemOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.ItemOrderField) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOItemTier2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTierᚄ(ctx context.Context, v interface{}) ([]item.Tier, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]item.Tier, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNItemTier2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOItemTier2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTierᚄ(ctx context.Context, sel ast.SelectionSet, v []item.Tier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItemTier2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOItemTier2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx context.Context, v interface{}) (*item.Tier, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(item.Tier)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOItemTier2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx context.Context, sel ast.SelectionSet, v *item.Tier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOItemType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTypeᚄ(ctx context.Context, v interface{}) ([]item.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]item.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNItemType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOItemType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []item.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItemType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOItemType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx context.Context, v interface{}) (*item.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(item.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOItemType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx context.Context, sel ast.SelectionSet, v *item.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.ItemWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ItemWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInput(ctx context.Context, v interface{}) (*ent.ItemWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputItemWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOListing2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListing(ctx context.Context, sel ast.SelectionSet, v []*ent.Listing) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOListing2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListing(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOListing2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListing(ctx context.Context, sel ast.SelectionSet, v *ent.Listing) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Listing(ctx, sel, v)
}

func (ec *executionContext) marshalOListingEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.ListingEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOListingEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOListingEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingEdge(ctx context.Context, sel ast.SelectionSet, v *ent.ListingEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ListingEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOListingOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingOrder(ctx context.Context, v interface{}) (*ent.ListingOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputListingOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOListingWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.ListingWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ListingWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNListingWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOListingWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐListingWhereInput(ctx context.Context, v interface{}) (*ent.ListingWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputListingWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLong2ᚕuint64ᚄ(ctx context.Context, v interface{}) ([]uint64, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]uint64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLong2uint64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOLong2ᚕuint64ᚄ(ctx context.Context, sel ast.SelectionSet, v []uint64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNLong2uint64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOLong2ᚖuint64(ctx context.Context, v interface{}) (*uint64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := model.UnmarshalUint64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLong2ᚖuint64(ctx context.Context, sel ast.SelectionSet, v *uint64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := model.MarshalUint64(*v)
	return res
}

func (ec *executionContext) marshalONode2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐNoder(ctx context.Context, sel ast.SelectionSet, v ent.Noder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOrderDirection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐOrderDirection(ctx context.Context, v interface{}) (ent.OrderDirection, error) {
	var res ent.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrderDirection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐOrderDirection(ctx context.Context, sel ast.SelectionSet, v ent.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalORLEs2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐRLEs(ctx context.Context, sel ast.SelectionSet, v schema.RLEs) graphql.Marshaler {
	return ec._RLEs(ctx, sel, &v)
}

func (ec *executionContext) marshalOSeaportOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋjobsᚋopenseaᚐSeaportOrder(ctx context.Context, sel ast.SelectionSet, v *opensea.SeaportOrder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SeaportOrder(ctx, sel, v)
}

func (ec *executionContext) marshalOSearchEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.SearchEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSearchEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOSearchEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchEdge(ctx context.Context, sel ast.SelectionSet, v *ent.SearchEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SearchEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSearchIndexWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchIndexWhereInputᚄ(ctx context.Context, v interface{}) ([]*model.SearchIndexWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.SearchIndexWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSearchIndexWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchIndexWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSearchIndexWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchIndexWhereInput(ctx context.Context, v interface{}) (*model.SearchIndexWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchIndexWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSearchOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchOrder(ctx context.Context, v interface{}) (*ent.SearchOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSearchOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchOrderField(ctx context.Context, v interface{}) (*ent.SearchOrderField, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ent.SearchOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSearchOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.SearchOrderField) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOSearchResult2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchResult(ctx context.Context, sel ast.SelectionSet, v model.SearchResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SearchResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSearchResultWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchResultWhereInputᚄ(ctx context.Context, v interface{}) ([]*model.SearchResultWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.SearchResultWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSearchResultWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchResultWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSearchResultWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSearchResultWhereInput(ctx context.Context, v interface{}) (*model.SearchResultWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchResultWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSearchType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐTypeᚄ(ctx context.Context, v interface{}) ([]search.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]search.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSearchType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOSearchType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []search.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSearchType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOSearchType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx context.Context, v interface{}) (*search.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(search.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSearchType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx context.Context, sel ast.SelectionSet, v *search.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOSearchWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.SearchWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.SearchWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSearchWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSearchWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInput(ctx context.Context, v interface{}) (*ent.SearchWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSource2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋlistingᚐSource(ctx context.Context, v interface{}) (listing.Source, error) {
	var res listing.Source
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSource2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋlistingᚐSource(ctx context.Context, sel ast.SelectionSet, v listing.Source) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOSource2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋlistingᚐSourceᚄ(ctx context.Context, v interface{}) ([]listing.Source, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]listing.Source, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSource2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋlistingᚐSource(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOSource2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋlistingᚐSourceᚄ(ctx context.Context, sel ast.SelectionSet, v []listing.Source) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSource2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋlistingᚐSource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOSource2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋlistingᚐSource(ctx context.Context, v interface{}) (*listing.Source, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(listing.Source)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSource2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋlistingᚐSource(ctx context.Context, sel ast.SelectionSet, v *listing.Source) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOSyncStateWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSyncStateWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.SyncStateWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.SyncStateWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSyncStateWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSyncStateWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSyncStateWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSyncStateWhereInput(ctx context.Context, v interface{}) (*ent.SyncStateWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSyncStateWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx context.Context, v interface{}) ([]time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTime2timeᚐTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2ᚕtimeᚐTimeᚄ(ctx context.Context, sel ast.SelectionSet, v []time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeᚐTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOToken2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐToken(ctx context.Context, sel ast.SelectionSet, v model.Token) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Token(ctx, sel, v)
}

func (ec *executionContext) marshalOWallet2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWallet(ctx context.Context, sel ast.SelectionSet, v *ent.Wallet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Wallet(ctx, sel, v)
}

func (ec *executionContext) marshalOWalletEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.WalletEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWalletEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOWalletEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletEdge(ctx context.Context, sel ast.SelectionSet, v *ent.WalletEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WalletEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOWalletItems2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItems(ctx context.Context, sel ast.SelectionSet, v *ent.WalletItems) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WalletItems(ctx, sel, v)
}

func (ec *executionContext) marshalOWalletItemsEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.WalletItemsEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWalletItemsEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOWalletItemsEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsEdge(ctx context.Context, sel ast.SelectionSet, v *ent.WalletItemsEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WalletItemsEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWalletItemsOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsOrder(ctx context.Context, v interface{}) (*ent.WalletItemsOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWalletItemsOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOWalletItemsWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.WalletItemsWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.WalletItemsWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWalletItemsWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOWalletItemsWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInput(ctx context.Context, v interface{}) (*ent.WalletItemsWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWalletItemsWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOWalletOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletOrder(ctx context.Context, v interface{}) (*ent.WalletOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWalletOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOWalletWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.WalletWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.WalletWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWalletWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOWalletWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInput(ctx context.Context, v interface{}) (*ent.WalletWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWalletWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWyvernOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋjobsᚋopenseaᚐWyvernOrder(ctx context.Context, sel ast.SelectionSet, v *opensea.WyvernOrder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WyvernOrder(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
