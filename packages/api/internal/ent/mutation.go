// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/amount"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/bodypart"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/dope"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/event"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/gamehustler"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/gamehustleritem"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/gamehustlerquest"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/gamehustlerrelation"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/hustler"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/item"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/listing"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/predicate"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/schema"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/search"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/syncstate"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/wallet"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/walletitems"
	"github.com/ethereum/go-ethereum/common"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAmount              = "Amount"
	TypeBodyPart            = "BodyPart"
	TypeDope                = "Dope"
	TypeEvent               = "Event"
	TypeGameHustler         = "GameHustler"
	TypeGameHustlerItem     = "GameHustlerItem"
	TypeGameHustlerQuest    = "GameHustlerQuest"
	TypeGameHustlerRelation = "GameHustlerRelation"
	TypeHustler             = "Hustler"
	TypeItem                = "Item"
	TypeListing             = "Listing"
	TypeSearch              = "Search"
	TypeSyncState           = "SyncState"
	TypeWallet              = "Wallet"
	TypeWalletItems         = "WalletItems"
)

// AmountMutation represents an operation that mutates the Amount nodes in the graph.
type AmountMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	_type                 *amount.Type
	amount                *schema.BigInt
	addamount             *schema.BigInt
	asset_id              *schema.BigInt
	addasset_id           *schema.BigInt
	clearedFields         map[string]struct{}
	listing_input         *string
	clearedlisting_input  bool
	listing_output        *string
	clearedlisting_output bool
	done                  bool
	oldValue              func(context.Context) (*Amount, error)
	predicates            []predicate.Amount
}

var _ ent.Mutation = (*AmountMutation)(nil)

// amountOption allows management of the mutation configuration using functional options.
type amountOption func(*AmountMutation)

// newAmountMutation creates new mutation for the Amount entity.
func newAmountMutation(c config, op Op, opts ...amountOption) *AmountMutation {
	m := &AmountMutation{
		config:        c,
		op:            op,
		typ:           TypeAmount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAmountID sets the ID field of the mutation.
func withAmountID(id string) amountOption {
	return func(m *AmountMutation) {
		var (
			err   error
			once  sync.Once
			value *Amount
		)
		m.oldValue = func(ctx context.Context) (*Amount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Amount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAmount sets the old Amount of the mutation.
func withAmount(node *Amount) amountOption {
	return func(m *AmountMutation) {
		m.oldValue = func(context.Context) (*Amount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AmountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AmountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Amount entities.
func (m *AmountMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AmountMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AmountMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Amount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *AmountMutation) SetType(a amount.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AmountMutation) GetType() (r amount.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Amount entity.
// If the Amount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmountMutation) OldType(ctx context.Context) (v amount.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AmountMutation) ResetType() {
	m._type = nil
}

// SetAmount sets the "amount" field.
func (m *AmountMutation) SetAmount(si schema.BigInt) {
	m.amount = &si
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *AmountMutation) Amount() (r schema.BigInt, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Amount entity.
// If the Amount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmountMutation) OldAmount(ctx context.Context) (v schema.BigInt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds si to the "amount" field.
func (m *AmountMutation) AddAmount(si schema.BigInt) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(si)
	} else {
		m.addamount = &si
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *AmountMutation) AddedAmount() (r schema.BigInt, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *AmountMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetAssetID sets the "asset_id" field.
func (m *AmountMutation) SetAssetID(si schema.BigInt) {
	m.asset_id = &si
	m.addasset_id = nil
}

// AssetID returns the value of the "asset_id" field in the mutation.
func (m *AmountMutation) AssetID() (r schema.BigInt, exists bool) {
	v := m.asset_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetID returns the old "asset_id" field's value of the Amount entity.
// If the Amount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmountMutation) OldAssetID(ctx context.Context) (v schema.BigInt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetID: %w", err)
	}
	return oldValue.AssetID, nil
}

// AddAssetID adds si to the "asset_id" field.
func (m *AmountMutation) AddAssetID(si schema.BigInt) {
	if m.addasset_id != nil {
		*m.addasset_id = m.addasset_id.Add(si)
	} else {
		m.addasset_id = &si
	}
}

// AddedAssetID returns the value that was added to the "asset_id" field in this mutation.
func (m *AmountMutation) AddedAssetID() (r schema.BigInt, exists bool) {
	v := m.addasset_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAssetID resets all changes to the "asset_id" field.
func (m *AmountMutation) ResetAssetID() {
	m.asset_id = nil
	m.addasset_id = nil
}

// SetListingInputID sets the "listing_input" edge to the Listing entity by id.
func (m *AmountMutation) SetListingInputID(id string) {
	m.listing_input = &id
}

// ClearListingInput clears the "listing_input" edge to the Listing entity.
func (m *AmountMutation) ClearListingInput() {
	m.clearedlisting_input = true
}

// ListingInputCleared reports if the "listing_input" edge to the Listing entity was cleared.
func (m *AmountMutation) ListingInputCleared() bool {
	return m.clearedlisting_input
}

// ListingInputID returns the "listing_input" edge ID in the mutation.
func (m *AmountMutation) ListingInputID() (id string, exists bool) {
	if m.listing_input != nil {
		return *m.listing_input, true
	}
	return
}

// ListingInputIDs returns the "listing_input" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ListingInputID instead. It exists only for internal usage by the builders.
func (m *AmountMutation) ListingInputIDs() (ids []string) {
	if id := m.listing_input; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetListingInput resets all changes to the "listing_input" edge.
func (m *AmountMutation) ResetListingInput() {
	m.listing_input = nil
	m.clearedlisting_input = false
}

// SetListingOutputID sets the "listing_output" edge to the Listing entity by id.
func (m *AmountMutation) SetListingOutputID(id string) {
	m.listing_output = &id
}

// ClearListingOutput clears the "listing_output" edge to the Listing entity.
func (m *AmountMutation) ClearListingOutput() {
	m.clearedlisting_output = true
}

// ListingOutputCleared reports if the "listing_output" edge to the Listing entity was cleared.
func (m *AmountMutation) ListingOutputCleared() bool {
	return m.clearedlisting_output
}

// ListingOutputID returns the "listing_output" edge ID in the mutation.
func (m *AmountMutation) ListingOutputID() (id string, exists bool) {
	if m.listing_output != nil {
		return *m.listing_output, true
	}
	return
}

// ListingOutputIDs returns the "listing_output" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ListingOutputID instead. It exists only for internal usage by the builders.
func (m *AmountMutation) ListingOutputIDs() (ids []string) {
	if id := m.listing_output; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetListingOutput resets all changes to the "listing_output" edge.
func (m *AmountMutation) ResetListingOutput() {
	m.listing_output = nil
	m.clearedlisting_output = false
}

// Where appends a list predicates to the AmountMutation builder.
func (m *AmountMutation) Where(ps ...predicate.Amount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AmountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Amount).
func (m *AmountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AmountMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._type != nil {
		fields = append(fields, amount.FieldType)
	}
	if m.amount != nil {
		fields = append(fields, amount.FieldAmount)
	}
	if m.asset_id != nil {
		fields = append(fields, amount.FieldAssetID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AmountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case amount.FieldType:
		return m.GetType()
	case amount.FieldAmount:
		return m.Amount()
	case amount.FieldAssetID:
		return m.AssetID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AmountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case amount.FieldType:
		return m.OldType(ctx)
	case amount.FieldAmount:
		return m.OldAmount(ctx)
	case amount.FieldAssetID:
		return m.OldAssetID(ctx)
	}
	return nil, fmt.Errorf("unknown Amount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AmountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case amount.FieldType:
		v, ok := value.(amount.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case amount.FieldAmount:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case amount.FieldAssetID:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetID(v)
		return nil
	}
	return fmt.Errorf("unknown Amount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AmountMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, amount.FieldAmount)
	}
	if m.addasset_id != nil {
		fields = append(fields, amount.FieldAssetID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AmountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case amount.FieldAmount:
		return m.AddedAmount()
	case amount.FieldAssetID:
		return m.AddedAssetID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AmountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case amount.FieldAmount:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case amount.FieldAssetID:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssetID(v)
		return nil
	}
	return fmt.Errorf("unknown Amount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AmountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AmountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AmountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Amount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AmountMutation) ResetField(name string) error {
	switch name {
	case amount.FieldType:
		m.ResetType()
		return nil
	case amount.FieldAmount:
		m.ResetAmount()
		return nil
	case amount.FieldAssetID:
		m.ResetAssetID()
		return nil
	}
	return fmt.Errorf("unknown Amount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AmountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.listing_input != nil {
		edges = append(edges, amount.EdgeListingInput)
	}
	if m.listing_output != nil {
		edges = append(edges, amount.EdgeListingOutput)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AmountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case amount.EdgeListingInput:
		if id := m.listing_input; id != nil {
			return []ent.Value{*id}
		}
	case amount.EdgeListingOutput:
		if id := m.listing_output; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AmountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AmountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AmountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlisting_input {
		edges = append(edges, amount.EdgeListingInput)
	}
	if m.clearedlisting_output {
		edges = append(edges, amount.EdgeListingOutput)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AmountMutation) EdgeCleared(name string) bool {
	switch name {
	case amount.EdgeListingInput:
		return m.clearedlisting_input
	case amount.EdgeListingOutput:
		return m.clearedlisting_output
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AmountMutation) ClearEdge(name string) error {
	switch name {
	case amount.EdgeListingInput:
		m.ClearListingInput()
		return nil
	case amount.EdgeListingOutput:
		m.ClearListingOutput()
		return nil
	}
	return fmt.Errorf("unknown Amount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AmountMutation) ResetEdge(name string) error {
	switch name {
	case amount.EdgeListingInput:
		m.ResetListingInput()
		return nil
	case amount.EdgeListingOutput:
		m.ResetListingOutput()
		return nil
	}
	return fmt.Errorf("unknown Amount edge %s", name)
}

// BodyPartMutation represents an operation that mutates the BodyPart nodes in the graph.
type BodyPartMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	_type                 *bodypart.Type
	sex                   *bodypart.Sex
	rle                   *string
	sprite                *string
	clearedFields         map[string]struct{}
	hustler_bodies        map[string]struct{}
	removedhustler_bodies map[string]struct{}
	clearedhustler_bodies bool
	hustler_hairs         map[string]struct{}
	removedhustler_hairs  map[string]struct{}
	clearedhustler_hairs  bool
	hustler_beards        map[string]struct{}
	removedhustler_beards map[string]struct{}
	clearedhustler_beards bool
	done                  bool
	oldValue              func(context.Context) (*BodyPart, error)
	predicates            []predicate.BodyPart
}

var _ ent.Mutation = (*BodyPartMutation)(nil)

// bodypartOption allows management of the mutation configuration using functional options.
type bodypartOption func(*BodyPartMutation)

// newBodyPartMutation creates new mutation for the BodyPart entity.
func newBodyPartMutation(c config, op Op, opts ...bodypartOption) *BodyPartMutation {
	m := &BodyPartMutation{
		config:        c,
		op:            op,
		typ:           TypeBodyPart,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBodyPartID sets the ID field of the mutation.
func withBodyPartID(id string) bodypartOption {
	return func(m *BodyPartMutation) {
		var (
			err   error
			once  sync.Once
			value *BodyPart
		)
		m.oldValue = func(ctx context.Context) (*BodyPart, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BodyPart.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBodyPart sets the old BodyPart of the mutation.
func withBodyPart(node *BodyPart) bodypartOption {
	return func(m *BodyPartMutation) {
		m.oldValue = func(context.Context) (*BodyPart, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BodyPartMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BodyPartMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BodyPart entities.
func (m *BodyPartMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BodyPartMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BodyPartMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BodyPart.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *BodyPartMutation) SetType(b bodypart.Type) {
	m._type = &b
}

// GetType returns the value of the "type" field in the mutation.
func (m *BodyPartMutation) GetType() (r bodypart.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BodyPart entity.
// If the BodyPart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BodyPartMutation) OldType(ctx context.Context) (v bodypart.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BodyPartMutation) ResetType() {
	m._type = nil
}

// SetSex sets the "sex" field.
func (m *BodyPartMutation) SetSex(b bodypart.Sex) {
	m.sex = &b
}

// Sex returns the value of the "sex" field in the mutation.
func (m *BodyPartMutation) Sex() (r bodypart.Sex, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the BodyPart entity.
// If the BodyPart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BodyPartMutation) OldSex(ctx context.Context) (v bodypart.Sex, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// ResetSex resets all changes to the "sex" field.
func (m *BodyPartMutation) ResetSex() {
	m.sex = nil
}

// SetRle sets the "rle" field.
func (m *BodyPartMutation) SetRle(s string) {
	m.rle = &s
}

// Rle returns the value of the "rle" field in the mutation.
func (m *BodyPartMutation) Rle() (r string, exists bool) {
	v := m.rle
	if v == nil {
		return
	}
	return *v, true
}

// OldRle returns the old "rle" field's value of the BodyPart entity.
// If the BodyPart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BodyPartMutation) OldRle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRle: %w", err)
	}
	return oldValue.Rle, nil
}

// ResetRle resets all changes to the "rle" field.
func (m *BodyPartMutation) ResetRle() {
	m.rle = nil
}

// SetSprite sets the "sprite" field.
func (m *BodyPartMutation) SetSprite(s string) {
	m.sprite = &s
}

// Sprite returns the value of the "sprite" field in the mutation.
func (m *BodyPartMutation) Sprite() (r string, exists bool) {
	v := m.sprite
	if v == nil {
		return
	}
	return *v, true
}

// OldSprite returns the old "sprite" field's value of the BodyPart entity.
// If the BodyPart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BodyPartMutation) OldSprite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSprite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSprite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSprite: %w", err)
	}
	return oldValue.Sprite, nil
}

// ClearSprite clears the value of the "sprite" field.
func (m *BodyPartMutation) ClearSprite() {
	m.sprite = nil
	m.clearedFields[bodypart.FieldSprite] = struct{}{}
}

// SpriteCleared returns if the "sprite" field was cleared in this mutation.
func (m *BodyPartMutation) SpriteCleared() bool {
	_, ok := m.clearedFields[bodypart.FieldSprite]
	return ok
}

// ResetSprite resets all changes to the "sprite" field.
func (m *BodyPartMutation) ResetSprite() {
	m.sprite = nil
	delete(m.clearedFields, bodypart.FieldSprite)
}

// AddHustlerBodyIDs adds the "hustler_bodies" edge to the Hustler entity by ids.
func (m *BodyPartMutation) AddHustlerBodyIDs(ids ...string) {
	if m.hustler_bodies == nil {
		m.hustler_bodies = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_bodies[ids[i]] = struct{}{}
	}
}

// ClearHustlerBodies clears the "hustler_bodies" edge to the Hustler entity.
func (m *BodyPartMutation) ClearHustlerBodies() {
	m.clearedhustler_bodies = true
}

// HustlerBodiesCleared reports if the "hustler_bodies" edge to the Hustler entity was cleared.
func (m *BodyPartMutation) HustlerBodiesCleared() bool {
	return m.clearedhustler_bodies
}

// RemoveHustlerBodyIDs removes the "hustler_bodies" edge to the Hustler entity by IDs.
func (m *BodyPartMutation) RemoveHustlerBodyIDs(ids ...string) {
	if m.removedhustler_bodies == nil {
		m.removedhustler_bodies = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_bodies, ids[i])
		m.removedhustler_bodies[ids[i]] = struct{}{}
	}
}

// RemovedHustlerBodies returns the removed IDs of the "hustler_bodies" edge to the Hustler entity.
func (m *BodyPartMutation) RemovedHustlerBodiesIDs() (ids []string) {
	for id := range m.removedhustler_bodies {
		ids = append(ids, id)
	}
	return
}

// HustlerBodiesIDs returns the "hustler_bodies" edge IDs in the mutation.
func (m *BodyPartMutation) HustlerBodiesIDs() (ids []string) {
	for id := range m.hustler_bodies {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerBodies resets all changes to the "hustler_bodies" edge.
func (m *BodyPartMutation) ResetHustlerBodies() {
	m.hustler_bodies = nil
	m.clearedhustler_bodies = false
	m.removedhustler_bodies = nil
}

// AddHustlerHairIDs adds the "hustler_hairs" edge to the Hustler entity by ids.
func (m *BodyPartMutation) AddHustlerHairIDs(ids ...string) {
	if m.hustler_hairs == nil {
		m.hustler_hairs = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_hairs[ids[i]] = struct{}{}
	}
}

// ClearHustlerHairs clears the "hustler_hairs" edge to the Hustler entity.
func (m *BodyPartMutation) ClearHustlerHairs() {
	m.clearedhustler_hairs = true
}

// HustlerHairsCleared reports if the "hustler_hairs" edge to the Hustler entity was cleared.
func (m *BodyPartMutation) HustlerHairsCleared() bool {
	return m.clearedhustler_hairs
}

// RemoveHustlerHairIDs removes the "hustler_hairs" edge to the Hustler entity by IDs.
func (m *BodyPartMutation) RemoveHustlerHairIDs(ids ...string) {
	if m.removedhustler_hairs == nil {
		m.removedhustler_hairs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_hairs, ids[i])
		m.removedhustler_hairs[ids[i]] = struct{}{}
	}
}

// RemovedHustlerHairs returns the removed IDs of the "hustler_hairs" edge to the Hustler entity.
func (m *BodyPartMutation) RemovedHustlerHairsIDs() (ids []string) {
	for id := range m.removedhustler_hairs {
		ids = append(ids, id)
	}
	return
}

// HustlerHairsIDs returns the "hustler_hairs" edge IDs in the mutation.
func (m *BodyPartMutation) HustlerHairsIDs() (ids []string) {
	for id := range m.hustler_hairs {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerHairs resets all changes to the "hustler_hairs" edge.
func (m *BodyPartMutation) ResetHustlerHairs() {
	m.hustler_hairs = nil
	m.clearedhustler_hairs = false
	m.removedhustler_hairs = nil
}

// AddHustlerBeardIDs adds the "hustler_beards" edge to the Hustler entity by ids.
func (m *BodyPartMutation) AddHustlerBeardIDs(ids ...string) {
	if m.hustler_beards == nil {
		m.hustler_beards = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_beards[ids[i]] = struct{}{}
	}
}

// ClearHustlerBeards clears the "hustler_beards" edge to the Hustler entity.
func (m *BodyPartMutation) ClearHustlerBeards() {
	m.clearedhustler_beards = true
}

// HustlerBeardsCleared reports if the "hustler_beards" edge to the Hustler entity was cleared.
func (m *BodyPartMutation) HustlerBeardsCleared() bool {
	return m.clearedhustler_beards
}

// RemoveHustlerBeardIDs removes the "hustler_beards" edge to the Hustler entity by IDs.
func (m *BodyPartMutation) RemoveHustlerBeardIDs(ids ...string) {
	if m.removedhustler_beards == nil {
		m.removedhustler_beards = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_beards, ids[i])
		m.removedhustler_beards[ids[i]] = struct{}{}
	}
}

// RemovedHustlerBeards returns the removed IDs of the "hustler_beards" edge to the Hustler entity.
func (m *BodyPartMutation) RemovedHustlerBeardsIDs() (ids []string) {
	for id := range m.removedhustler_beards {
		ids = append(ids, id)
	}
	return
}

// HustlerBeardsIDs returns the "hustler_beards" edge IDs in the mutation.
func (m *BodyPartMutation) HustlerBeardsIDs() (ids []string) {
	for id := range m.hustler_beards {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerBeards resets all changes to the "hustler_beards" edge.
func (m *BodyPartMutation) ResetHustlerBeards() {
	m.hustler_beards = nil
	m.clearedhustler_beards = false
	m.removedhustler_beards = nil
}

// Where appends a list predicates to the BodyPartMutation builder.
func (m *BodyPartMutation) Where(ps ...predicate.BodyPart) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BodyPartMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BodyPart).
func (m *BodyPartMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BodyPartMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._type != nil {
		fields = append(fields, bodypart.FieldType)
	}
	if m.sex != nil {
		fields = append(fields, bodypart.FieldSex)
	}
	if m.rle != nil {
		fields = append(fields, bodypart.FieldRle)
	}
	if m.sprite != nil {
		fields = append(fields, bodypart.FieldSprite)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BodyPartMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bodypart.FieldType:
		return m.GetType()
	case bodypart.FieldSex:
		return m.Sex()
	case bodypart.FieldRle:
		return m.Rle()
	case bodypart.FieldSprite:
		return m.Sprite()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BodyPartMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bodypart.FieldType:
		return m.OldType(ctx)
	case bodypart.FieldSex:
		return m.OldSex(ctx)
	case bodypart.FieldRle:
		return m.OldRle(ctx)
	case bodypart.FieldSprite:
		return m.OldSprite(ctx)
	}
	return nil, fmt.Errorf("unknown BodyPart field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BodyPartMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bodypart.FieldType:
		v, ok := value.(bodypart.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case bodypart.FieldSex:
		v, ok := value.(bodypart.Sex)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case bodypart.FieldRle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRle(v)
		return nil
	case bodypart.FieldSprite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSprite(v)
		return nil
	}
	return fmt.Errorf("unknown BodyPart field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BodyPartMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BodyPartMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BodyPartMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BodyPart numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BodyPartMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bodypart.FieldSprite) {
		fields = append(fields, bodypart.FieldSprite)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BodyPartMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BodyPartMutation) ClearField(name string) error {
	switch name {
	case bodypart.FieldSprite:
		m.ClearSprite()
		return nil
	}
	return fmt.Errorf("unknown BodyPart nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BodyPartMutation) ResetField(name string) error {
	switch name {
	case bodypart.FieldType:
		m.ResetType()
		return nil
	case bodypart.FieldSex:
		m.ResetSex()
		return nil
	case bodypart.FieldRle:
		m.ResetRle()
		return nil
	case bodypart.FieldSprite:
		m.ResetSprite()
		return nil
	}
	return fmt.Errorf("unknown BodyPart field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BodyPartMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.hustler_bodies != nil {
		edges = append(edges, bodypart.EdgeHustlerBodies)
	}
	if m.hustler_hairs != nil {
		edges = append(edges, bodypart.EdgeHustlerHairs)
	}
	if m.hustler_beards != nil {
		edges = append(edges, bodypart.EdgeHustlerBeards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BodyPartMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bodypart.EdgeHustlerBodies:
		ids := make([]ent.Value, 0, len(m.hustler_bodies))
		for id := range m.hustler_bodies {
			ids = append(ids, id)
		}
		return ids
	case bodypart.EdgeHustlerHairs:
		ids := make([]ent.Value, 0, len(m.hustler_hairs))
		for id := range m.hustler_hairs {
			ids = append(ids, id)
		}
		return ids
	case bodypart.EdgeHustlerBeards:
		ids := make([]ent.Value, 0, len(m.hustler_beards))
		for id := range m.hustler_beards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BodyPartMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedhustler_bodies != nil {
		edges = append(edges, bodypart.EdgeHustlerBodies)
	}
	if m.removedhustler_hairs != nil {
		edges = append(edges, bodypart.EdgeHustlerHairs)
	}
	if m.removedhustler_beards != nil {
		edges = append(edges, bodypart.EdgeHustlerBeards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BodyPartMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bodypart.EdgeHustlerBodies:
		ids := make([]ent.Value, 0, len(m.removedhustler_bodies))
		for id := range m.removedhustler_bodies {
			ids = append(ids, id)
		}
		return ids
	case bodypart.EdgeHustlerHairs:
		ids := make([]ent.Value, 0, len(m.removedhustler_hairs))
		for id := range m.removedhustler_hairs {
			ids = append(ids, id)
		}
		return ids
	case bodypart.EdgeHustlerBeards:
		ids := make([]ent.Value, 0, len(m.removedhustler_beards))
		for id := range m.removedhustler_beards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BodyPartMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedhustler_bodies {
		edges = append(edges, bodypart.EdgeHustlerBodies)
	}
	if m.clearedhustler_hairs {
		edges = append(edges, bodypart.EdgeHustlerHairs)
	}
	if m.clearedhustler_beards {
		edges = append(edges, bodypart.EdgeHustlerBeards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BodyPartMutation) EdgeCleared(name string) bool {
	switch name {
	case bodypart.EdgeHustlerBodies:
		return m.clearedhustler_bodies
	case bodypart.EdgeHustlerHairs:
		return m.clearedhustler_hairs
	case bodypart.EdgeHustlerBeards:
		return m.clearedhustler_beards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BodyPartMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BodyPart unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BodyPartMutation) ResetEdge(name string) error {
	switch name {
	case bodypart.EdgeHustlerBodies:
		m.ResetHustlerBodies()
		return nil
	case bodypart.EdgeHustlerHairs:
		m.ResetHustlerHairs()
		return nil
	case bodypart.EdgeHustlerBeards:
		m.ResetHustlerBeards()
		return nil
	}
	return fmt.Errorf("unknown BodyPart edge %s", name)
}

// DopeMutation represents an operation that mutates the Dope nodes in the graph.
type DopeMutation struct {
	config
	op               Op
	typ              string
	id               *string
	claimed          *bool
	opened           *bool
	score            *int
	addscore         *int
	rank             *int
	addrank          *int
	_order           *int
	add_order        *int
	clearedFields    map[string]struct{}
	wallet           *string
	clearedwallet    bool
	last_sale        *string
	clearedlast_sale bool
	listings         map[string]struct{}
	removedlistings  map[string]struct{}
	clearedlistings  bool
	items            map[string]struct{}
	removeditems     map[string]struct{}
	cleareditems     bool
	index            *string
	clearedindex     bool
	done             bool
	oldValue         func(context.Context) (*Dope, error)
	predicates       []predicate.Dope
}

var _ ent.Mutation = (*DopeMutation)(nil)

// dopeOption allows management of the mutation configuration using functional options.
type dopeOption func(*DopeMutation)

// newDopeMutation creates new mutation for the Dope entity.
func newDopeMutation(c config, op Op, opts ...dopeOption) *DopeMutation {
	m := &DopeMutation{
		config:        c,
		op:            op,
		typ:           TypeDope,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDopeID sets the ID field of the mutation.
func withDopeID(id string) dopeOption {
	return func(m *DopeMutation) {
		var (
			err   error
			once  sync.Once
			value *Dope
		)
		m.oldValue = func(ctx context.Context) (*Dope, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dope.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDope sets the old Dope of the mutation.
func withDope(node *Dope) dopeOption {
	return func(m *DopeMutation) {
		m.oldValue = func(context.Context) (*Dope, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DopeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DopeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dope entities.
func (m *DopeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DopeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DopeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dope.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClaimed sets the "claimed" field.
func (m *DopeMutation) SetClaimed(b bool) {
	m.claimed = &b
}

// Claimed returns the value of the "claimed" field in the mutation.
func (m *DopeMutation) Claimed() (r bool, exists bool) {
	v := m.claimed
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimed returns the old "claimed" field's value of the Dope entity.
// If the Dope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DopeMutation) OldClaimed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimed: %w", err)
	}
	return oldValue.Claimed, nil
}

// ResetClaimed resets all changes to the "claimed" field.
func (m *DopeMutation) ResetClaimed() {
	m.claimed = nil
}

// SetOpened sets the "opened" field.
func (m *DopeMutation) SetOpened(b bool) {
	m.opened = &b
}

// Opened returns the value of the "opened" field in the mutation.
func (m *DopeMutation) Opened() (r bool, exists bool) {
	v := m.opened
	if v == nil {
		return
	}
	return *v, true
}

// OldOpened returns the old "opened" field's value of the Dope entity.
// If the Dope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DopeMutation) OldOpened(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpened is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpened requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpened: %w", err)
	}
	return oldValue.Opened, nil
}

// ResetOpened resets all changes to the "opened" field.
func (m *DopeMutation) ResetOpened() {
	m.opened = nil
}

// SetScore sets the "score" field.
func (m *DopeMutation) SetScore(i int) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *DopeMutation) Score() (r int, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Dope entity.
// If the Dope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DopeMutation) OldScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *DopeMutation) AddScore(i int) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *DopeMutation) AddedScore() (r int, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *DopeMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[dope.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *DopeMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[dope.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *DopeMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, dope.FieldScore)
}

// SetRank sets the "rank" field.
func (m *DopeMutation) SetRank(i int) {
	m.rank = &i
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *DopeMutation) Rank() (r int, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the Dope entity.
// If the Dope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DopeMutation) OldRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to the "rank" field.
func (m *DopeMutation) AddRank(i int) {
	if m.addrank != nil {
		*m.addrank += i
	} else {
		m.addrank = &i
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *DopeMutation) AddedRank() (r int, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ClearRank clears the value of the "rank" field.
func (m *DopeMutation) ClearRank() {
	m.rank = nil
	m.addrank = nil
	m.clearedFields[dope.FieldRank] = struct{}{}
}

// RankCleared returns if the "rank" field was cleared in this mutation.
func (m *DopeMutation) RankCleared() bool {
	_, ok := m.clearedFields[dope.FieldRank]
	return ok
}

// ResetRank resets all changes to the "rank" field.
func (m *DopeMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
	delete(m.clearedFields, dope.FieldRank)
}

// SetOrder sets the "order" field.
func (m *DopeMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *DopeMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Dope entity.
// If the Dope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DopeMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *DopeMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *DopeMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *DopeMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetWalletID sets the "wallet" edge to the Wallet entity by id.
func (m *DopeMutation) SetWalletID(id string) {
	m.wallet = &id
}

// ClearWallet clears the "wallet" edge to the Wallet entity.
func (m *DopeMutation) ClearWallet() {
	m.clearedwallet = true
}

// WalletCleared reports if the "wallet" edge to the Wallet entity was cleared.
func (m *DopeMutation) WalletCleared() bool {
	return m.clearedwallet
}

// WalletID returns the "wallet" edge ID in the mutation.
func (m *DopeMutation) WalletID() (id string, exists bool) {
	if m.wallet != nil {
		return *m.wallet, true
	}
	return
}

// WalletIDs returns the "wallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WalletID instead. It exists only for internal usage by the builders.
func (m *DopeMutation) WalletIDs() (ids []string) {
	if id := m.wallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWallet resets all changes to the "wallet" edge.
func (m *DopeMutation) ResetWallet() {
	m.wallet = nil
	m.clearedwallet = false
}

// SetLastSaleID sets the "last_sale" edge to the Listing entity by id.
func (m *DopeMutation) SetLastSaleID(id string) {
	m.last_sale = &id
}

// ClearLastSale clears the "last_sale" edge to the Listing entity.
func (m *DopeMutation) ClearLastSale() {
	m.clearedlast_sale = true
}

// LastSaleCleared reports if the "last_sale" edge to the Listing entity was cleared.
func (m *DopeMutation) LastSaleCleared() bool {
	return m.clearedlast_sale
}

// LastSaleID returns the "last_sale" edge ID in the mutation.
func (m *DopeMutation) LastSaleID() (id string, exists bool) {
	if m.last_sale != nil {
		return *m.last_sale, true
	}
	return
}

// LastSaleIDs returns the "last_sale" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LastSaleID instead. It exists only for internal usage by the builders.
func (m *DopeMutation) LastSaleIDs() (ids []string) {
	if id := m.last_sale; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLastSale resets all changes to the "last_sale" edge.
func (m *DopeMutation) ResetLastSale() {
	m.last_sale = nil
	m.clearedlast_sale = false
}

// AddListingIDs adds the "listings" edge to the Listing entity by ids.
func (m *DopeMutation) AddListingIDs(ids ...string) {
	if m.listings == nil {
		m.listings = make(map[string]struct{})
	}
	for i := range ids {
		m.listings[ids[i]] = struct{}{}
	}
}

// ClearListings clears the "listings" edge to the Listing entity.
func (m *DopeMutation) ClearListings() {
	m.clearedlistings = true
}

// ListingsCleared reports if the "listings" edge to the Listing entity was cleared.
func (m *DopeMutation) ListingsCleared() bool {
	return m.clearedlistings
}

// RemoveListingIDs removes the "listings" edge to the Listing entity by IDs.
func (m *DopeMutation) RemoveListingIDs(ids ...string) {
	if m.removedlistings == nil {
		m.removedlistings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.listings, ids[i])
		m.removedlistings[ids[i]] = struct{}{}
	}
}

// RemovedListings returns the removed IDs of the "listings" edge to the Listing entity.
func (m *DopeMutation) RemovedListingsIDs() (ids []string) {
	for id := range m.removedlistings {
		ids = append(ids, id)
	}
	return
}

// ListingsIDs returns the "listings" edge IDs in the mutation.
func (m *DopeMutation) ListingsIDs() (ids []string) {
	for id := range m.listings {
		ids = append(ids, id)
	}
	return
}

// ResetListings resets all changes to the "listings" edge.
func (m *DopeMutation) ResetListings() {
	m.listings = nil
	m.clearedlistings = false
	m.removedlistings = nil
}

// AddItemIDs adds the "items" edge to the Item entity by ids.
func (m *DopeMutation) AddItemIDs(ids ...string) {
	if m.items == nil {
		m.items = make(map[string]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the Item entity.
func (m *DopeMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the Item entity was cleared.
func (m *DopeMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the Item entity by IDs.
func (m *DopeMutation) RemoveItemIDs(ids ...string) {
	if m.removeditems == nil {
		m.removeditems = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the Item entity.
func (m *DopeMutation) RemovedItemsIDs() (ids []string) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *DopeMutation) ItemsIDs() (ids []string) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *DopeMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// SetIndexID sets the "index" edge to the Search entity by id.
func (m *DopeMutation) SetIndexID(id string) {
	m.index = &id
}

// ClearIndex clears the "index" edge to the Search entity.
func (m *DopeMutation) ClearIndex() {
	m.clearedindex = true
}

// IndexCleared reports if the "index" edge to the Search entity was cleared.
func (m *DopeMutation) IndexCleared() bool {
	return m.clearedindex
}

// IndexID returns the "index" edge ID in the mutation.
func (m *DopeMutation) IndexID() (id string, exists bool) {
	if m.index != nil {
		return *m.index, true
	}
	return
}

// IndexIDs returns the "index" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IndexID instead. It exists only for internal usage by the builders.
func (m *DopeMutation) IndexIDs() (ids []string) {
	if id := m.index; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIndex resets all changes to the "index" edge.
func (m *DopeMutation) ResetIndex() {
	m.index = nil
	m.clearedindex = false
}

// Where appends a list predicates to the DopeMutation builder.
func (m *DopeMutation) Where(ps ...predicate.Dope) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DopeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Dope).
func (m *DopeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DopeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.claimed != nil {
		fields = append(fields, dope.FieldClaimed)
	}
	if m.opened != nil {
		fields = append(fields, dope.FieldOpened)
	}
	if m.score != nil {
		fields = append(fields, dope.FieldScore)
	}
	if m.rank != nil {
		fields = append(fields, dope.FieldRank)
	}
	if m._order != nil {
		fields = append(fields, dope.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DopeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dope.FieldClaimed:
		return m.Claimed()
	case dope.FieldOpened:
		return m.Opened()
	case dope.FieldScore:
		return m.Score()
	case dope.FieldRank:
		return m.Rank()
	case dope.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DopeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dope.FieldClaimed:
		return m.OldClaimed(ctx)
	case dope.FieldOpened:
		return m.OldOpened(ctx)
	case dope.FieldScore:
		return m.OldScore(ctx)
	case dope.FieldRank:
		return m.OldRank(ctx)
	case dope.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Dope field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DopeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dope.FieldClaimed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimed(v)
		return nil
	case dope.FieldOpened:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpened(v)
		return nil
	case dope.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case dope.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case dope.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Dope field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DopeMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, dope.FieldScore)
	}
	if m.addrank != nil {
		fields = append(fields, dope.FieldRank)
	}
	if m.add_order != nil {
		fields = append(fields, dope.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DopeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dope.FieldScore:
		return m.AddedScore()
	case dope.FieldRank:
		return m.AddedRank()
	case dope.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DopeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dope.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case dope.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	case dope.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Dope numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DopeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dope.FieldScore) {
		fields = append(fields, dope.FieldScore)
	}
	if m.FieldCleared(dope.FieldRank) {
		fields = append(fields, dope.FieldRank)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DopeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DopeMutation) ClearField(name string) error {
	switch name {
	case dope.FieldScore:
		m.ClearScore()
		return nil
	case dope.FieldRank:
		m.ClearRank()
		return nil
	}
	return fmt.Errorf("unknown Dope nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DopeMutation) ResetField(name string) error {
	switch name {
	case dope.FieldClaimed:
		m.ResetClaimed()
		return nil
	case dope.FieldOpened:
		m.ResetOpened()
		return nil
	case dope.FieldScore:
		m.ResetScore()
		return nil
	case dope.FieldRank:
		m.ResetRank()
		return nil
	case dope.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Dope field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DopeMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.wallet != nil {
		edges = append(edges, dope.EdgeWallet)
	}
	if m.last_sale != nil {
		edges = append(edges, dope.EdgeLastSale)
	}
	if m.listings != nil {
		edges = append(edges, dope.EdgeListings)
	}
	if m.items != nil {
		edges = append(edges, dope.EdgeItems)
	}
	if m.index != nil {
		edges = append(edges, dope.EdgeIndex)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DopeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dope.EdgeWallet:
		if id := m.wallet; id != nil {
			return []ent.Value{*id}
		}
	case dope.EdgeLastSale:
		if id := m.last_sale; id != nil {
			return []ent.Value{*id}
		}
	case dope.EdgeListings:
		ids := make([]ent.Value, 0, len(m.listings))
		for id := range m.listings {
			ids = append(ids, id)
		}
		return ids
	case dope.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case dope.EdgeIndex:
		if id := m.index; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DopeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedlistings != nil {
		edges = append(edges, dope.EdgeListings)
	}
	if m.removeditems != nil {
		edges = append(edges, dope.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DopeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dope.EdgeListings:
		ids := make([]ent.Value, 0, len(m.removedlistings))
		for id := range m.removedlistings {
			ids = append(ids, id)
		}
		return ids
	case dope.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DopeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedwallet {
		edges = append(edges, dope.EdgeWallet)
	}
	if m.clearedlast_sale {
		edges = append(edges, dope.EdgeLastSale)
	}
	if m.clearedlistings {
		edges = append(edges, dope.EdgeListings)
	}
	if m.cleareditems {
		edges = append(edges, dope.EdgeItems)
	}
	if m.clearedindex {
		edges = append(edges, dope.EdgeIndex)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DopeMutation) EdgeCleared(name string) bool {
	switch name {
	case dope.EdgeWallet:
		return m.clearedwallet
	case dope.EdgeLastSale:
		return m.clearedlast_sale
	case dope.EdgeListings:
		return m.clearedlistings
	case dope.EdgeItems:
		return m.cleareditems
	case dope.EdgeIndex:
		return m.clearedindex
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DopeMutation) ClearEdge(name string) error {
	switch name {
	case dope.EdgeWallet:
		m.ClearWallet()
		return nil
	case dope.EdgeLastSale:
		m.ClearLastSale()
		return nil
	case dope.EdgeIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown Dope unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DopeMutation) ResetEdge(name string) error {
	switch name {
	case dope.EdgeWallet:
		m.ResetWallet()
		return nil
	case dope.EdgeLastSale:
		m.ResetLastSale()
		return nil
	case dope.EdgeListings:
		m.ResetListings()
		return nil
	case dope.EdgeItems:
		m.ResetItems()
		return nil
	case dope.EdgeIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown Dope edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op            Op
	typ           string
	id            *string
	address       *common.Address
	index         *uint64
	addindex      *int64
	hash          *common.Hash
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Event, error)
	predicates    []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id string) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAddress sets the "address" field.
func (m *EventMutation) SetAddress(c common.Address) {
	m.address = &c
}

// Address returns the value of the "address" field in the mutation.
func (m *EventMutation) Address() (r common.Address, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAddress(ctx context.Context) (v common.Address, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *EventMutation) ResetAddress() {
	m.address = nil
}

// SetIndex sets the "index" field.
func (m *EventMutation) SetIndex(u uint64) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *EventMutation) Index() (r uint64, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIndex(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *EventMutation) AddIndex(u int64) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *EventMutation) AddedIndex() (r int64, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *EventMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetHash sets the "hash" field.
func (m *EventMutation) SetHash(c common.Hash) {
	m.hash = &c
}

// Hash returns the value of the "hash" field in the mutation.
func (m *EventMutation) Hash() (r common.Hash, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldHash(ctx context.Context) (v common.Hash, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *EventMutation) ResetHash() {
	m.hash = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.address != nil {
		fields = append(fields, event.FieldAddress)
	}
	if m.index != nil {
		fields = append(fields, event.FieldIndex)
	}
	if m.hash != nil {
		fields = append(fields, event.FieldHash)
	}
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldAddress:
		return m.Address()
	case event.FieldIndex:
		return m.Index()
	case event.FieldHash:
		return m.Hash()
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldAddress:
		return m.OldAddress(ctx)
	case event.FieldIndex:
		return m.OldIndex(ctx)
	case event.FieldHash:
		return m.OldHash(ctx)
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldAddress:
		v, ok := value.(common.Address)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case event.FieldIndex:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case event.FieldHash:
		v, ok := value.(common.Hash)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, event.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldAddress:
		m.ResetAddress()
		return nil
	case event.FieldIndex:
		m.ResetIndex()
		return nil
	case event.FieldHash:
		m.ResetHash()
		return nil
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Event edge %s", name)
}

// GameHustlerMutation represents an operation that mutates the GameHustler nodes in the graph.
type GameHustlerMutation struct {
	config
	op               Op
	typ              string
	id               *string
	last_position    *schema.Position
	created_at       *time.Time
	clearedFields    map[string]struct{}
	relations        map[string]struct{}
	removedrelations map[string]struct{}
	clearedrelations bool
	items            map[string]struct{}
	removeditems     map[string]struct{}
	cleareditems     bool
	quests           map[string]struct{}
	removedquests    map[string]struct{}
	clearedquests    bool
	done             bool
	oldValue         func(context.Context) (*GameHustler, error)
	predicates       []predicate.GameHustler
}

var _ ent.Mutation = (*GameHustlerMutation)(nil)

// gamehustlerOption allows management of the mutation configuration using functional options.
type gamehustlerOption func(*GameHustlerMutation)

// newGameHustlerMutation creates new mutation for the GameHustler entity.
func newGameHustlerMutation(c config, op Op, opts ...gamehustlerOption) *GameHustlerMutation {
	m := &GameHustlerMutation{
		config:        c,
		op:            op,
		typ:           TypeGameHustler,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameHustlerID sets the ID field of the mutation.
func withGameHustlerID(id string) gamehustlerOption {
	return func(m *GameHustlerMutation) {
		var (
			err   error
			once  sync.Once
			value *GameHustler
		)
		m.oldValue = func(ctx context.Context) (*GameHustler, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GameHustler.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGameHustler sets the old GameHustler of the mutation.
func withGameHustler(node *GameHustler) gamehustlerOption {
	return func(m *GameHustlerMutation) {
		m.oldValue = func(context.Context) (*GameHustler, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameHustlerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameHustlerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GameHustler entities.
func (m *GameHustlerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameHustlerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameHustlerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GameHustler.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastPosition sets the "last_position" field.
func (m *GameHustlerMutation) SetLastPosition(s schema.Position) {
	m.last_position = &s
}

// LastPosition returns the value of the "last_position" field in the mutation.
func (m *GameHustlerMutation) LastPosition() (r schema.Position, exists bool) {
	v := m.last_position
	if v == nil {
		return
	}
	return *v, true
}

// OldLastPosition returns the old "last_position" field's value of the GameHustler entity.
// If the GameHustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameHustlerMutation) OldLastPosition(ctx context.Context) (v schema.Position, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastPosition: %w", err)
	}
	return oldValue.LastPosition, nil
}

// ResetLastPosition resets all changes to the "last_position" field.
func (m *GameHustlerMutation) ResetLastPosition() {
	m.last_position = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GameHustlerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GameHustlerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GameHustler entity.
// If the GameHustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameHustlerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GameHustlerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddRelationIDs adds the "relations" edge to the GameHustlerRelation entity by ids.
func (m *GameHustlerMutation) AddRelationIDs(ids ...string) {
	if m.relations == nil {
		m.relations = make(map[string]struct{})
	}
	for i := range ids {
		m.relations[ids[i]] = struct{}{}
	}
}

// ClearRelations clears the "relations" edge to the GameHustlerRelation entity.
func (m *GameHustlerMutation) ClearRelations() {
	m.clearedrelations = true
}

// RelationsCleared reports if the "relations" edge to the GameHustlerRelation entity was cleared.
func (m *GameHustlerMutation) RelationsCleared() bool {
	return m.clearedrelations
}

// RemoveRelationIDs removes the "relations" edge to the GameHustlerRelation entity by IDs.
func (m *GameHustlerMutation) RemoveRelationIDs(ids ...string) {
	if m.removedrelations == nil {
		m.removedrelations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.relations, ids[i])
		m.removedrelations[ids[i]] = struct{}{}
	}
}

// RemovedRelations returns the removed IDs of the "relations" edge to the GameHustlerRelation entity.
func (m *GameHustlerMutation) RemovedRelationsIDs() (ids []string) {
	for id := range m.removedrelations {
		ids = append(ids, id)
	}
	return
}

// RelationsIDs returns the "relations" edge IDs in the mutation.
func (m *GameHustlerMutation) RelationsIDs() (ids []string) {
	for id := range m.relations {
		ids = append(ids, id)
	}
	return
}

// ResetRelations resets all changes to the "relations" edge.
func (m *GameHustlerMutation) ResetRelations() {
	m.relations = nil
	m.clearedrelations = false
	m.removedrelations = nil
}

// AddItemIDs adds the "items" edge to the GameHustlerItem entity by ids.
func (m *GameHustlerMutation) AddItemIDs(ids ...string) {
	if m.items == nil {
		m.items = make(map[string]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the GameHustlerItem entity.
func (m *GameHustlerMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the GameHustlerItem entity was cleared.
func (m *GameHustlerMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the GameHustlerItem entity by IDs.
func (m *GameHustlerMutation) RemoveItemIDs(ids ...string) {
	if m.removeditems == nil {
		m.removeditems = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the GameHustlerItem entity.
func (m *GameHustlerMutation) RemovedItemsIDs() (ids []string) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *GameHustlerMutation) ItemsIDs() (ids []string) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *GameHustlerMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddQuestIDs adds the "quests" edge to the GameHustlerQuest entity by ids.
func (m *GameHustlerMutation) AddQuestIDs(ids ...string) {
	if m.quests == nil {
		m.quests = make(map[string]struct{})
	}
	for i := range ids {
		m.quests[ids[i]] = struct{}{}
	}
}

// ClearQuests clears the "quests" edge to the GameHustlerQuest entity.
func (m *GameHustlerMutation) ClearQuests() {
	m.clearedquests = true
}

// QuestsCleared reports if the "quests" edge to the GameHustlerQuest entity was cleared.
func (m *GameHustlerMutation) QuestsCleared() bool {
	return m.clearedquests
}

// RemoveQuestIDs removes the "quests" edge to the GameHustlerQuest entity by IDs.
func (m *GameHustlerMutation) RemoveQuestIDs(ids ...string) {
	if m.removedquests == nil {
		m.removedquests = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.quests, ids[i])
		m.removedquests[ids[i]] = struct{}{}
	}
}

// RemovedQuests returns the removed IDs of the "quests" edge to the GameHustlerQuest entity.
func (m *GameHustlerMutation) RemovedQuestsIDs() (ids []string) {
	for id := range m.removedquests {
		ids = append(ids, id)
	}
	return
}

// QuestsIDs returns the "quests" edge IDs in the mutation.
func (m *GameHustlerMutation) QuestsIDs() (ids []string) {
	for id := range m.quests {
		ids = append(ids, id)
	}
	return
}

// ResetQuests resets all changes to the "quests" edge.
func (m *GameHustlerMutation) ResetQuests() {
	m.quests = nil
	m.clearedquests = false
	m.removedquests = nil
}

// Where appends a list predicates to the GameHustlerMutation builder.
func (m *GameHustlerMutation) Where(ps ...predicate.GameHustler) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GameHustlerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GameHustler).
func (m *GameHustlerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameHustlerMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.last_position != nil {
		fields = append(fields, gamehustler.FieldLastPosition)
	}
	if m.created_at != nil {
		fields = append(fields, gamehustler.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameHustlerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gamehustler.FieldLastPosition:
		return m.LastPosition()
	case gamehustler.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameHustlerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gamehustler.FieldLastPosition:
		return m.OldLastPosition(ctx)
	case gamehustler.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GameHustler field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameHustlerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gamehustler.FieldLastPosition:
		v, ok := value.(schema.Position)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastPosition(v)
		return nil
	case gamehustler.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GameHustler field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameHustlerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameHustlerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameHustlerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GameHustler numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameHustlerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameHustlerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameHustlerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GameHustler nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameHustlerMutation) ResetField(name string) error {
	switch name {
	case gamehustler.FieldLastPosition:
		m.ResetLastPosition()
		return nil
	case gamehustler.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown GameHustler field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameHustlerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.relations != nil {
		edges = append(edges, gamehustler.EdgeRelations)
	}
	if m.items != nil {
		edges = append(edges, gamehustler.EdgeItems)
	}
	if m.quests != nil {
		edges = append(edges, gamehustler.EdgeQuests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameHustlerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gamehustler.EdgeRelations:
		ids := make([]ent.Value, 0, len(m.relations))
		for id := range m.relations {
			ids = append(ids, id)
		}
		return ids
	case gamehustler.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case gamehustler.EdgeQuests:
		ids := make([]ent.Value, 0, len(m.quests))
		for id := range m.quests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameHustlerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrelations != nil {
		edges = append(edges, gamehustler.EdgeRelations)
	}
	if m.removeditems != nil {
		edges = append(edges, gamehustler.EdgeItems)
	}
	if m.removedquests != nil {
		edges = append(edges, gamehustler.EdgeQuests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameHustlerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gamehustler.EdgeRelations:
		ids := make([]ent.Value, 0, len(m.removedrelations))
		for id := range m.removedrelations {
			ids = append(ids, id)
		}
		return ids
	case gamehustler.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case gamehustler.EdgeQuests:
		ids := make([]ent.Value, 0, len(m.removedquests))
		for id := range m.removedquests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameHustlerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrelations {
		edges = append(edges, gamehustler.EdgeRelations)
	}
	if m.cleareditems {
		edges = append(edges, gamehustler.EdgeItems)
	}
	if m.clearedquests {
		edges = append(edges, gamehustler.EdgeQuests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameHustlerMutation) EdgeCleared(name string) bool {
	switch name {
	case gamehustler.EdgeRelations:
		return m.clearedrelations
	case gamehustler.EdgeItems:
		return m.cleareditems
	case gamehustler.EdgeQuests:
		return m.clearedquests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameHustlerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GameHustler unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameHustlerMutation) ResetEdge(name string) error {
	switch name {
	case gamehustler.EdgeRelations:
		m.ResetRelations()
		return nil
	case gamehustler.EdgeItems:
		m.ResetItems()
		return nil
	case gamehustler.EdgeQuests:
		m.ResetQuests()
		return nil
	}
	return fmt.Errorf("unknown GameHustler edge %s", name)
}

// GameHustlerItemMutation represents an operation that mutates the GameHustlerItem nodes in the graph.
type GameHustlerItemMutation struct {
	config
	op             Op
	typ            string
	id             *string
	item           *string
	clearedFields  map[string]struct{}
	hustler        *string
	clearedhustler bool
	done           bool
	oldValue       func(context.Context) (*GameHustlerItem, error)
	predicates     []predicate.GameHustlerItem
}

var _ ent.Mutation = (*GameHustlerItemMutation)(nil)

// gamehustleritemOption allows management of the mutation configuration using functional options.
type gamehustleritemOption func(*GameHustlerItemMutation)

// newGameHustlerItemMutation creates new mutation for the GameHustlerItem entity.
func newGameHustlerItemMutation(c config, op Op, opts ...gamehustleritemOption) *GameHustlerItemMutation {
	m := &GameHustlerItemMutation{
		config:        c,
		op:            op,
		typ:           TypeGameHustlerItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameHustlerItemID sets the ID field of the mutation.
func withGameHustlerItemID(id string) gamehustleritemOption {
	return func(m *GameHustlerItemMutation) {
		var (
			err   error
			once  sync.Once
			value *GameHustlerItem
		)
		m.oldValue = func(ctx context.Context) (*GameHustlerItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GameHustlerItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGameHustlerItem sets the old GameHustlerItem of the mutation.
func withGameHustlerItem(node *GameHustlerItem) gamehustleritemOption {
	return func(m *GameHustlerItemMutation) {
		m.oldValue = func(context.Context) (*GameHustlerItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameHustlerItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameHustlerItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GameHustlerItem entities.
func (m *GameHustlerItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameHustlerItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameHustlerItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GameHustlerItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetItem sets the "item" field.
func (m *GameHustlerItemMutation) SetItem(s string) {
	m.item = &s
}

// Item returns the value of the "item" field in the mutation.
func (m *GameHustlerItemMutation) Item() (r string, exists bool) {
	v := m.item
	if v == nil {
		return
	}
	return *v, true
}

// OldItem returns the old "item" field's value of the GameHustlerItem entity.
// If the GameHustlerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameHustlerItemMutation) OldItem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItem: %w", err)
	}
	return oldValue.Item, nil
}

// ResetItem resets all changes to the "item" field.
func (m *GameHustlerItemMutation) ResetItem() {
	m.item = nil
}

// SetHustlerID sets the "hustler" edge to the GameHustler entity by id.
func (m *GameHustlerItemMutation) SetHustlerID(id string) {
	m.hustler = &id
}

// ClearHustler clears the "hustler" edge to the GameHustler entity.
func (m *GameHustlerItemMutation) ClearHustler() {
	m.clearedhustler = true
}

// HustlerCleared reports if the "hustler" edge to the GameHustler entity was cleared.
func (m *GameHustlerItemMutation) HustlerCleared() bool {
	return m.clearedhustler
}

// HustlerID returns the "hustler" edge ID in the mutation.
func (m *GameHustlerItemMutation) HustlerID() (id string, exists bool) {
	if m.hustler != nil {
		return *m.hustler, true
	}
	return
}

// HustlerIDs returns the "hustler" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HustlerID instead. It exists only for internal usage by the builders.
func (m *GameHustlerItemMutation) HustlerIDs() (ids []string) {
	if id := m.hustler; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHustler resets all changes to the "hustler" edge.
func (m *GameHustlerItemMutation) ResetHustler() {
	m.hustler = nil
	m.clearedhustler = false
}

// Where appends a list predicates to the GameHustlerItemMutation builder.
func (m *GameHustlerItemMutation) Where(ps ...predicate.GameHustlerItem) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GameHustlerItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GameHustlerItem).
func (m *GameHustlerItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameHustlerItemMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.item != nil {
		fields = append(fields, gamehustleritem.FieldItem)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameHustlerItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gamehustleritem.FieldItem:
		return m.Item()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameHustlerItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gamehustleritem.FieldItem:
		return m.OldItem(ctx)
	}
	return nil, fmt.Errorf("unknown GameHustlerItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameHustlerItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gamehustleritem.FieldItem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItem(v)
		return nil
	}
	return fmt.Errorf("unknown GameHustlerItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameHustlerItemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameHustlerItemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameHustlerItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GameHustlerItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameHustlerItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameHustlerItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameHustlerItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GameHustlerItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameHustlerItemMutation) ResetField(name string) error {
	switch name {
	case gamehustleritem.FieldItem:
		m.ResetItem()
		return nil
	}
	return fmt.Errorf("unknown GameHustlerItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameHustlerItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hustler != nil {
		edges = append(edges, gamehustleritem.EdgeHustler)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameHustlerItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gamehustleritem.EdgeHustler:
		if id := m.hustler; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameHustlerItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameHustlerItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameHustlerItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhustler {
		edges = append(edges, gamehustleritem.EdgeHustler)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameHustlerItemMutation) EdgeCleared(name string) bool {
	switch name {
	case gamehustleritem.EdgeHustler:
		return m.clearedhustler
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameHustlerItemMutation) ClearEdge(name string) error {
	switch name {
	case gamehustleritem.EdgeHustler:
		m.ClearHustler()
		return nil
	}
	return fmt.Errorf("unknown GameHustlerItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameHustlerItemMutation) ResetEdge(name string) error {
	switch name {
	case gamehustleritem.EdgeHustler:
		m.ResetHustler()
		return nil
	}
	return fmt.Errorf("unknown GameHustlerItem edge %s", name)
}

// GameHustlerQuestMutation represents an operation that mutates the GameHustlerQuest nodes in the graph.
type GameHustlerQuestMutation struct {
	config
	op             Op
	typ            string
	id             *string
	quest          *string
	completed      *bool
	clearedFields  map[string]struct{}
	hustler        *string
	clearedhustler bool
	done           bool
	oldValue       func(context.Context) (*GameHustlerQuest, error)
	predicates     []predicate.GameHustlerQuest
}

var _ ent.Mutation = (*GameHustlerQuestMutation)(nil)

// gamehustlerquestOption allows management of the mutation configuration using functional options.
type gamehustlerquestOption func(*GameHustlerQuestMutation)

// newGameHustlerQuestMutation creates new mutation for the GameHustlerQuest entity.
func newGameHustlerQuestMutation(c config, op Op, opts ...gamehustlerquestOption) *GameHustlerQuestMutation {
	m := &GameHustlerQuestMutation{
		config:        c,
		op:            op,
		typ:           TypeGameHustlerQuest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameHustlerQuestID sets the ID field of the mutation.
func withGameHustlerQuestID(id string) gamehustlerquestOption {
	return func(m *GameHustlerQuestMutation) {
		var (
			err   error
			once  sync.Once
			value *GameHustlerQuest
		)
		m.oldValue = func(ctx context.Context) (*GameHustlerQuest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GameHustlerQuest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGameHustlerQuest sets the old GameHustlerQuest of the mutation.
func withGameHustlerQuest(node *GameHustlerQuest) gamehustlerquestOption {
	return func(m *GameHustlerQuestMutation) {
		m.oldValue = func(context.Context) (*GameHustlerQuest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameHustlerQuestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameHustlerQuestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GameHustlerQuest entities.
func (m *GameHustlerQuestMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameHustlerQuestMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameHustlerQuestMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GameHustlerQuest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuest sets the "quest" field.
func (m *GameHustlerQuestMutation) SetQuest(s string) {
	m.quest = &s
}

// Quest returns the value of the "quest" field in the mutation.
func (m *GameHustlerQuestMutation) Quest() (r string, exists bool) {
	v := m.quest
	if v == nil {
		return
	}
	return *v, true
}

// OldQuest returns the old "quest" field's value of the GameHustlerQuest entity.
// If the GameHustlerQuest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameHustlerQuestMutation) OldQuest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuest: %w", err)
	}
	return oldValue.Quest, nil
}

// ResetQuest resets all changes to the "quest" field.
func (m *GameHustlerQuestMutation) ResetQuest() {
	m.quest = nil
}

// SetCompleted sets the "completed" field.
func (m *GameHustlerQuestMutation) SetCompleted(b bool) {
	m.completed = &b
}

// Completed returns the value of the "completed" field in the mutation.
func (m *GameHustlerQuestMutation) Completed() (r bool, exists bool) {
	v := m.completed
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleted returns the old "completed" field's value of the GameHustlerQuest entity.
// If the GameHustlerQuest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameHustlerQuestMutation) OldCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleted: %w", err)
	}
	return oldValue.Completed, nil
}

// ResetCompleted resets all changes to the "completed" field.
func (m *GameHustlerQuestMutation) ResetCompleted() {
	m.completed = nil
}

// SetHustlerID sets the "hustler" edge to the GameHustler entity by id.
func (m *GameHustlerQuestMutation) SetHustlerID(id string) {
	m.hustler = &id
}

// ClearHustler clears the "hustler" edge to the GameHustler entity.
func (m *GameHustlerQuestMutation) ClearHustler() {
	m.clearedhustler = true
}

// HustlerCleared reports if the "hustler" edge to the GameHustler entity was cleared.
func (m *GameHustlerQuestMutation) HustlerCleared() bool {
	return m.clearedhustler
}

// HustlerID returns the "hustler" edge ID in the mutation.
func (m *GameHustlerQuestMutation) HustlerID() (id string, exists bool) {
	if m.hustler != nil {
		return *m.hustler, true
	}
	return
}

// HustlerIDs returns the "hustler" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HustlerID instead. It exists only for internal usage by the builders.
func (m *GameHustlerQuestMutation) HustlerIDs() (ids []string) {
	if id := m.hustler; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHustler resets all changes to the "hustler" edge.
func (m *GameHustlerQuestMutation) ResetHustler() {
	m.hustler = nil
	m.clearedhustler = false
}

// Where appends a list predicates to the GameHustlerQuestMutation builder.
func (m *GameHustlerQuestMutation) Where(ps ...predicate.GameHustlerQuest) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GameHustlerQuestMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GameHustlerQuest).
func (m *GameHustlerQuestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameHustlerQuestMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.quest != nil {
		fields = append(fields, gamehustlerquest.FieldQuest)
	}
	if m.completed != nil {
		fields = append(fields, gamehustlerquest.FieldCompleted)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameHustlerQuestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gamehustlerquest.FieldQuest:
		return m.Quest()
	case gamehustlerquest.FieldCompleted:
		return m.Completed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameHustlerQuestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gamehustlerquest.FieldQuest:
		return m.OldQuest(ctx)
	case gamehustlerquest.FieldCompleted:
		return m.OldCompleted(ctx)
	}
	return nil, fmt.Errorf("unknown GameHustlerQuest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameHustlerQuestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gamehustlerquest.FieldQuest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuest(v)
		return nil
	case gamehustlerquest.FieldCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleted(v)
		return nil
	}
	return fmt.Errorf("unknown GameHustlerQuest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameHustlerQuestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameHustlerQuestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameHustlerQuestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GameHustlerQuest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameHustlerQuestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameHustlerQuestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameHustlerQuestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GameHustlerQuest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameHustlerQuestMutation) ResetField(name string) error {
	switch name {
	case gamehustlerquest.FieldQuest:
		m.ResetQuest()
		return nil
	case gamehustlerquest.FieldCompleted:
		m.ResetCompleted()
		return nil
	}
	return fmt.Errorf("unknown GameHustlerQuest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameHustlerQuestMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hustler != nil {
		edges = append(edges, gamehustlerquest.EdgeHustler)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameHustlerQuestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gamehustlerquest.EdgeHustler:
		if id := m.hustler; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameHustlerQuestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameHustlerQuestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameHustlerQuestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhustler {
		edges = append(edges, gamehustlerquest.EdgeHustler)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameHustlerQuestMutation) EdgeCleared(name string) bool {
	switch name {
	case gamehustlerquest.EdgeHustler:
		return m.clearedhustler
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameHustlerQuestMutation) ClearEdge(name string) error {
	switch name {
	case gamehustlerquest.EdgeHustler:
		m.ClearHustler()
		return nil
	}
	return fmt.Errorf("unknown GameHustlerQuest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameHustlerQuestMutation) ResetEdge(name string) error {
	switch name {
	case gamehustlerquest.EdgeHustler:
		m.ResetHustler()
		return nil
	}
	return fmt.Errorf("unknown GameHustlerQuest edge %s", name)
}

// GameHustlerRelationMutation represents an operation that mutates the GameHustlerRelation nodes in the graph.
type GameHustlerRelationMutation struct {
	config
	op             Op
	typ            string
	id             *string
	citizen        *string
	conversation   *string
	text           *uint
	addtext        *int
	clearedFields  map[string]struct{}
	hustler        *string
	clearedhustler bool
	done           bool
	oldValue       func(context.Context) (*GameHustlerRelation, error)
	predicates     []predicate.GameHustlerRelation
}

var _ ent.Mutation = (*GameHustlerRelationMutation)(nil)

// gamehustlerrelationOption allows management of the mutation configuration using functional options.
type gamehustlerrelationOption func(*GameHustlerRelationMutation)

// newGameHustlerRelationMutation creates new mutation for the GameHustlerRelation entity.
func newGameHustlerRelationMutation(c config, op Op, opts ...gamehustlerrelationOption) *GameHustlerRelationMutation {
	m := &GameHustlerRelationMutation{
		config:        c,
		op:            op,
		typ:           TypeGameHustlerRelation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameHustlerRelationID sets the ID field of the mutation.
func withGameHustlerRelationID(id string) gamehustlerrelationOption {
	return func(m *GameHustlerRelationMutation) {
		var (
			err   error
			once  sync.Once
			value *GameHustlerRelation
		)
		m.oldValue = func(ctx context.Context) (*GameHustlerRelation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GameHustlerRelation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGameHustlerRelation sets the old GameHustlerRelation of the mutation.
func withGameHustlerRelation(node *GameHustlerRelation) gamehustlerrelationOption {
	return func(m *GameHustlerRelationMutation) {
		m.oldValue = func(context.Context) (*GameHustlerRelation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameHustlerRelationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameHustlerRelationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GameHustlerRelation entities.
func (m *GameHustlerRelationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameHustlerRelationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameHustlerRelationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GameHustlerRelation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCitizen sets the "citizen" field.
func (m *GameHustlerRelationMutation) SetCitizen(s string) {
	m.citizen = &s
}

// Citizen returns the value of the "citizen" field in the mutation.
func (m *GameHustlerRelationMutation) Citizen() (r string, exists bool) {
	v := m.citizen
	if v == nil {
		return
	}
	return *v, true
}

// OldCitizen returns the old "citizen" field's value of the GameHustlerRelation entity.
// If the GameHustlerRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameHustlerRelationMutation) OldCitizen(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCitizen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCitizen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCitizen: %w", err)
	}
	return oldValue.Citizen, nil
}

// ResetCitizen resets all changes to the "citizen" field.
func (m *GameHustlerRelationMutation) ResetCitizen() {
	m.citizen = nil
}

// SetConversation sets the "conversation" field.
func (m *GameHustlerRelationMutation) SetConversation(s string) {
	m.conversation = &s
}

// Conversation returns the value of the "conversation" field in the mutation.
func (m *GameHustlerRelationMutation) Conversation() (r string, exists bool) {
	v := m.conversation
	if v == nil {
		return
	}
	return *v, true
}

// OldConversation returns the old "conversation" field's value of the GameHustlerRelation entity.
// If the GameHustlerRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameHustlerRelationMutation) OldConversation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversation: %w", err)
	}
	return oldValue.Conversation, nil
}

// ResetConversation resets all changes to the "conversation" field.
func (m *GameHustlerRelationMutation) ResetConversation() {
	m.conversation = nil
}

// SetText sets the "text" field.
func (m *GameHustlerRelationMutation) SetText(u uint) {
	m.text = &u
	m.addtext = nil
}

// Text returns the value of the "text" field in the mutation.
func (m *GameHustlerRelationMutation) Text() (r uint, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the GameHustlerRelation entity.
// If the GameHustlerRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameHustlerRelationMutation) OldText(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// AddText adds u to the "text" field.
func (m *GameHustlerRelationMutation) AddText(u int) {
	if m.addtext != nil {
		*m.addtext += u
	} else {
		m.addtext = &u
	}
}

// AddedText returns the value that was added to the "text" field in this mutation.
func (m *GameHustlerRelationMutation) AddedText() (r int, exists bool) {
	v := m.addtext
	if v == nil {
		return
	}
	return *v, true
}

// ResetText resets all changes to the "text" field.
func (m *GameHustlerRelationMutation) ResetText() {
	m.text = nil
	m.addtext = nil
}

// SetHustlerID sets the "hustler" edge to the GameHustler entity by id.
func (m *GameHustlerRelationMutation) SetHustlerID(id string) {
	m.hustler = &id
}

// ClearHustler clears the "hustler" edge to the GameHustler entity.
func (m *GameHustlerRelationMutation) ClearHustler() {
	m.clearedhustler = true
}

// HustlerCleared reports if the "hustler" edge to the GameHustler entity was cleared.
func (m *GameHustlerRelationMutation) HustlerCleared() bool {
	return m.clearedhustler
}

// HustlerID returns the "hustler" edge ID in the mutation.
func (m *GameHustlerRelationMutation) HustlerID() (id string, exists bool) {
	if m.hustler != nil {
		return *m.hustler, true
	}
	return
}

// HustlerIDs returns the "hustler" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HustlerID instead. It exists only for internal usage by the builders.
func (m *GameHustlerRelationMutation) HustlerIDs() (ids []string) {
	if id := m.hustler; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHustler resets all changes to the "hustler" edge.
func (m *GameHustlerRelationMutation) ResetHustler() {
	m.hustler = nil
	m.clearedhustler = false
}

// Where appends a list predicates to the GameHustlerRelationMutation builder.
func (m *GameHustlerRelationMutation) Where(ps ...predicate.GameHustlerRelation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GameHustlerRelationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GameHustlerRelation).
func (m *GameHustlerRelationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameHustlerRelationMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.citizen != nil {
		fields = append(fields, gamehustlerrelation.FieldCitizen)
	}
	if m.conversation != nil {
		fields = append(fields, gamehustlerrelation.FieldConversation)
	}
	if m.text != nil {
		fields = append(fields, gamehustlerrelation.FieldText)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameHustlerRelationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gamehustlerrelation.FieldCitizen:
		return m.Citizen()
	case gamehustlerrelation.FieldConversation:
		return m.Conversation()
	case gamehustlerrelation.FieldText:
		return m.Text()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameHustlerRelationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gamehustlerrelation.FieldCitizen:
		return m.OldCitizen(ctx)
	case gamehustlerrelation.FieldConversation:
		return m.OldConversation(ctx)
	case gamehustlerrelation.FieldText:
		return m.OldText(ctx)
	}
	return nil, fmt.Errorf("unknown GameHustlerRelation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameHustlerRelationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gamehustlerrelation.FieldCitizen:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCitizen(v)
		return nil
	case gamehustlerrelation.FieldConversation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversation(v)
		return nil
	case gamehustlerrelation.FieldText:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	}
	return fmt.Errorf("unknown GameHustlerRelation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameHustlerRelationMutation) AddedFields() []string {
	var fields []string
	if m.addtext != nil {
		fields = append(fields, gamehustlerrelation.FieldText)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameHustlerRelationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gamehustlerrelation.FieldText:
		return m.AddedText()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameHustlerRelationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gamehustlerrelation.FieldText:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddText(v)
		return nil
	}
	return fmt.Errorf("unknown GameHustlerRelation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameHustlerRelationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameHustlerRelationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameHustlerRelationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GameHustlerRelation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameHustlerRelationMutation) ResetField(name string) error {
	switch name {
	case gamehustlerrelation.FieldCitizen:
		m.ResetCitizen()
		return nil
	case gamehustlerrelation.FieldConversation:
		m.ResetConversation()
		return nil
	case gamehustlerrelation.FieldText:
		m.ResetText()
		return nil
	}
	return fmt.Errorf("unknown GameHustlerRelation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameHustlerRelationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hustler != nil {
		edges = append(edges, gamehustlerrelation.EdgeHustler)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameHustlerRelationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gamehustlerrelation.EdgeHustler:
		if id := m.hustler; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameHustlerRelationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameHustlerRelationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameHustlerRelationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhustler {
		edges = append(edges, gamehustlerrelation.EdgeHustler)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameHustlerRelationMutation) EdgeCleared(name string) bool {
	switch name {
	case gamehustlerrelation.EdgeHustler:
		return m.clearedhustler
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameHustlerRelationMutation) ClearEdge(name string) error {
	switch name {
	case gamehustlerrelation.EdgeHustler:
		m.ClearHustler()
		return nil
	}
	return fmt.Errorf("unknown GameHustlerRelation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameHustlerRelationMutation) ResetEdge(name string) error {
	switch name {
	case gamehustlerrelation.EdgeHustler:
		m.ResetHustler()
		return nil
	}
	return fmt.Errorf("unknown GameHustlerRelation edge %s", name)
}

// HustlerMutation represents an operation that mutates the Hustler nodes in the graph.
type HustlerMutation struct {
	config
	op               Op
	typ              string
	id               *string
	_type            *hustler.Type
	name             *string
	title            *string
	color            *string
	background       *string
	age              *uint64
	addage           *int64
	sex              *hustler.Sex
	viewbox          *[]int
	_order           *[]int
	svg              *string
	created_at       *time.Time
	clearedFields    map[string]struct{}
	wallet           *string
	clearedwallet    bool
	weapon           *string
	clearedweapon    bool
	clothes          *string
	clearedclothes   bool
	vehicle          *string
	clearedvehicle   bool
	waist            *string
	clearedwaist     bool
	foot             *string
	clearedfoot      bool
	hand             *string
	clearedhand      bool
	drug             *string
	cleareddrug      bool
	neck             *string
	clearedneck      bool
	ring             *string
	clearedring      bool
	accessory        *string
	clearedaccessory bool
	body             *string
	clearedbody      bool
	hair             *string
	clearedhair      bool
	beard            *string
	clearedbeard     bool
	index            *string
	clearedindex     bool
	done             bool
	oldValue         func(context.Context) (*Hustler, error)
	predicates       []predicate.Hustler
}

var _ ent.Mutation = (*HustlerMutation)(nil)

// hustlerOption allows management of the mutation configuration using functional options.
type hustlerOption func(*HustlerMutation)

// newHustlerMutation creates new mutation for the Hustler entity.
func newHustlerMutation(c config, op Op, opts ...hustlerOption) *HustlerMutation {
	m := &HustlerMutation{
		config:        c,
		op:            op,
		typ:           TypeHustler,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHustlerID sets the ID field of the mutation.
func withHustlerID(id string) hustlerOption {
	return func(m *HustlerMutation) {
		var (
			err   error
			once  sync.Once
			value *Hustler
		)
		m.oldValue = func(ctx context.Context) (*Hustler, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hustler.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHustler sets the old Hustler of the mutation.
func withHustler(node *Hustler) hustlerOption {
	return func(m *HustlerMutation) {
		m.oldValue = func(context.Context) (*Hustler, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HustlerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HustlerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Hustler entities.
func (m *HustlerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HustlerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HustlerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Hustler.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *HustlerMutation) SetType(h hustler.Type) {
	m._type = &h
}

// GetType returns the value of the "type" field in the mutation.
func (m *HustlerMutation) GetType() (r hustler.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldType(ctx context.Context) (v hustler.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *HustlerMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *HustlerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HustlerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *HustlerMutation) ClearName() {
	m.name = nil
	m.clearedFields[hustler.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *HustlerMutation) NameCleared() bool {
	_, ok := m.clearedFields[hustler.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *HustlerMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, hustler.FieldName)
}

// SetTitle sets the "title" field.
func (m *HustlerMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *HustlerMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *HustlerMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[hustler.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *HustlerMutation) TitleCleared() bool {
	_, ok := m.clearedFields[hustler.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *HustlerMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, hustler.FieldTitle)
}

// SetColor sets the "color" field.
func (m *HustlerMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *HustlerMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *HustlerMutation) ClearColor() {
	m.color = nil
	m.clearedFields[hustler.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *HustlerMutation) ColorCleared() bool {
	_, ok := m.clearedFields[hustler.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *HustlerMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, hustler.FieldColor)
}

// SetBackground sets the "background" field.
func (m *HustlerMutation) SetBackground(s string) {
	m.background = &s
}

// Background returns the value of the "background" field in the mutation.
func (m *HustlerMutation) Background() (r string, exists bool) {
	v := m.background
	if v == nil {
		return
	}
	return *v, true
}

// OldBackground returns the old "background" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldBackground(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackground is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackground requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackground: %w", err)
	}
	return oldValue.Background, nil
}

// ClearBackground clears the value of the "background" field.
func (m *HustlerMutation) ClearBackground() {
	m.background = nil
	m.clearedFields[hustler.FieldBackground] = struct{}{}
}

// BackgroundCleared returns if the "background" field was cleared in this mutation.
func (m *HustlerMutation) BackgroundCleared() bool {
	_, ok := m.clearedFields[hustler.FieldBackground]
	return ok
}

// ResetBackground resets all changes to the "background" field.
func (m *HustlerMutation) ResetBackground() {
	m.background = nil
	delete(m.clearedFields, hustler.FieldBackground)
}

// SetAge sets the "age" field.
func (m *HustlerMutation) SetAge(u uint64) {
	m.age = &u
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *HustlerMutation) Age() (r uint64, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldAge(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds u to the "age" field.
func (m *HustlerMutation) AddAge(u int64) {
	if m.addage != nil {
		*m.addage += u
	} else {
		m.addage = &u
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *HustlerMutation) AddedAge() (r int64, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *HustlerMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetSex sets the "sex" field.
func (m *HustlerMutation) SetSex(h hustler.Sex) {
	m.sex = &h
}

// Sex returns the value of the "sex" field in the mutation.
func (m *HustlerMutation) Sex() (r hustler.Sex, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldSex(ctx context.Context) (v hustler.Sex, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// ResetSex resets all changes to the "sex" field.
func (m *HustlerMutation) ResetSex() {
	m.sex = nil
}

// SetViewbox sets the "viewbox" field.
func (m *HustlerMutation) SetViewbox(i []int) {
	m.viewbox = &i
}

// Viewbox returns the value of the "viewbox" field in the mutation.
func (m *HustlerMutation) Viewbox() (r []int, exists bool) {
	v := m.viewbox
	if v == nil {
		return
	}
	return *v, true
}

// OldViewbox returns the old "viewbox" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldViewbox(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewbox is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewbox requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewbox: %w", err)
	}
	return oldValue.Viewbox, nil
}

// ResetViewbox resets all changes to the "viewbox" field.
func (m *HustlerMutation) ResetViewbox() {
	m.viewbox = nil
}

// SetOrder sets the "order" field.
func (m *HustlerMutation) SetOrder(i []int) {
	m._order = &i
}

// Order returns the value of the "order" field in the mutation.
func (m *HustlerMutation) Order() (r []int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldOrder(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// ResetOrder resets all changes to the "order" field.
func (m *HustlerMutation) ResetOrder() {
	m._order = nil
}

// SetSvg sets the "svg" field.
func (m *HustlerMutation) SetSvg(s string) {
	m.svg = &s
}

// Svg returns the value of the "svg" field in the mutation.
func (m *HustlerMutation) Svg() (r string, exists bool) {
	v := m.svg
	if v == nil {
		return
	}
	return *v, true
}

// OldSvg returns the old "svg" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldSvg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSvg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSvg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSvg: %w", err)
	}
	return oldValue.Svg, nil
}

// ClearSvg clears the value of the "svg" field.
func (m *HustlerMutation) ClearSvg() {
	m.svg = nil
	m.clearedFields[hustler.FieldSvg] = struct{}{}
}

// SvgCleared returns if the "svg" field was cleared in this mutation.
func (m *HustlerMutation) SvgCleared() bool {
	_, ok := m.clearedFields[hustler.FieldSvg]
	return ok
}

// ResetSvg resets all changes to the "svg" field.
func (m *HustlerMutation) ResetSvg() {
	m.svg = nil
	delete(m.clearedFields, hustler.FieldSvg)
}

// SetCreatedAt sets the "created_at" field.
func (m *HustlerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HustlerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Hustler entity.
// If the Hustler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HustlerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HustlerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetWalletID sets the "wallet" edge to the Wallet entity by id.
func (m *HustlerMutation) SetWalletID(id string) {
	m.wallet = &id
}

// ClearWallet clears the "wallet" edge to the Wallet entity.
func (m *HustlerMutation) ClearWallet() {
	m.clearedwallet = true
}

// WalletCleared reports if the "wallet" edge to the Wallet entity was cleared.
func (m *HustlerMutation) WalletCleared() bool {
	return m.clearedwallet
}

// WalletID returns the "wallet" edge ID in the mutation.
func (m *HustlerMutation) WalletID() (id string, exists bool) {
	if m.wallet != nil {
		return *m.wallet, true
	}
	return
}

// WalletIDs returns the "wallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WalletID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) WalletIDs() (ids []string) {
	if id := m.wallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWallet resets all changes to the "wallet" edge.
func (m *HustlerMutation) ResetWallet() {
	m.wallet = nil
	m.clearedwallet = false
}

// SetWeaponID sets the "weapon" edge to the Item entity by id.
func (m *HustlerMutation) SetWeaponID(id string) {
	m.weapon = &id
}

// ClearWeapon clears the "weapon" edge to the Item entity.
func (m *HustlerMutation) ClearWeapon() {
	m.clearedweapon = true
}

// WeaponCleared reports if the "weapon" edge to the Item entity was cleared.
func (m *HustlerMutation) WeaponCleared() bool {
	return m.clearedweapon
}

// WeaponID returns the "weapon" edge ID in the mutation.
func (m *HustlerMutation) WeaponID() (id string, exists bool) {
	if m.weapon != nil {
		return *m.weapon, true
	}
	return
}

// WeaponIDs returns the "weapon" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WeaponID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) WeaponIDs() (ids []string) {
	if id := m.weapon; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWeapon resets all changes to the "weapon" edge.
func (m *HustlerMutation) ResetWeapon() {
	m.weapon = nil
	m.clearedweapon = false
}

// SetClothesID sets the "clothes" edge to the Item entity by id.
func (m *HustlerMutation) SetClothesID(id string) {
	m.clothes = &id
}

// ClearClothes clears the "clothes" edge to the Item entity.
func (m *HustlerMutation) ClearClothes() {
	m.clearedclothes = true
}

// ClothesCleared reports if the "clothes" edge to the Item entity was cleared.
func (m *HustlerMutation) ClothesCleared() bool {
	return m.clearedclothes
}

// ClothesID returns the "clothes" edge ID in the mutation.
func (m *HustlerMutation) ClothesID() (id string, exists bool) {
	if m.clothes != nil {
		return *m.clothes, true
	}
	return
}

// ClothesIDs returns the "clothes" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClothesID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) ClothesIDs() (ids []string) {
	if id := m.clothes; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClothes resets all changes to the "clothes" edge.
func (m *HustlerMutation) ResetClothes() {
	m.clothes = nil
	m.clearedclothes = false
}

// SetVehicleID sets the "vehicle" edge to the Item entity by id.
func (m *HustlerMutation) SetVehicleID(id string) {
	m.vehicle = &id
}

// ClearVehicle clears the "vehicle" edge to the Item entity.
func (m *HustlerMutation) ClearVehicle() {
	m.clearedvehicle = true
}

// VehicleCleared reports if the "vehicle" edge to the Item entity was cleared.
func (m *HustlerMutation) VehicleCleared() bool {
	return m.clearedvehicle
}

// VehicleID returns the "vehicle" edge ID in the mutation.
func (m *HustlerMutation) VehicleID() (id string, exists bool) {
	if m.vehicle != nil {
		return *m.vehicle, true
	}
	return
}

// VehicleIDs returns the "vehicle" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VehicleID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) VehicleIDs() (ids []string) {
	if id := m.vehicle; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVehicle resets all changes to the "vehicle" edge.
func (m *HustlerMutation) ResetVehicle() {
	m.vehicle = nil
	m.clearedvehicle = false
}

// SetWaistID sets the "waist" edge to the Item entity by id.
func (m *HustlerMutation) SetWaistID(id string) {
	m.waist = &id
}

// ClearWaist clears the "waist" edge to the Item entity.
func (m *HustlerMutation) ClearWaist() {
	m.clearedwaist = true
}

// WaistCleared reports if the "waist" edge to the Item entity was cleared.
func (m *HustlerMutation) WaistCleared() bool {
	return m.clearedwaist
}

// WaistID returns the "waist" edge ID in the mutation.
func (m *HustlerMutation) WaistID() (id string, exists bool) {
	if m.waist != nil {
		return *m.waist, true
	}
	return
}

// WaistIDs returns the "waist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WaistID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) WaistIDs() (ids []string) {
	if id := m.waist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWaist resets all changes to the "waist" edge.
func (m *HustlerMutation) ResetWaist() {
	m.waist = nil
	m.clearedwaist = false
}

// SetFootID sets the "foot" edge to the Item entity by id.
func (m *HustlerMutation) SetFootID(id string) {
	m.foot = &id
}

// ClearFoot clears the "foot" edge to the Item entity.
func (m *HustlerMutation) ClearFoot() {
	m.clearedfoot = true
}

// FootCleared reports if the "foot" edge to the Item entity was cleared.
func (m *HustlerMutation) FootCleared() bool {
	return m.clearedfoot
}

// FootID returns the "foot" edge ID in the mutation.
func (m *HustlerMutation) FootID() (id string, exists bool) {
	if m.foot != nil {
		return *m.foot, true
	}
	return
}

// FootIDs returns the "foot" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FootID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) FootIDs() (ids []string) {
	if id := m.foot; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFoot resets all changes to the "foot" edge.
func (m *HustlerMutation) ResetFoot() {
	m.foot = nil
	m.clearedfoot = false
}

// SetHandID sets the "hand" edge to the Item entity by id.
func (m *HustlerMutation) SetHandID(id string) {
	m.hand = &id
}

// ClearHand clears the "hand" edge to the Item entity.
func (m *HustlerMutation) ClearHand() {
	m.clearedhand = true
}

// HandCleared reports if the "hand" edge to the Item entity was cleared.
func (m *HustlerMutation) HandCleared() bool {
	return m.clearedhand
}

// HandID returns the "hand" edge ID in the mutation.
func (m *HustlerMutation) HandID() (id string, exists bool) {
	if m.hand != nil {
		return *m.hand, true
	}
	return
}

// HandIDs returns the "hand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HandID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) HandIDs() (ids []string) {
	if id := m.hand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHand resets all changes to the "hand" edge.
func (m *HustlerMutation) ResetHand() {
	m.hand = nil
	m.clearedhand = false
}

// SetDrugID sets the "drug" edge to the Item entity by id.
func (m *HustlerMutation) SetDrugID(id string) {
	m.drug = &id
}

// ClearDrug clears the "drug" edge to the Item entity.
func (m *HustlerMutation) ClearDrug() {
	m.cleareddrug = true
}

// DrugCleared reports if the "drug" edge to the Item entity was cleared.
func (m *HustlerMutation) DrugCleared() bool {
	return m.cleareddrug
}

// DrugID returns the "drug" edge ID in the mutation.
func (m *HustlerMutation) DrugID() (id string, exists bool) {
	if m.drug != nil {
		return *m.drug, true
	}
	return
}

// DrugIDs returns the "drug" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DrugID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) DrugIDs() (ids []string) {
	if id := m.drug; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDrug resets all changes to the "drug" edge.
func (m *HustlerMutation) ResetDrug() {
	m.drug = nil
	m.cleareddrug = false
}

// SetNeckID sets the "neck" edge to the Item entity by id.
func (m *HustlerMutation) SetNeckID(id string) {
	m.neck = &id
}

// ClearNeck clears the "neck" edge to the Item entity.
func (m *HustlerMutation) ClearNeck() {
	m.clearedneck = true
}

// NeckCleared reports if the "neck" edge to the Item entity was cleared.
func (m *HustlerMutation) NeckCleared() bool {
	return m.clearedneck
}

// NeckID returns the "neck" edge ID in the mutation.
func (m *HustlerMutation) NeckID() (id string, exists bool) {
	if m.neck != nil {
		return *m.neck, true
	}
	return
}

// NeckIDs returns the "neck" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NeckID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) NeckIDs() (ids []string) {
	if id := m.neck; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNeck resets all changes to the "neck" edge.
func (m *HustlerMutation) ResetNeck() {
	m.neck = nil
	m.clearedneck = false
}

// SetRingID sets the "ring" edge to the Item entity by id.
func (m *HustlerMutation) SetRingID(id string) {
	m.ring = &id
}

// ClearRing clears the "ring" edge to the Item entity.
func (m *HustlerMutation) ClearRing() {
	m.clearedring = true
}

// RingCleared reports if the "ring" edge to the Item entity was cleared.
func (m *HustlerMutation) RingCleared() bool {
	return m.clearedring
}

// RingID returns the "ring" edge ID in the mutation.
func (m *HustlerMutation) RingID() (id string, exists bool) {
	if m.ring != nil {
		return *m.ring, true
	}
	return
}

// RingIDs returns the "ring" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RingID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) RingIDs() (ids []string) {
	if id := m.ring; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRing resets all changes to the "ring" edge.
func (m *HustlerMutation) ResetRing() {
	m.ring = nil
	m.clearedring = false
}

// SetAccessoryID sets the "accessory" edge to the Item entity by id.
func (m *HustlerMutation) SetAccessoryID(id string) {
	m.accessory = &id
}

// ClearAccessory clears the "accessory" edge to the Item entity.
func (m *HustlerMutation) ClearAccessory() {
	m.clearedaccessory = true
}

// AccessoryCleared reports if the "accessory" edge to the Item entity was cleared.
func (m *HustlerMutation) AccessoryCleared() bool {
	return m.clearedaccessory
}

// AccessoryID returns the "accessory" edge ID in the mutation.
func (m *HustlerMutation) AccessoryID() (id string, exists bool) {
	if m.accessory != nil {
		return *m.accessory, true
	}
	return
}

// AccessoryIDs returns the "accessory" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccessoryID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) AccessoryIDs() (ids []string) {
	if id := m.accessory; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccessory resets all changes to the "accessory" edge.
func (m *HustlerMutation) ResetAccessory() {
	m.accessory = nil
	m.clearedaccessory = false
}

// SetBodyID sets the "body" edge to the BodyPart entity by id.
func (m *HustlerMutation) SetBodyID(id string) {
	m.body = &id
}

// ClearBody clears the "body" edge to the BodyPart entity.
func (m *HustlerMutation) ClearBody() {
	m.clearedbody = true
}

// BodyCleared reports if the "body" edge to the BodyPart entity was cleared.
func (m *HustlerMutation) BodyCleared() bool {
	return m.clearedbody
}

// BodyID returns the "body" edge ID in the mutation.
func (m *HustlerMutation) BodyID() (id string, exists bool) {
	if m.body != nil {
		return *m.body, true
	}
	return
}

// BodyIDs returns the "body" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BodyID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) BodyIDs() (ids []string) {
	if id := m.body; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBody resets all changes to the "body" edge.
func (m *HustlerMutation) ResetBody() {
	m.body = nil
	m.clearedbody = false
}

// SetHairID sets the "hair" edge to the BodyPart entity by id.
func (m *HustlerMutation) SetHairID(id string) {
	m.hair = &id
}

// ClearHair clears the "hair" edge to the BodyPart entity.
func (m *HustlerMutation) ClearHair() {
	m.clearedhair = true
}

// HairCleared reports if the "hair" edge to the BodyPart entity was cleared.
func (m *HustlerMutation) HairCleared() bool {
	return m.clearedhair
}

// HairID returns the "hair" edge ID in the mutation.
func (m *HustlerMutation) HairID() (id string, exists bool) {
	if m.hair != nil {
		return *m.hair, true
	}
	return
}

// HairIDs returns the "hair" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HairID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) HairIDs() (ids []string) {
	if id := m.hair; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHair resets all changes to the "hair" edge.
func (m *HustlerMutation) ResetHair() {
	m.hair = nil
	m.clearedhair = false
}

// SetBeardID sets the "beard" edge to the BodyPart entity by id.
func (m *HustlerMutation) SetBeardID(id string) {
	m.beard = &id
}

// ClearBeard clears the "beard" edge to the BodyPart entity.
func (m *HustlerMutation) ClearBeard() {
	m.clearedbeard = true
}

// BeardCleared reports if the "beard" edge to the BodyPart entity was cleared.
func (m *HustlerMutation) BeardCleared() bool {
	return m.clearedbeard
}

// BeardID returns the "beard" edge ID in the mutation.
func (m *HustlerMutation) BeardID() (id string, exists bool) {
	if m.beard != nil {
		return *m.beard, true
	}
	return
}

// BeardIDs returns the "beard" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BeardID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) BeardIDs() (ids []string) {
	if id := m.beard; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBeard resets all changes to the "beard" edge.
func (m *HustlerMutation) ResetBeard() {
	m.beard = nil
	m.clearedbeard = false
}

// SetIndexID sets the "index" edge to the Search entity by id.
func (m *HustlerMutation) SetIndexID(id string) {
	m.index = &id
}

// ClearIndex clears the "index" edge to the Search entity.
func (m *HustlerMutation) ClearIndex() {
	m.clearedindex = true
}

// IndexCleared reports if the "index" edge to the Search entity was cleared.
func (m *HustlerMutation) IndexCleared() bool {
	return m.clearedindex
}

// IndexID returns the "index" edge ID in the mutation.
func (m *HustlerMutation) IndexID() (id string, exists bool) {
	if m.index != nil {
		return *m.index, true
	}
	return
}

// IndexIDs returns the "index" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IndexID instead. It exists only for internal usage by the builders.
func (m *HustlerMutation) IndexIDs() (ids []string) {
	if id := m.index; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIndex resets all changes to the "index" edge.
func (m *HustlerMutation) ResetIndex() {
	m.index = nil
	m.clearedindex = false
}

// Where appends a list predicates to the HustlerMutation builder.
func (m *HustlerMutation) Where(ps ...predicate.Hustler) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HustlerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Hustler).
func (m *HustlerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HustlerMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m._type != nil {
		fields = append(fields, hustler.FieldType)
	}
	if m.name != nil {
		fields = append(fields, hustler.FieldName)
	}
	if m.title != nil {
		fields = append(fields, hustler.FieldTitle)
	}
	if m.color != nil {
		fields = append(fields, hustler.FieldColor)
	}
	if m.background != nil {
		fields = append(fields, hustler.FieldBackground)
	}
	if m.age != nil {
		fields = append(fields, hustler.FieldAge)
	}
	if m.sex != nil {
		fields = append(fields, hustler.FieldSex)
	}
	if m.viewbox != nil {
		fields = append(fields, hustler.FieldViewbox)
	}
	if m._order != nil {
		fields = append(fields, hustler.FieldOrder)
	}
	if m.svg != nil {
		fields = append(fields, hustler.FieldSvg)
	}
	if m.created_at != nil {
		fields = append(fields, hustler.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HustlerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hustler.FieldType:
		return m.GetType()
	case hustler.FieldName:
		return m.Name()
	case hustler.FieldTitle:
		return m.Title()
	case hustler.FieldColor:
		return m.Color()
	case hustler.FieldBackground:
		return m.Background()
	case hustler.FieldAge:
		return m.Age()
	case hustler.FieldSex:
		return m.Sex()
	case hustler.FieldViewbox:
		return m.Viewbox()
	case hustler.FieldOrder:
		return m.Order()
	case hustler.FieldSvg:
		return m.Svg()
	case hustler.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HustlerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hustler.FieldType:
		return m.OldType(ctx)
	case hustler.FieldName:
		return m.OldName(ctx)
	case hustler.FieldTitle:
		return m.OldTitle(ctx)
	case hustler.FieldColor:
		return m.OldColor(ctx)
	case hustler.FieldBackground:
		return m.OldBackground(ctx)
	case hustler.FieldAge:
		return m.OldAge(ctx)
	case hustler.FieldSex:
		return m.OldSex(ctx)
	case hustler.FieldViewbox:
		return m.OldViewbox(ctx)
	case hustler.FieldOrder:
		return m.OldOrder(ctx)
	case hustler.FieldSvg:
		return m.OldSvg(ctx)
	case hustler.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Hustler field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HustlerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hustler.FieldType:
		v, ok := value.(hustler.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case hustler.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hustler.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case hustler.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case hustler.FieldBackground:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackground(v)
		return nil
	case hustler.FieldAge:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case hustler.FieldSex:
		v, ok := value.(hustler.Sex)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case hustler.FieldViewbox:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewbox(v)
		return nil
	case hustler.FieldOrder:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case hustler.FieldSvg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSvg(v)
		return nil
	case hustler.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Hustler field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HustlerMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, hustler.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HustlerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hustler.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HustlerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hustler.FieldAge:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown Hustler numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HustlerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hustler.FieldName) {
		fields = append(fields, hustler.FieldName)
	}
	if m.FieldCleared(hustler.FieldTitle) {
		fields = append(fields, hustler.FieldTitle)
	}
	if m.FieldCleared(hustler.FieldColor) {
		fields = append(fields, hustler.FieldColor)
	}
	if m.FieldCleared(hustler.FieldBackground) {
		fields = append(fields, hustler.FieldBackground)
	}
	if m.FieldCleared(hustler.FieldSvg) {
		fields = append(fields, hustler.FieldSvg)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HustlerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HustlerMutation) ClearField(name string) error {
	switch name {
	case hustler.FieldName:
		m.ClearName()
		return nil
	case hustler.FieldTitle:
		m.ClearTitle()
		return nil
	case hustler.FieldColor:
		m.ClearColor()
		return nil
	case hustler.FieldBackground:
		m.ClearBackground()
		return nil
	case hustler.FieldSvg:
		m.ClearSvg()
		return nil
	}
	return fmt.Errorf("unknown Hustler nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HustlerMutation) ResetField(name string) error {
	switch name {
	case hustler.FieldType:
		m.ResetType()
		return nil
	case hustler.FieldName:
		m.ResetName()
		return nil
	case hustler.FieldTitle:
		m.ResetTitle()
		return nil
	case hustler.FieldColor:
		m.ResetColor()
		return nil
	case hustler.FieldBackground:
		m.ResetBackground()
		return nil
	case hustler.FieldAge:
		m.ResetAge()
		return nil
	case hustler.FieldSex:
		m.ResetSex()
		return nil
	case hustler.FieldViewbox:
		m.ResetViewbox()
		return nil
	case hustler.FieldOrder:
		m.ResetOrder()
		return nil
	case hustler.FieldSvg:
		m.ResetSvg()
		return nil
	case hustler.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Hustler field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HustlerMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.wallet != nil {
		edges = append(edges, hustler.EdgeWallet)
	}
	if m.weapon != nil {
		edges = append(edges, hustler.EdgeWeapon)
	}
	if m.clothes != nil {
		edges = append(edges, hustler.EdgeClothes)
	}
	if m.vehicle != nil {
		edges = append(edges, hustler.EdgeVehicle)
	}
	if m.waist != nil {
		edges = append(edges, hustler.EdgeWaist)
	}
	if m.foot != nil {
		edges = append(edges, hustler.EdgeFoot)
	}
	if m.hand != nil {
		edges = append(edges, hustler.EdgeHand)
	}
	if m.drug != nil {
		edges = append(edges, hustler.EdgeDrug)
	}
	if m.neck != nil {
		edges = append(edges, hustler.EdgeNeck)
	}
	if m.ring != nil {
		edges = append(edges, hustler.EdgeRing)
	}
	if m.accessory != nil {
		edges = append(edges, hustler.EdgeAccessory)
	}
	if m.body != nil {
		edges = append(edges, hustler.EdgeBody)
	}
	if m.hair != nil {
		edges = append(edges, hustler.EdgeHair)
	}
	if m.beard != nil {
		edges = append(edges, hustler.EdgeBeard)
	}
	if m.index != nil {
		edges = append(edges, hustler.EdgeIndex)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HustlerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hustler.EdgeWallet:
		if id := m.wallet; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeWeapon:
		if id := m.weapon; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeClothes:
		if id := m.clothes; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeVehicle:
		if id := m.vehicle; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeWaist:
		if id := m.waist; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeFoot:
		if id := m.foot; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeHand:
		if id := m.hand; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeDrug:
		if id := m.drug; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeNeck:
		if id := m.neck; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeRing:
		if id := m.ring; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeAccessory:
		if id := m.accessory; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeBody:
		if id := m.body; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeHair:
		if id := m.hair; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeBeard:
		if id := m.beard; id != nil {
			return []ent.Value{*id}
		}
	case hustler.EdgeIndex:
		if id := m.index; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HustlerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HustlerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HustlerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedwallet {
		edges = append(edges, hustler.EdgeWallet)
	}
	if m.clearedweapon {
		edges = append(edges, hustler.EdgeWeapon)
	}
	if m.clearedclothes {
		edges = append(edges, hustler.EdgeClothes)
	}
	if m.clearedvehicle {
		edges = append(edges, hustler.EdgeVehicle)
	}
	if m.clearedwaist {
		edges = append(edges, hustler.EdgeWaist)
	}
	if m.clearedfoot {
		edges = append(edges, hustler.EdgeFoot)
	}
	if m.clearedhand {
		edges = append(edges, hustler.EdgeHand)
	}
	if m.cleareddrug {
		edges = append(edges, hustler.EdgeDrug)
	}
	if m.clearedneck {
		edges = append(edges, hustler.EdgeNeck)
	}
	if m.clearedring {
		edges = append(edges, hustler.EdgeRing)
	}
	if m.clearedaccessory {
		edges = append(edges, hustler.EdgeAccessory)
	}
	if m.clearedbody {
		edges = append(edges, hustler.EdgeBody)
	}
	if m.clearedhair {
		edges = append(edges, hustler.EdgeHair)
	}
	if m.clearedbeard {
		edges = append(edges, hustler.EdgeBeard)
	}
	if m.clearedindex {
		edges = append(edges, hustler.EdgeIndex)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HustlerMutation) EdgeCleared(name string) bool {
	switch name {
	case hustler.EdgeWallet:
		return m.clearedwallet
	case hustler.EdgeWeapon:
		return m.clearedweapon
	case hustler.EdgeClothes:
		return m.clearedclothes
	case hustler.EdgeVehicle:
		return m.clearedvehicle
	case hustler.EdgeWaist:
		return m.clearedwaist
	case hustler.EdgeFoot:
		return m.clearedfoot
	case hustler.EdgeHand:
		return m.clearedhand
	case hustler.EdgeDrug:
		return m.cleareddrug
	case hustler.EdgeNeck:
		return m.clearedneck
	case hustler.EdgeRing:
		return m.clearedring
	case hustler.EdgeAccessory:
		return m.clearedaccessory
	case hustler.EdgeBody:
		return m.clearedbody
	case hustler.EdgeHair:
		return m.clearedhair
	case hustler.EdgeBeard:
		return m.clearedbeard
	case hustler.EdgeIndex:
		return m.clearedindex
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HustlerMutation) ClearEdge(name string) error {
	switch name {
	case hustler.EdgeWallet:
		m.ClearWallet()
		return nil
	case hustler.EdgeWeapon:
		m.ClearWeapon()
		return nil
	case hustler.EdgeClothes:
		m.ClearClothes()
		return nil
	case hustler.EdgeVehicle:
		m.ClearVehicle()
		return nil
	case hustler.EdgeWaist:
		m.ClearWaist()
		return nil
	case hustler.EdgeFoot:
		m.ClearFoot()
		return nil
	case hustler.EdgeHand:
		m.ClearHand()
		return nil
	case hustler.EdgeDrug:
		m.ClearDrug()
		return nil
	case hustler.EdgeNeck:
		m.ClearNeck()
		return nil
	case hustler.EdgeRing:
		m.ClearRing()
		return nil
	case hustler.EdgeAccessory:
		m.ClearAccessory()
		return nil
	case hustler.EdgeBody:
		m.ClearBody()
		return nil
	case hustler.EdgeHair:
		m.ClearHair()
		return nil
	case hustler.EdgeBeard:
		m.ClearBeard()
		return nil
	case hustler.EdgeIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown Hustler unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HustlerMutation) ResetEdge(name string) error {
	switch name {
	case hustler.EdgeWallet:
		m.ResetWallet()
		return nil
	case hustler.EdgeWeapon:
		m.ResetWeapon()
		return nil
	case hustler.EdgeClothes:
		m.ResetClothes()
		return nil
	case hustler.EdgeVehicle:
		m.ResetVehicle()
		return nil
	case hustler.EdgeWaist:
		m.ResetWaist()
		return nil
	case hustler.EdgeFoot:
		m.ResetFoot()
		return nil
	case hustler.EdgeHand:
		m.ResetHand()
		return nil
	case hustler.EdgeDrug:
		m.ResetDrug()
		return nil
	case hustler.EdgeNeck:
		m.ResetNeck()
		return nil
	case hustler.EdgeRing:
		m.ResetRing()
		return nil
	case hustler.EdgeAccessory:
		m.ResetAccessory()
		return nil
	case hustler.EdgeBody:
		m.ResetBody()
		return nil
	case hustler.EdgeHair:
		m.ResetHair()
		return nil
	case hustler.EdgeBeard:
		m.ResetBeard()
		return nil
	case hustler.EdgeIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown Hustler edge %s", name)
}

// ItemMutation represents an operation that mutates the Item nodes in the graph.
type ItemMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	_type                      *item.Type
	name_prefix                *string
	name_suffix                *string
	name                       *string
	suffix                     *string
	augmented                  *bool
	count                      *int
	addcount                   *int
	tier                       *item.Tier
	greatness                  *int
	addgreatness               *int
	rles                       *schema.RLEs
	svg                        *string
	sprite                     *schema.Sprites
	clearedFields              map[string]struct{}
	wallets                    map[string]struct{}
	removedwallets             map[string]struct{}
	clearedwallets             bool
	dopes                      map[string]struct{}
	removeddopes               map[string]struct{}
	cleareddopes               bool
	hustler_weapons            map[string]struct{}
	removedhustler_weapons     map[string]struct{}
	clearedhustler_weapons     bool
	hustler_clothes            map[string]struct{}
	removedhustler_clothes     map[string]struct{}
	clearedhustler_clothes     bool
	hustler_vehicles           map[string]struct{}
	removedhustler_vehicles    map[string]struct{}
	clearedhustler_vehicles    bool
	hustler_waists             map[string]struct{}
	removedhustler_waists      map[string]struct{}
	clearedhustler_waists      bool
	hustler_feet               map[string]struct{}
	removedhustler_feet        map[string]struct{}
	clearedhustler_feet        bool
	hustler_hands              map[string]struct{}
	removedhustler_hands       map[string]struct{}
	clearedhustler_hands       bool
	hustler_drugs              map[string]struct{}
	removedhustler_drugs       map[string]struct{}
	clearedhustler_drugs       bool
	hustler_necks              map[string]struct{}
	removedhustler_necks       map[string]struct{}
	clearedhustler_necks       bool
	hustler_rings              map[string]struct{}
	removedhustler_rings       map[string]struct{}
	clearedhustler_rings       bool
	hustler_accessories        map[string]struct{}
	removedhustler_accessories map[string]struct{}
	clearedhustler_accessories bool
	base                       *string
	clearedbase                bool
	derivative                 map[string]struct{}
	removedderivative          map[string]struct{}
	clearedderivative          bool
	index                      *string
	clearedindex               bool
	done                       bool
	oldValue                   func(context.Context) (*Item, error)
	predicates                 []predicate.Item
}

var _ ent.Mutation = (*ItemMutation)(nil)

// itemOption allows management of the mutation configuration using functional options.
type itemOption func(*ItemMutation)

// newItemMutation creates new mutation for the Item entity.
func newItemMutation(c config, op Op, opts ...itemOption) *ItemMutation {
	m := &ItemMutation{
		config:        c,
		op:            op,
		typ:           TypeItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withItemID sets the ID field of the mutation.
func withItemID(id string) itemOption {
	return func(m *ItemMutation) {
		var (
			err   error
			once  sync.Once
			value *Item
		)
		m.oldValue = func(ctx context.Context) (*Item, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Item.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withItem sets the old Item of the mutation.
func withItem(node *Item) itemOption {
	return func(m *ItemMutation) {
		m.oldValue = func(context.Context) (*Item, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Item entities.
func (m *ItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Item.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ItemMutation) SetType(i item.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *ItemMutation) GetType() (r item.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldType(ctx context.Context) (v item.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ItemMutation) ResetType() {
	m._type = nil
}

// SetNamePrefix sets the "name_prefix" field.
func (m *ItemMutation) SetNamePrefix(s string) {
	m.name_prefix = &s
}

// NamePrefix returns the value of the "name_prefix" field in the mutation.
func (m *ItemMutation) NamePrefix() (r string, exists bool) {
	v := m.name_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldNamePrefix returns the old "name_prefix" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldNamePrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamePrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamePrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamePrefix: %w", err)
	}
	return oldValue.NamePrefix, nil
}

// ClearNamePrefix clears the value of the "name_prefix" field.
func (m *ItemMutation) ClearNamePrefix() {
	m.name_prefix = nil
	m.clearedFields[item.FieldNamePrefix] = struct{}{}
}

// NamePrefixCleared returns if the "name_prefix" field was cleared in this mutation.
func (m *ItemMutation) NamePrefixCleared() bool {
	_, ok := m.clearedFields[item.FieldNamePrefix]
	return ok
}

// ResetNamePrefix resets all changes to the "name_prefix" field.
func (m *ItemMutation) ResetNamePrefix() {
	m.name_prefix = nil
	delete(m.clearedFields, item.FieldNamePrefix)
}

// SetNameSuffix sets the "name_suffix" field.
func (m *ItemMutation) SetNameSuffix(s string) {
	m.name_suffix = &s
}

// NameSuffix returns the value of the "name_suffix" field in the mutation.
func (m *ItemMutation) NameSuffix() (r string, exists bool) {
	v := m.name_suffix
	if v == nil {
		return
	}
	return *v, true
}

// OldNameSuffix returns the old "name_suffix" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldNameSuffix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameSuffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameSuffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameSuffix: %w", err)
	}
	return oldValue.NameSuffix, nil
}

// ClearNameSuffix clears the value of the "name_suffix" field.
func (m *ItemMutation) ClearNameSuffix() {
	m.name_suffix = nil
	m.clearedFields[item.FieldNameSuffix] = struct{}{}
}

// NameSuffixCleared returns if the "name_suffix" field was cleared in this mutation.
func (m *ItemMutation) NameSuffixCleared() bool {
	_, ok := m.clearedFields[item.FieldNameSuffix]
	return ok
}

// ResetNameSuffix resets all changes to the "name_suffix" field.
func (m *ItemMutation) ResetNameSuffix() {
	m.name_suffix = nil
	delete(m.clearedFields, item.FieldNameSuffix)
}

// SetName sets the "name" field.
func (m *ItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ItemMutation) ResetName() {
	m.name = nil
}

// SetSuffix sets the "suffix" field.
func (m *ItemMutation) SetSuffix(s string) {
	m.suffix = &s
}

// Suffix returns the value of the "suffix" field in the mutation.
func (m *ItemMutation) Suffix() (r string, exists bool) {
	v := m.suffix
	if v == nil {
		return
	}
	return *v, true
}

// OldSuffix returns the old "suffix" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSuffix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuffix: %w", err)
	}
	return oldValue.Suffix, nil
}

// ClearSuffix clears the value of the "suffix" field.
func (m *ItemMutation) ClearSuffix() {
	m.suffix = nil
	m.clearedFields[item.FieldSuffix] = struct{}{}
}

// SuffixCleared returns if the "suffix" field was cleared in this mutation.
func (m *ItemMutation) SuffixCleared() bool {
	_, ok := m.clearedFields[item.FieldSuffix]
	return ok
}

// ResetSuffix resets all changes to the "suffix" field.
func (m *ItemMutation) ResetSuffix() {
	m.suffix = nil
	delete(m.clearedFields, item.FieldSuffix)
}

// SetAugmented sets the "augmented" field.
func (m *ItemMutation) SetAugmented(b bool) {
	m.augmented = &b
}

// Augmented returns the value of the "augmented" field in the mutation.
func (m *ItemMutation) Augmented() (r bool, exists bool) {
	v := m.augmented
	if v == nil {
		return
	}
	return *v, true
}

// OldAugmented returns the old "augmented" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldAugmented(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAugmented is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAugmented requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAugmented: %w", err)
	}
	return oldValue.Augmented, nil
}

// ClearAugmented clears the value of the "augmented" field.
func (m *ItemMutation) ClearAugmented() {
	m.augmented = nil
	m.clearedFields[item.FieldAugmented] = struct{}{}
}

// AugmentedCleared returns if the "augmented" field was cleared in this mutation.
func (m *ItemMutation) AugmentedCleared() bool {
	_, ok := m.clearedFields[item.FieldAugmented]
	return ok
}

// ResetAugmented resets all changes to the "augmented" field.
func (m *ItemMutation) ResetAugmented() {
	m.augmented = nil
	delete(m.clearedFields, item.FieldAugmented)
}

// SetCount sets the "count" field.
func (m *ItemMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *ItemMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *ItemMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *ItemMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ClearCount clears the value of the "count" field.
func (m *ItemMutation) ClearCount() {
	m.count = nil
	m.addcount = nil
	m.clearedFields[item.FieldCount] = struct{}{}
}

// CountCleared returns if the "count" field was cleared in this mutation.
func (m *ItemMutation) CountCleared() bool {
	_, ok := m.clearedFields[item.FieldCount]
	return ok
}

// ResetCount resets all changes to the "count" field.
func (m *ItemMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
	delete(m.clearedFields, item.FieldCount)
}

// SetTier sets the "tier" field.
func (m *ItemMutation) SetTier(i item.Tier) {
	m.tier = &i
}

// Tier returns the value of the "tier" field in the mutation.
func (m *ItemMutation) Tier() (r item.Tier, exists bool) {
	v := m.tier
	if v == nil {
		return
	}
	return *v, true
}

// OldTier returns the old "tier" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldTier(ctx context.Context) (v item.Tier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTier: %w", err)
	}
	return oldValue.Tier, nil
}

// ClearTier clears the value of the "tier" field.
func (m *ItemMutation) ClearTier() {
	m.tier = nil
	m.clearedFields[item.FieldTier] = struct{}{}
}

// TierCleared returns if the "tier" field was cleared in this mutation.
func (m *ItemMutation) TierCleared() bool {
	_, ok := m.clearedFields[item.FieldTier]
	return ok
}

// ResetTier resets all changes to the "tier" field.
func (m *ItemMutation) ResetTier() {
	m.tier = nil
	delete(m.clearedFields, item.FieldTier)
}

// SetGreatness sets the "greatness" field.
func (m *ItemMutation) SetGreatness(i int) {
	m.greatness = &i
	m.addgreatness = nil
}

// Greatness returns the value of the "greatness" field in the mutation.
func (m *ItemMutation) Greatness() (r int, exists bool) {
	v := m.greatness
	if v == nil {
		return
	}
	return *v, true
}

// OldGreatness returns the old "greatness" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldGreatness(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGreatness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGreatness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGreatness: %w", err)
	}
	return oldValue.Greatness, nil
}

// AddGreatness adds i to the "greatness" field.
func (m *ItemMutation) AddGreatness(i int) {
	if m.addgreatness != nil {
		*m.addgreatness += i
	} else {
		m.addgreatness = &i
	}
}

// AddedGreatness returns the value that was added to the "greatness" field in this mutation.
func (m *ItemMutation) AddedGreatness() (r int, exists bool) {
	v := m.addgreatness
	if v == nil {
		return
	}
	return *v, true
}

// ClearGreatness clears the value of the "greatness" field.
func (m *ItemMutation) ClearGreatness() {
	m.greatness = nil
	m.addgreatness = nil
	m.clearedFields[item.FieldGreatness] = struct{}{}
}

// GreatnessCleared returns if the "greatness" field was cleared in this mutation.
func (m *ItemMutation) GreatnessCleared() bool {
	_, ok := m.clearedFields[item.FieldGreatness]
	return ok
}

// ResetGreatness resets all changes to the "greatness" field.
func (m *ItemMutation) ResetGreatness() {
	m.greatness = nil
	m.addgreatness = nil
	delete(m.clearedFields, item.FieldGreatness)
}

// SetRles sets the "rles" field.
func (m *ItemMutation) SetRles(se schema.RLEs) {
	m.rles = &se
}

// Rles returns the value of the "rles" field in the mutation.
func (m *ItemMutation) Rles() (r schema.RLEs, exists bool) {
	v := m.rles
	if v == nil {
		return
	}
	return *v, true
}

// OldRles returns the old "rles" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldRles(ctx context.Context) (v schema.RLEs, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRles: %w", err)
	}
	return oldValue.Rles, nil
}

// ClearRles clears the value of the "rles" field.
func (m *ItemMutation) ClearRles() {
	m.rles = nil
	m.clearedFields[item.FieldRles] = struct{}{}
}

// RlesCleared returns if the "rles" field was cleared in this mutation.
func (m *ItemMutation) RlesCleared() bool {
	_, ok := m.clearedFields[item.FieldRles]
	return ok
}

// ResetRles resets all changes to the "rles" field.
func (m *ItemMutation) ResetRles() {
	m.rles = nil
	delete(m.clearedFields, item.FieldRles)
}

// SetSvg sets the "svg" field.
func (m *ItemMutation) SetSvg(s string) {
	m.svg = &s
}

// Svg returns the value of the "svg" field in the mutation.
func (m *ItemMutation) Svg() (r string, exists bool) {
	v := m.svg
	if v == nil {
		return
	}
	return *v, true
}

// OldSvg returns the old "svg" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSvg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSvg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSvg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSvg: %w", err)
	}
	return oldValue.Svg, nil
}

// ClearSvg clears the value of the "svg" field.
func (m *ItemMutation) ClearSvg() {
	m.svg = nil
	m.clearedFields[item.FieldSvg] = struct{}{}
}

// SvgCleared returns if the "svg" field was cleared in this mutation.
func (m *ItemMutation) SvgCleared() bool {
	_, ok := m.clearedFields[item.FieldSvg]
	return ok
}

// ResetSvg resets all changes to the "svg" field.
func (m *ItemMutation) ResetSvg() {
	m.svg = nil
	delete(m.clearedFields, item.FieldSvg)
}

// SetSprite sets the "sprite" field.
func (m *ItemMutation) SetSprite(s schema.Sprites) {
	m.sprite = &s
}

// Sprite returns the value of the "sprite" field in the mutation.
func (m *ItemMutation) Sprite() (r schema.Sprites, exists bool) {
	v := m.sprite
	if v == nil {
		return
	}
	return *v, true
}

// OldSprite returns the old "sprite" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSprite(ctx context.Context) (v schema.Sprites, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSprite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSprite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSprite: %w", err)
	}
	return oldValue.Sprite, nil
}

// ClearSprite clears the value of the "sprite" field.
func (m *ItemMutation) ClearSprite() {
	m.sprite = nil
	m.clearedFields[item.FieldSprite] = struct{}{}
}

// SpriteCleared returns if the "sprite" field was cleared in this mutation.
func (m *ItemMutation) SpriteCleared() bool {
	_, ok := m.clearedFields[item.FieldSprite]
	return ok
}

// ResetSprite resets all changes to the "sprite" field.
func (m *ItemMutation) ResetSprite() {
	m.sprite = nil
	delete(m.clearedFields, item.FieldSprite)
}

// AddWalletIDs adds the "wallets" edge to the WalletItems entity by ids.
func (m *ItemMutation) AddWalletIDs(ids ...string) {
	if m.wallets == nil {
		m.wallets = make(map[string]struct{})
	}
	for i := range ids {
		m.wallets[ids[i]] = struct{}{}
	}
}

// ClearWallets clears the "wallets" edge to the WalletItems entity.
func (m *ItemMutation) ClearWallets() {
	m.clearedwallets = true
}

// WalletsCleared reports if the "wallets" edge to the WalletItems entity was cleared.
func (m *ItemMutation) WalletsCleared() bool {
	return m.clearedwallets
}

// RemoveWalletIDs removes the "wallets" edge to the WalletItems entity by IDs.
func (m *ItemMutation) RemoveWalletIDs(ids ...string) {
	if m.removedwallets == nil {
		m.removedwallets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.wallets, ids[i])
		m.removedwallets[ids[i]] = struct{}{}
	}
}

// RemovedWallets returns the removed IDs of the "wallets" edge to the WalletItems entity.
func (m *ItemMutation) RemovedWalletsIDs() (ids []string) {
	for id := range m.removedwallets {
		ids = append(ids, id)
	}
	return
}

// WalletsIDs returns the "wallets" edge IDs in the mutation.
func (m *ItemMutation) WalletsIDs() (ids []string) {
	for id := range m.wallets {
		ids = append(ids, id)
	}
	return
}

// ResetWallets resets all changes to the "wallets" edge.
func (m *ItemMutation) ResetWallets() {
	m.wallets = nil
	m.clearedwallets = false
	m.removedwallets = nil
}

// AddDopeIDs adds the "dopes" edge to the Dope entity by ids.
func (m *ItemMutation) AddDopeIDs(ids ...string) {
	if m.dopes == nil {
		m.dopes = make(map[string]struct{})
	}
	for i := range ids {
		m.dopes[ids[i]] = struct{}{}
	}
}

// ClearDopes clears the "dopes" edge to the Dope entity.
func (m *ItemMutation) ClearDopes() {
	m.cleareddopes = true
}

// DopesCleared reports if the "dopes" edge to the Dope entity was cleared.
func (m *ItemMutation) DopesCleared() bool {
	return m.cleareddopes
}

// RemoveDopeIDs removes the "dopes" edge to the Dope entity by IDs.
func (m *ItemMutation) RemoveDopeIDs(ids ...string) {
	if m.removeddopes == nil {
		m.removeddopes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dopes, ids[i])
		m.removeddopes[ids[i]] = struct{}{}
	}
}

// RemovedDopes returns the removed IDs of the "dopes" edge to the Dope entity.
func (m *ItemMutation) RemovedDopesIDs() (ids []string) {
	for id := range m.removeddopes {
		ids = append(ids, id)
	}
	return
}

// DopesIDs returns the "dopes" edge IDs in the mutation.
func (m *ItemMutation) DopesIDs() (ids []string) {
	for id := range m.dopes {
		ids = append(ids, id)
	}
	return
}

// ResetDopes resets all changes to the "dopes" edge.
func (m *ItemMutation) ResetDopes() {
	m.dopes = nil
	m.cleareddopes = false
	m.removeddopes = nil
}

// AddHustlerWeaponIDs adds the "hustler_weapons" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerWeaponIDs(ids ...string) {
	if m.hustler_weapons == nil {
		m.hustler_weapons = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_weapons[ids[i]] = struct{}{}
	}
}

// ClearHustlerWeapons clears the "hustler_weapons" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerWeapons() {
	m.clearedhustler_weapons = true
}

// HustlerWeaponsCleared reports if the "hustler_weapons" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerWeaponsCleared() bool {
	return m.clearedhustler_weapons
}

// RemoveHustlerWeaponIDs removes the "hustler_weapons" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerWeaponIDs(ids ...string) {
	if m.removedhustler_weapons == nil {
		m.removedhustler_weapons = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_weapons, ids[i])
		m.removedhustler_weapons[ids[i]] = struct{}{}
	}
}

// RemovedHustlerWeapons returns the removed IDs of the "hustler_weapons" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerWeaponsIDs() (ids []string) {
	for id := range m.removedhustler_weapons {
		ids = append(ids, id)
	}
	return
}

// HustlerWeaponsIDs returns the "hustler_weapons" edge IDs in the mutation.
func (m *ItemMutation) HustlerWeaponsIDs() (ids []string) {
	for id := range m.hustler_weapons {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerWeapons resets all changes to the "hustler_weapons" edge.
func (m *ItemMutation) ResetHustlerWeapons() {
	m.hustler_weapons = nil
	m.clearedhustler_weapons = false
	m.removedhustler_weapons = nil
}

// AddHustlerClotheIDs adds the "hustler_clothes" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerClotheIDs(ids ...string) {
	if m.hustler_clothes == nil {
		m.hustler_clothes = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_clothes[ids[i]] = struct{}{}
	}
}

// ClearHustlerClothes clears the "hustler_clothes" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerClothes() {
	m.clearedhustler_clothes = true
}

// HustlerClothesCleared reports if the "hustler_clothes" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerClothesCleared() bool {
	return m.clearedhustler_clothes
}

// RemoveHustlerClotheIDs removes the "hustler_clothes" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerClotheIDs(ids ...string) {
	if m.removedhustler_clothes == nil {
		m.removedhustler_clothes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_clothes, ids[i])
		m.removedhustler_clothes[ids[i]] = struct{}{}
	}
}

// RemovedHustlerClothes returns the removed IDs of the "hustler_clothes" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerClothesIDs() (ids []string) {
	for id := range m.removedhustler_clothes {
		ids = append(ids, id)
	}
	return
}

// HustlerClothesIDs returns the "hustler_clothes" edge IDs in the mutation.
func (m *ItemMutation) HustlerClothesIDs() (ids []string) {
	for id := range m.hustler_clothes {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerClothes resets all changes to the "hustler_clothes" edge.
func (m *ItemMutation) ResetHustlerClothes() {
	m.hustler_clothes = nil
	m.clearedhustler_clothes = false
	m.removedhustler_clothes = nil
}

// AddHustlerVehicleIDs adds the "hustler_vehicles" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerVehicleIDs(ids ...string) {
	if m.hustler_vehicles == nil {
		m.hustler_vehicles = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_vehicles[ids[i]] = struct{}{}
	}
}

// ClearHustlerVehicles clears the "hustler_vehicles" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerVehicles() {
	m.clearedhustler_vehicles = true
}

// HustlerVehiclesCleared reports if the "hustler_vehicles" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerVehiclesCleared() bool {
	return m.clearedhustler_vehicles
}

// RemoveHustlerVehicleIDs removes the "hustler_vehicles" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerVehicleIDs(ids ...string) {
	if m.removedhustler_vehicles == nil {
		m.removedhustler_vehicles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_vehicles, ids[i])
		m.removedhustler_vehicles[ids[i]] = struct{}{}
	}
}

// RemovedHustlerVehicles returns the removed IDs of the "hustler_vehicles" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerVehiclesIDs() (ids []string) {
	for id := range m.removedhustler_vehicles {
		ids = append(ids, id)
	}
	return
}

// HustlerVehiclesIDs returns the "hustler_vehicles" edge IDs in the mutation.
func (m *ItemMutation) HustlerVehiclesIDs() (ids []string) {
	for id := range m.hustler_vehicles {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerVehicles resets all changes to the "hustler_vehicles" edge.
func (m *ItemMutation) ResetHustlerVehicles() {
	m.hustler_vehicles = nil
	m.clearedhustler_vehicles = false
	m.removedhustler_vehicles = nil
}

// AddHustlerWaistIDs adds the "hustler_waists" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerWaistIDs(ids ...string) {
	if m.hustler_waists == nil {
		m.hustler_waists = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_waists[ids[i]] = struct{}{}
	}
}

// ClearHustlerWaists clears the "hustler_waists" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerWaists() {
	m.clearedhustler_waists = true
}

// HustlerWaistsCleared reports if the "hustler_waists" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerWaistsCleared() bool {
	return m.clearedhustler_waists
}

// RemoveHustlerWaistIDs removes the "hustler_waists" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerWaistIDs(ids ...string) {
	if m.removedhustler_waists == nil {
		m.removedhustler_waists = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_waists, ids[i])
		m.removedhustler_waists[ids[i]] = struct{}{}
	}
}

// RemovedHustlerWaists returns the removed IDs of the "hustler_waists" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerWaistsIDs() (ids []string) {
	for id := range m.removedhustler_waists {
		ids = append(ids, id)
	}
	return
}

// HustlerWaistsIDs returns the "hustler_waists" edge IDs in the mutation.
func (m *ItemMutation) HustlerWaistsIDs() (ids []string) {
	for id := range m.hustler_waists {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerWaists resets all changes to the "hustler_waists" edge.
func (m *ItemMutation) ResetHustlerWaists() {
	m.hustler_waists = nil
	m.clearedhustler_waists = false
	m.removedhustler_waists = nil
}

// AddHustlerFeetIDs adds the "hustler_feet" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerFeetIDs(ids ...string) {
	if m.hustler_feet == nil {
		m.hustler_feet = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_feet[ids[i]] = struct{}{}
	}
}

// ClearHustlerFeet clears the "hustler_feet" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerFeet() {
	m.clearedhustler_feet = true
}

// HustlerFeetCleared reports if the "hustler_feet" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerFeetCleared() bool {
	return m.clearedhustler_feet
}

// RemoveHustlerFeetIDs removes the "hustler_feet" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerFeetIDs(ids ...string) {
	if m.removedhustler_feet == nil {
		m.removedhustler_feet = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_feet, ids[i])
		m.removedhustler_feet[ids[i]] = struct{}{}
	}
}

// RemovedHustlerFeet returns the removed IDs of the "hustler_feet" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerFeetIDs() (ids []string) {
	for id := range m.removedhustler_feet {
		ids = append(ids, id)
	}
	return
}

// HustlerFeetIDs returns the "hustler_feet" edge IDs in the mutation.
func (m *ItemMutation) HustlerFeetIDs() (ids []string) {
	for id := range m.hustler_feet {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerFeet resets all changes to the "hustler_feet" edge.
func (m *ItemMutation) ResetHustlerFeet() {
	m.hustler_feet = nil
	m.clearedhustler_feet = false
	m.removedhustler_feet = nil
}

// AddHustlerHandIDs adds the "hustler_hands" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerHandIDs(ids ...string) {
	if m.hustler_hands == nil {
		m.hustler_hands = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_hands[ids[i]] = struct{}{}
	}
}

// ClearHustlerHands clears the "hustler_hands" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerHands() {
	m.clearedhustler_hands = true
}

// HustlerHandsCleared reports if the "hustler_hands" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerHandsCleared() bool {
	return m.clearedhustler_hands
}

// RemoveHustlerHandIDs removes the "hustler_hands" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerHandIDs(ids ...string) {
	if m.removedhustler_hands == nil {
		m.removedhustler_hands = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_hands, ids[i])
		m.removedhustler_hands[ids[i]] = struct{}{}
	}
}

// RemovedHustlerHands returns the removed IDs of the "hustler_hands" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerHandsIDs() (ids []string) {
	for id := range m.removedhustler_hands {
		ids = append(ids, id)
	}
	return
}

// HustlerHandsIDs returns the "hustler_hands" edge IDs in the mutation.
func (m *ItemMutation) HustlerHandsIDs() (ids []string) {
	for id := range m.hustler_hands {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerHands resets all changes to the "hustler_hands" edge.
func (m *ItemMutation) ResetHustlerHands() {
	m.hustler_hands = nil
	m.clearedhustler_hands = false
	m.removedhustler_hands = nil
}

// AddHustlerDrugIDs adds the "hustler_drugs" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerDrugIDs(ids ...string) {
	if m.hustler_drugs == nil {
		m.hustler_drugs = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_drugs[ids[i]] = struct{}{}
	}
}

// ClearHustlerDrugs clears the "hustler_drugs" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerDrugs() {
	m.clearedhustler_drugs = true
}

// HustlerDrugsCleared reports if the "hustler_drugs" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerDrugsCleared() bool {
	return m.clearedhustler_drugs
}

// RemoveHustlerDrugIDs removes the "hustler_drugs" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerDrugIDs(ids ...string) {
	if m.removedhustler_drugs == nil {
		m.removedhustler_drugs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_drugs, ids[i])
		m.removedhustler_drugs[ids[i]] = struct{}{}
	}
}

// RemovedHustlerDrugs returns the removed IDs of the "hustler_drugs" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerDrugsIDs() (ids []string) {
	for id := range m.removedhustler_drugs {
		ids = append(ids, id)
	}
	return
}

// HustlerDrugsIDs returns the "hustler_drugs" edge IDs in the mutation.
func (m *ItemMutation) HustlerDrugsIDs() (ids []string) {
	for id := range m.hustler_drugs {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerDrugs resets all changes to the "hustler_drugs" edge.
func (m *ItemMutation) ResetHustlerDrugs() {
	m.hustler_drugs = nil
	m.clearedhustler_drugs = false
	m.removedhustler_drugs = nil
}

// AddHustlerNeckIDs adds the "hustler_necks" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerNeckIDs(ids ...string) {
	if m.hustler_necks == nil {
		m.hustler_necks = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_necks[ids[i]] = struct{}{}
	}
}

// ClearHustlerNecks clears the "hustler_necks" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerNecks() {
	m.clearedhustler_necks = true
}

// HustlerNecksCleared reports if the "hustler_necks" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerNecksCleared() bool {
	return m.clearedhustler_necks
}

// RemoveHustlerNeckIDs removes the "hustler_necks" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerNeckIDs(ids ...string) {
	if m.removedhustler_necks == nil {
		m.removedhustler_necks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_necks, ids[i])
		m.removedhustler_necks[ids[i]] = struct{}{}
	}
}

// RemovedHustlerNecks returns the removed IDs of the "hustler_necks" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerNecksIDs() (ids []string) {
	for id := range m.removedhustler_necks {
		ids = append(ids, id)
	}
	return
}

// HustlerNecksIDs returns the "hustler_necks" edge IDs in the mutation.
func (m *ItemMutation) HustlerNecksIDs() (ids []string) {
	for id := range m.hustler_necks {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerNecks resets all changes to the "hustler_necks" edge.
func (m *ItemMutation) ResetHustlerNecks() {
	m.hustler_necks = nil
	m.clearedhustler_necks = false
	m.removedhustler_necks = nil
}

// AddHustlerRingIDs adds the "hustler_rings" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerRingIDs(ids ...string) {
	if m.hustler_rings == nil {
		m.hustler_rings = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_rings[ids[i]] = struct{}{}
	}
}

// ClearHustlerRings clears the "hustler_rings" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerRings() {
	m.clearedhustler_rings = true
}

// HustlerRingsCleared reports if the "hustler_rings" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerRingsCleared() bool {
	return m.clearedhustler_rings
}

// RemoveHustlerRingIDs removes the "hustler_rings" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerRingIDs(ids ...string) {
	if m.removedhustler_rings == nil {
		m.removedhustler_rings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_rings, ids[i])
		m.removedhustler_rings[ids[i]] = struct{}{}
	}
}

// RemovedHustlerRings returns the removed IDs of the "hustler_rings" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerRingsIDs() (ids []string) {
	for id := range m.removedhustler_rings {
		ids = append(ids, id)
	}
	return
}

// HustlerRingsIDs returns the "hustler_rings" edge IDs in the mutation.
func (m *ItemMutation) HustlerRingsIDs() (ids []string) {
	for id := range m.hustler_rings {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerRings resets all changes to the "hustler_rings" edge.
func (m *ItemMutation) ResetHustlerRings() {
	m.hustler_rings = nil
	m.clearedhustler_rings = false
	m.removedhustler_rings = nil
}

// AddHustlerAccessoryIDs adds the "hustler_accessories" edge to the Hustler entity by ids.
func (m *ItemMutation) AddHustlerAccessoryIDs(ids ...string) {
	if m.hustler_accessories == nil {
		m.hustler_accessories = make(map[string]struct{})
	}
	for i := range ids {
		m.hustler_accessories[ids[i]] = struct{}{}
	}
}

// ClearHustlerAccessories clears the "hustler_accessories" edge to the Hustler entity.
func (m *ItemMutation) ClearHustlerAccessories() {
	m.clearedhustler_accessories = true
}

// HustlerAccessoriesCleared reports if the "hustler_accessories" edge to the Hustler entity was cleared.
func (m *ItemMutation) HustlerAccessoriesCleared() bool {
	return m.clearedhustler_accessories
}

// RemoveHustlerAccessoryIDs removes the "hustler_accessories" edge to the Hustler entity by IDs.
func (m *ItemMutation) RemoveHustlerAccessoryIDs(ids ...string) {
	if m.removedhustler_accessories == nil {
		m.removedhustler_accessories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustler_accessories, ids[i])
		m.removedhustler_accessories[ids[i]] = struct{}{}
	}
}

// RemovedHustlerAccessories returns the removed IDs of the "hustler_accessories" edge to the Hustler entity.
func (m *ItemMutation) RemovedHustlerAccessoriesIDs() (ids []string) {
	for id := range m.removedhustler_accessories {
		ids = append(ids, id)
	}
	return
}

// HustlerAccessoriesIDs returns the "hustler_accessories" edge IDs in the mutation.
func (m *ItemMutation) HustlerAccessoriesIDs() (ids []string) {
	for id := range m.hustler_accessories {
		ids = append(ids, id)
	}
	return
}

// ResetHustlerAccessories resets all changes to the "hustler_accessories" edge.
func (m *ItemMutation) ResetHustlerAccessories() {
	m.hustler_accessories = nil
	m.clearedhustler_accessories = false
	m.removedhustler_accessories = nil
}

// SetBaseID sets the "base" edge to the Item entity by id.
func (m *ItemMutation) SetBaseID(id string) {
	m.base = &id
}

// ClearBase clears the "base" edge to the Item entity.
func (m *ItemMutation) ClearBase() {
	m.clearedbase = true
}

// BaseCleared reports if the "base" edge to the Item entity was cleared.
func (m *ItemMutation) BaseCleared() bool {
	return m.clearedbase
}

// BaseID returns the "base" edge ID in the mutation.
func (m *ItemMutation) BaseID() (id string, exists bool) {
	if m.base != nil {
		return *m.base, true
	}
	return
}

// BaseIDs returns the "base" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BaseID instead. It exists only for internal usage by the builders.
func (m *ItemMutation) BaseIDs() (ids []string) {
	if id := m.base; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBase resets all changes to the "base" edge.
func (m *ItemMutation) ResetBase() {
	m.base = nil
	m.clearedbase = false
}

// AddDerivativeIDs adds the "derivative" edge to the Item entity by ids.
func (m *ItemMutation) AddDerivativeIDs(ids ...string) {
	if m.derivative == nil {
		m.derivative = make(map[string]struct{})
	}
	for i := range ids {
		m.derivative[ids[i]] = struct{}{}
	}
}

// ClearDerivative clears the "derivative" edge to the Item entity.
func (m *ItemMutation) ClearDerivative() {
	m.clearedderivative = true
}

// DerivativeCleared reports if the "derivative" edge to the Item entity was cleared.
func (m *ItemMutation) DerivativeCleared() bool {
	return m.clearedderivative
}

// RemoveDerivativeIDs removes the "derivative" edge to the Item entity by IDs.
func (m *ItemMutation) RemoveDerivativeIDs(ids ...string) {
	if m.removedderivative == nil {
		m.removedderivative = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.derivative, ids[i])
		m.removedderivative[ids[i]] = struct{}{}
	}
}

// RemovedDerivative returns the removed IDs of the "derivative" edge to the Item entity.
func (m *ItemMutation) RemovedDerivativeIDs() (ids []string) {
	for id := range m.removedderivative {
		ids = append(ids, id)
	}
	return
}

// DerivativeIDs returns the "derivative" edge IDs in the mutation.
func (m *ItemMutation) DerivativeIDs() (ids []string) {
	for id := range m.derivative {
		ids = append(ids, id)
	}
	return
}

// ResetDerivative resets all changes to the "derivative" edge.
func (m *ItemMutation) ResetDerivative() {
	m.derivative = nil
	m.clearedderivative = false
	m.removedderivative = nil
}

// SetIndexID sets the "index" edge to the Search entity by id.
func (m *ItemMutation) SetIndexID(id string) {
	m.index = &id
}

// ClearIndex clears the "index" edge to the Search entity.
func (m *ItemMutation) ClearIndex() {
	m.clearedindex = true
}

// IndexCleared reports if the "index" edge to the Search entity was cleared.
func (m *ItemMutation) IndexCleared() bool {
	return m.clearedindex
}

// IndexID returns the "index" edge ID in the mutation.
func (m *ItemMutation) IndexID() (id string, exists bool) {
	if m.index != nil {
		return *m.index, true
	}
	return
}

// IndexIDs returns the "index" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IndexID instead. It exists only for internal usage by the builders.
func (m *ItemMutation) IndexIDs() (ids []string) {
	if id := m.index; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIndex resets all changes to the "index" edge.
func (m *ItemMutation) ResetIndex() {
	m.index = nil
	m.clearedindex = false
}

// Where appends a list predicates to the ItemMutation builder.
func (m *ItemMutation) Where(ps ...predicate.Item) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Item).
func (m *ItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ItemMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m._type != nil {
		fields = append(fields, item.FieldType)
	}
	if m.name_prefix != nil {
		fields = append(fields, item.FieldNamePrefix)
	}
	if m.name_suffix != nil {
		fields = append(fields, item.FieldNameSuffix)
	}
	if m.name != nil {
		fields = append(fields, item.FieldName)
	}
	if m.suffix != nil {
		fields = append(fields, item.FieldSuffix)
	}
	if m.augmented != nil {
		fields = append(fields, item.FieldAugmented)
	}
	if m.count != nil {
		fields = append(fields, item.FieldCount)
	}
	if m.tier != nil {
		fields = append(fields, item.FieldTier)
	}
	if m.greatness != nil {
		fields = append(fields, item.FieldGreatness)
	}
	if m.rles != nil {
		fields = append(fields, item.FieldRles)
	}
	if m.svg != nil {
		fields = append(fields, item.FieldSvg)
	}
	if m.sprite != nil {
		fields = append(fields, item.FieldSprite)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case item.FieldType:
		return m.GetType()
	case item.FieldNamePrefix:
		return m.NamePrefix()
	case item.FieldNameSuffix:
		return m.NameSuffix()
	case item.FieldName:
		return m.Name()
	case item.FieldSuffix:
		return m.Suffix()
	case item.FieldAugmented:
		return m.Augmented()
	case item.FieldCount:
		return m.Count()
	case item.FieldTier:
		return m.Tier()
	case item.FieldGreatness:
		return m.Greatness()
	case item.FieldRles:
		return m.Rles()
	case item.FieldSvg:
		return m.Svg()
	case item.FieldSprite:
		return m.Sprite()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case item.FieldType:
		return m.OldType(ctx)
	case item.FieldNamePrefix:
		return m.OldNamePrefix(ctx)
	case item.FieldNameSuffix:
		return m.OldNameSuffix(ctx)
	case item.FieldName:
		return m.OldName(ctx)
	case item.FieldSuffix:
		return m.OldSuffix(ctx)
	case item.FieldAugmented:
		return m.OldAugmented(ctx)
	case item.FieldCount:
		return m.OldCount(ctx)
	case item.FieldTier:
		return m.OldTier(ctx)
	case item.FieldGreatness:
		return m.OldGreatness(ctx)
	case item.FieldRles:
		return m.OldRles(ctx)
	case item.FieldSvg:
		return m.OldSvg(ctx)
	case item.FieldSprite:
		return m.OldSprite(ctx)
	}
	return nil, fmt.Errorf("unknown Item field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case item.FieldType:
		v, ok := value.(item.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case item.FieldNamePrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamePrefix(v)
		return nil
	case item.FieldNameSuffix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameSuffix(v)
		return nil
	case item.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case item.FieldSuffix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuffix(v)
		return nil
	case item.FieldAugmented:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAugmented(v)
		return nil
	case item.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case item.FieldTier:
		v, ok := value.(item.Tier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTier(v)
		return nil
	case item.FieldGreatness:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGreatness(v)
		return nil
	case item.FieldRles:
		v, ok := value.(schema.RLEs)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRles(v)
		return nil
	case item.FieldSvg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSvg(v)
		return nil
	case item.FieldSprite:
		v, ok := value.(schema.Sprites)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSprite(v)
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ItemMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, item.FieldCount)
	}
	if m.addgreatness != nil {
		fields = append(fields, item.FieldGreatness)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case item.FieldCount:
		return m.AddedCount()
	case item.FieldGreatness:
		return m.AddedGreatness()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case item.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case item.FieldGreatness:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGreatness(v)
		return nil
	}
	return fmt.Errorf("unknown Item numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(item.FieldNamePrefix) {
		fields = append(fields, item.FieldNamePrefix)
	}
	if m.FieldCleared(item.FieldNameSuffix) {
		fields = append(fields, item.FieldNameSuffix)
	}
	if m.FieldCleared(item.FieldSuffix) {
		fields = append(fields, item.FieldSuffix)
	}
	if m.FieldCleared(item.FieldAugmented) {
		fields = append(fields, item.FieldAugmented)
	}
	if m.FieldCleared(item.FieldCount) {
		fields = append(fields, item.FieldCount)
	}
	if m.FieldCleared(item.FieldTier) {
		fields = append(fields, item.FieldTier)
	}
	if m.FieldCleared(item.FieldGreatness) {
		fields = append(fields, item.FieldGreatness)
	}
	if m.FieldCleared(item.FieldRles) {
		fields = append(fields, item.FieldRles)
	}
	if m.FieldCleared(item.FieldSvg) {
		fields = append(fields, item.FieldSvg)
	}
	if m.FieldCleared(item.FieldSprite) {
		fields = append(fields, item.FieldSprite)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ItemMutation) ClearField(name string) error {
	switch name {
	case item.FieldNamePrefix:
		m.ClearNamePrefix()
		return nil
	case item.FieldNameSuffix:
		m.ClearNameSuffix()
		return nil
	case item.FieldSuffix:
		m.ClearSuffix()
		return nil
	case item.FieldAugmented:
		m.ClearAugmented()
		return nil
	case item.FieldCount:
		m.ClearCount()
		return nil
	case item.FieldTier:
		m.ClearTier()
		return nil
	case item.FieldGreatness:
		m.ClearGreatness()
		return nil
	case item.FieldRles:
		m.ClearRles()
		return nil
	case item.FieldSvg:
		m.ClearSvg()
		return nil
	case item.FieldSprite:
		m.ClearSprite()
		return nil
	}
	return fmt.Errorf("unknown Item nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ItemMutation) ResetField(name string) error {
	switch name {
	case item.FieldType:
		m.ResetType()
		return nil
	case item.FieldNamePrefix:
		m.ResetNamePrefix()
		return nil
	case item.FieldNameSuffix:
		m.ResetNameSuffix()
		return nil
	case item.FieldName:
		m.ResetName()
		return nil
	case item.FieldSuffix:
		m.ResetSuffix()
		return nil
	case item.FieldAugmented:
		m.ResetAugmented()
		return nil
	case item.FieldCount:
		m.ResetCount()
		return nil
	case item.FieldTier:
		m.ResetTier()
		return nil
	case item.FieldGreatness:
		m.ResetGreatness()
		return nil
	case item.FieldRles:
		m.ResetRles()
		return nil
	case item.FieldSvg:
		m.ResetSvg()
		return nil
	case item.FieldSprite:
		m.ResetSprite()
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.wallets != nil {
		edges = append(edges, item.EdgeWallets)
	}
	if m.dopes != nil {
		edges = append(edges, item.EdgeDopes)
	}
	if m.hustler_weapons != nil {
		edges = append(edges, item.EdgeHustlerWeapons)
	}
	if m.hustler_clothes != nil {
		edges = append(edges, item.EdgeHustlerClothes)
	}
	if m.hustler_vehicles != nil {
		edges = append(edges, item.EdgeHustlerVehicles)
	}
	if m.hustler_waists != nil {
		edges = append(edges, item.EdgeHustlerWaists)
	}
	if m.hustler_feet != nil {
		edges = append(edges, item.EdgeHustlerFeet)
	}
	if m.hustler_hands != nil {
		edges = append(edges, item.EdgeHustlerHands)
	}
	if m.hustler_drugs != nil {
		edges = append(edges, item.EdgeHustlerDrugs)
	}
	if m.hustler_necks != nil {
		edges = append(edges, item.EdgeHustlerNecks)
	}
	if m.hustler_rings != nil {
		edges = append(edges, item.EdgeHustlerRings)
	}
	if m.hustler_accessories != nil {
		edges = append(edges, item.EdgeHustlerAccessories)
	}
	if m.base != nil {
		edges = append(edges, item.EdgeBase)
	}
	if m.derivative != nil {
		edges = append(edges, item.EdgeDerivative)
	}
	if m.index != nil {
		edges = append(edges, item.EdgeIndex)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeWallets:
		ids := make([]ent.Value, 0, len(m.wallets))
		for id := range m.wallets {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeDopes:
		ids := make([]ent.Value, 0, len(m.dopes))
		for id := range m.dopes {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerWeapons:
		ids := make([]ent.Value, 0, len(m.hustler_weapons))
		for id := range m.hustler_weapons {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerClothes:
		ids := make([]ent.Value, 0, len(m.hustler_clothes))
		for id := range m.hustler_clothes {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerVehicles:
		ids := make([]ent.Value, 0, len(m.hustler_vehicles))
		for id := range m.hustler_vehicles {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerWaists:
		ids := make([]ent.Value, 0, len(m.hustler_waists))
		for id := range m.hustler_waists {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerFeet:
		ids := make([]ent.Value, 0, len(m.hustler_feet))
		for id := range m.hustler_feet {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerHands:
		ids := make([]ent.Value, 0, len(m.hustler_hands))
		for id := range m.hustler_hands {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerDrugs:
		ids := make([]ent.Value, 0, len(m.hustler_drugs))
		for id := range m.hustler_drugs {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerNecks:
		ids := make([]ent.Value, 0, len(m.hustler_necks))
		for id := range m.hustler_necks {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerRings:
		ids := make([]ent.Value, 0, len(m.hustler_rings))
		for id := range m.hustler_rings {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerAccessories:
		ids := make([]ent.Value, 0, len(m.hustler_accessories))
		for id := range m.hustler_accessories {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeBase:
		if id := m.base; id != nil {
			return []ent.Value{*id}
		}
	case item.EdgeDerivative:
		ids := make([]ent.Value, 0, len(m.derivative))
		for id := range m.derivative {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeIndex:
		if id := m.index; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removedwallets != nil {
		edges = append(edges, item.EdgeWallets)
	}
	if m.removeddopes != nil {
		edges = append(edges, item.EdgeDopes)
	}
	if m.removedhustler_weapons != nil {
		edges = append(edges, item.EdgeHustlerWeapons)
	}
	if m.removedhustler_clothes != nil {
		edges = append(edges, item.EdgeHustlerClothes)
	}
	if m.removedhustler_vehicles != nil {
		edges = append(edges, item.EdgeHustlerVehicles)
	}
	if m.removedhustler_waists != nil {
		edges = append(edges, item.EdgeHustlerWaists)
	}
	if m.removedhustler_feet != nil {
		edges = append(edges, item.EdgeHustlerFeet)
	}
	if m.removedhustler_hands != nil {
		edges = append(edges, item.EdgeHustlerHands)
	}
	if m.removedhustler_drugs != nil {
		edges = append(edges, item.EdgeHustlerDrugs)
	}
	if m.removedhustler_necks != nil {
		edges = append(edges, item.EdgeHustlerNecks)
	}
	if m.removedhustler_rings != nil {
		edges = append(edges, item.EdgeHustlerRings)
	}
	if m.removedhustler_accessories != nil {
		edges = append(edges, item.EdgeHustlerAccessories)
	}
	if m.removedderivative != nil {
		edges = append(edges, item.EdgeDerivative)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeWallets:
		ids := make([]ent.Value, 0, len(m.removedwallets))
		for id := range m.removedwallets {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeDopes:
		ids := make([]ent.Value, 0, len(m.removeddopes))
		for id := range m.removeddopes {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerWeapons:
		ids := make([]ent.Value, 0, len(m.removedhustler_weapons))
		for id := range m.removedhustler_weapons {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerClothes:
		ids := make([]ent.Value, 0, len(m.removedhustler_clothes))
		for id := range m.removedhustler_clothes {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerVehicles:
		ids := make([]ent.Value, 0, len(m.removedhustler_vehicles))
		for id := range m.removedhustler_vehicles {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerWaists:
		ids := make([]ent.Value, 0, len(m.removedhustler_waists))
		for id := range m.removedhustler_waists {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerFeet:
		ids := make([]ent.Value, 0, len(m.removedhustler_feet))
		for id := range m.removedhustler_feet {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerHands:
		ids := make([]ent.Value, 0, len(m.removedhustler_hands))
		for id := range m.removedhustler_hands {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerDrugs:
		ids := make([]ent.Value, 0, len(m.removedhustler_drugs))
		for id := range m.removedhustler_drugs {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerNecks:
		ids := make([]ent.Value, 0, len(m.removedhustler_necks))
		for id := range m.removedhustler_necks {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerRings:
		ids := make([]ent.Value, 0, len(m.removedhustler_rings))
		for id := range m.removedhustler_rings {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeHustlerAccessories:
		ids := make([]ent.Value, 0, len(m.removedhustler_accessories))
		for id := range m.removedhustler_accessories {
			ids = append(ids, id)
		}
		return ids
	case item.EdgeDerivative:
		ids := make([]ent.Value, 0, len(m.removedderivative))
		for id := range m.removedderivative {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedwallets {
		edges = append(edges, item.EdgeWallets)
	}
	if m.cleareddopes {
		edges = append(edges, item.EdgeDopes)
	}
	if m.clearedhustler_weapons {
		edges = append(edges, item.EdgeHustlerWeapons)
	}
	if m.clearedhustler_clothes {
		edges = append(edges, item.EdgeHustlerClothes)
	}
	if m.clearedhustler_vehicles {
		edges = append(edges, item.EdgeHustlerVehicles)
	}
	if m.clearedhustler_waists {
		edges = append(edges, item.EdgeHustlerWaists)
	}
	if m.clearedhustler_feet {
		edges = append(edges, item.EdgeHustlerFeet)
	}
	if m.clearedhustler_hands {
		edges = append(edges, item.EdgeHustlerHands)
	}
	if m.clearedhustler_drugs {
		edges = append(edges, item.EdgeHustlerDrugs)
	}
	if m.clearedhustler_necks {
		edges = append(edges, item.EdgeHustlerNecks)
	}
	if m.clearedhustler_rings {
		edges = append(edges, item.EdgeHustlerRings)
	}
	if m.clearedhustler_accessories {
		edges = append(edges, item.EdgeHustlerAccessories)
	}
	if m.clearedbase {
		edges = append(edges, item.EdgeBase)
	}
	if m.clearedderivative {
		edges = append(edges, item.EdgeDerivative)
	}
	if m.clearedindex {
		edges = append(edges, item.EdgeIndex)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ItemMutation) EdgeCleared(name string) bool {
	switch name {
	case item.EdgeWallets:
		return m.clearedwallets
	case item.EdgeDopes:
		return m.cleareddopes
	case item.EdgeHustlerWeapons:
		return m.clearedhustler_weapons
	case item.EdgeHustlerClothes:
		return m.clearedhustler_clothes
	case item.EdgeHustlerVehicles:
		return m.clearedhustler_vehicles
	case item.EdgeHustlerWaists:
		return m.clearedhustler_waists
	case item.EdgeHustlerFeet:
		return m.clearedhustler_feet
	case item.EdgeHustlerHands:
		return m.clearedhustler_hands
	case item.EdgeHustlerDrugs:
		return m.clearedhustler_drugs
	case item.EdgeHustlerNecks:
		return m.clearedhustler_necks
	case item.EdgeHustlerRings:
		return m.clearedhustler_rings
	case item.EdgeHustlerAccessories:
		return m.clearedhustler_accessories
	case item.EdgeBase:
		return m.clearedbase
	case item.EdgeDerivative:
		return m.clearedderivative
	case item.EdgeIndex:
		return m.clearedindex
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ItemMutation) ClearEdge(name string) error {
	switch name {
	case item.EdgeBase:
		m.ClearBase()
		return nil
	case item.EdgeIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown Item unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ItemMutation) ResetEdge(name string) error {
	switch name {
	case item.EdgeWallets:
		m.ResetWallets()
		return nil
	case item.EdgeDopes:
		m.ResetDopes()
		return nil
	case item.EdgeHustlerWeapons:
		m.ResetHustlerWeapons()
		return nil
	case item.EdgeHustlerClothes:
		m.ResetHustlerClothes()
		return nil
	case item.EdgeHustlerVehicles:
		m.ResetHustlerVehicles()
		return nil
	case item.EdgeHustlerWaists:
		m.ResetHustlerWaists()
		return nil
	case item.EdgeHustlerFeet:
		m.ResetHustlerFeet()
		return nil
	case item.EdgeHustlerHands:
		m.ResetHustlerHands()
		return nil
	case item.EdgeHustlerDrugs:
		m.ResetHustlerDrugs()
		return nil
	case item.EdgeHustlerNecks:
		m.ResetHustlerNecks()
		return nil
	case item.EdgeHustlerRings:
		m.ResetHustlerRings()
		return nil
	case item.EdgeHustlerAccessories:
		m.ResetHustlerAccessories()
		return nil
	case item.EdgeBase:
		m.ResetBase()
		return nil
	case item.EdgeDerivative:
		m.ResetDerivative()
		return nil
	case item.EdgeIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown Item edge %s", name)
}

// ListingMutation represents an operation that mutates the Listing nodes in the graph.
type ListingMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	active                *bool
	source                *listing.Source
	wyvern_order          *json.RawMessage
	seaport_order         *json.RawMessage
	clearedFields         map[string]struct{}
	dope                  *string
	cleareddope           bool
	dope_lastsales        *string
	cleareddope_lastsales bool
	inputs                map[string]struct{}
	removedinputs         map[string]struct{}
	clearedinputs         bool
	outputs               map[string]struct{}
	removedoutputs        map[string]struct{}
	clearedoutputs        bool
	done                  bool
	oldValue              func(context.Context) (*Listing, error)
	predicates            []predicate.Listing
}

var _ ent.Mutation = (*ListingMutation)(nil)

// listingOption allows management of the mutation configuration using functional options.
type listingOption func(*ListingMutation)

// newListingMutation creates new mutation for the Listing entity.
func newListingMutation(c config, op Op, opts ...listingOption) *ListingMutation {
	m := &ListingMutation{
		config:        c,
		op:            op,
		typ:           TypeListing,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withListingID sets the ID field of the mutation.
func withListingID(id string) listingOption {
	return func(m *ListingMutation) {
		var (
			err   error
			once  sync.Once
			value *Listing
		)
		m.oldValue = func(ctx context.Context) (*Listing, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Listing.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withListing sets the old Listing of the mutation.
func withListing(node *Listing) listingOption {
	return func(m *ListingMutation) {
		m.oldValue = func(context.Context) (*Listing, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ListingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ListingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Listing entities.
func (m *ListingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ListingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ListingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Listing.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActive sets the "active" field.
func (m *ListingMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *ListingMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Listing entity.
// If the Listing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListingMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *ListingMutation) ResetActive() {
	m.active = nil
}

// SetSource sets the "source" field.
func (m *ListingMutation) SetSource(l listing.Source) {
	m.source = &l
}

// Source returns the value of the "source" field in the mutation.
func (m *ListingMutation) Source() (r listing.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Listing entity.
// If the Listing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListingMutation) OldSource(ctx context.Context) (v listing.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ListingMutation) ResetSource() {
	m.source = nil
}

// SetWyvernOrder sets the "wyvern_order" field.
func (m *ListingMutation) SetWyvernOrder(jm json.RawMessage) {
	m.wyvern_order = &jm
}

// WyvernOrder returns the value of the "wyvern_order" field in the mutation.
func (m *ListingMutation) WyvernOrder() (r json.RawMessage, exists bool) {
	v := m.wyvern_order
	if v == nil {
		return
	}
	return *v, true
}

// OldWyvernOrder returns the old "wyvern_order" field's value of the Listing entity.
// If the Listing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListingMutation) OldWyvernOrder(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWyvernOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWyvernOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWyvernOrder: %w", err)
	}
	return oldValue.WyvernOrder, nil
}

// ClearWyvernOrder clears the value of the "wyvern_order" field.
func (m *ListingMutation) ClearWyvernOrder() {
	m.wyvern_order = nil
	m.clearedFields[listing.FieldWyvernOrder] = struct{}{}
}

// WyvernOrderCleared returns if the "wyvern_order" field was cleared in this mutation.
func (m *ListingMutation) WyvernOrderCleared() bool {
	_, ok := m.clearedFields[listing.FieldWyvernOrder]
	return ok
}

// ResetWyvernOrder resets all changes to the "wyvern_order" field.
func (m *ListingMutation) ResetWyvernOrder() {
	m.wyvern_order = nil
	delete(m.clearedFields, listing.FieldWyvernOrder)
}

// SetSeaportOrder sets the "seaport_order" field.
func (m *ListingMutation) SetSeaportOrder(jm json.RawMessage) {
	m.seaport_order = &jm
}

// SeaportOrder returns the value of the "seaport_order" field in the mutation.
func (m *ListingMutation) SeaportOrder() (r json.RawMessage, exists bool) {
	v := m.seaport_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSeaportOrder returns the old "seaport_order" field's value of the Listing entity.
// If the Listing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListingMutation) OldSeaportOrder(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeaportOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeaportOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeaportOrder: %w", err)
	}
	return oldValue.SeaportOrder, nil
}

// ClearSeaportOrder clears the value of the "seaport_order" field.
func (m *ListingMutation) ClearSeaportOrder() {
	m.seaport_order = nil
	m.clearedFields[listing.FieldSeaportOrder] = struct{}{}
}

// SeaportOrderCleared returns if the "seaport_order" field was cleared in this mutation.
func (m *ListingMutation) SeaportOrderCleared() bool {
	_, ok := m.clearedFields[listing.FieldSeaportOrder]
	return ok
}

// ResetSeaportOrder resets all changes to the "seaport_order" field.
func (m *ListingMutation) ResetSeaportOrder() {
	m.seaport_order = nil
	delete(m.clearedFields, listing.FieldSeaportOrder)
}

// SetDopeID sets the "dope" edge to the Dope entity by id.
func (m *ListingMutation) SetDopeID(id string) {
	m.dope = &id
}

// ClearDope clears the "dope" edge to the Dope entity.
func (m *ListingMutation) ClearDope() {
	m.cleareddope = true
}

// DopeCleared reports if the "dope" edge to the Dope entity was cleared.
func (m *ListingMutation) DopeCleared() bool {
	return m.cleareddope
}

// DopeID returns the "dope" edge ID in the mutation.
func (m *ListingMutation) DopeID() (id string, exists bool) {
	if m.dope != nil {
		return *m.dope, true
	}
	return
}

// DopeIDs returns the "dope" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DopeID instead. It exists only for internal usage by the builders.
func (m *ListingMutation) DopeIDs() (ids []string) {
	if id := m.dope; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDope resets all changes to the "dope" edge.
func (m *ListingMutation) ResetDope() {
	m.dope = nil
	m.cleareddope = false
}

// SetDopeLastsalesID sets the "dope_lastsales" edge to the Dope entity by id.
func (m *ListingMutation) SetDopeLastsalesID(id string) {
	m.dope_lastsales = &id
}

// ClearDopeLastsales clears the "dope_lastsales" edge to the Dope entity.
func (m *ListingMutation) ClearDopeLastsales() {
	m.cleareddope_lastsales = true
}

// DopeLastsalesCleared reports if the "dope_lastsales" edge to the Dope entity was cleared.
func (m *ListingMutation) DopeLastsalesCleared() bool {
	return m.cleareddope_lastsales
}

// DopeLastsalesID returns the "dope_lastsales" edge ID in the mutation.
func (m *ListingMutation) DopeLastsalesID() (id string, exists bool) {
	if m.dope_lastsales != nil {
		return *m.dope_lastsales, true
	}
	return
}

// DopeLastsalesIDs returns the "dope_lastsales" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DopeLastsalesID instead. It exists only for internal usage by the builders.
func (m *ListingMutation) DopeLastsalesIDs() (ids []string) {
	if id := m.dope_lastsales; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDopeLastsales resets all changes to the "dope_lastsales" edge.
func (m *ListingMutation) ResetDopeLastsales() {
	m.dope_lastsales = nil
	m.cleareddope_lastsales = false
}

// AddInputIDs adds the "inputs" edge to the Amount entity by ids.
func (m *ListingMutation) AddInputIDs(ids ...string) {
	if m.inputs == nil {
		m.inputs = make(map[string]struct{})
	}
	for i := range ids {
		m.inputs[ids[i]] = struct{}{}
	}
}

// ClearInputs clears the "inputs" edge to the Amount entity.
func (m *ListingMutation) ClearInputs() {
	m.clearedinputs = true
}

// InputsCleared reports if the "inputs" edge to the Amount entity was cleared.
func (m *ListingMutation) InputsCleared() bool {
	return m.clearedinputs
}

// RemoveInputIDs removes the "inputs" edge to the Amount entity by IDs.
func (m *ListingMutation) RemoveInputIDs(ids ...string) {
	if m.removedinputs == nil {
		m.removedinputs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.inputs, ids[i])
		m.removedinputs[ids[i]] = struct{}{}
	}
}

// RemovedInputs returns the removed IDs of the "inputs" edge to the Amount entity.
func (m *ListingMutation) RemovedInputsIDs() (ids []string) {
	for id := range m.removedinputs {
		ids = append(ids, id)
	}
	return
}

// InputsIDs returns the "inputs" edge IDs in the mutation.
func (m *ListingMutation) InputsIDs() (ids []string) {
	for id := range m.inputs {
		ids = append(ids, id)
	}
	return
}

// ResetInputs resets all changes to the "inputs" edge.
func (m *ListingMutation) ResetInputs() {
	m.inputs = nil
	m.clearedinputs = false
	m.removedinputs = nil
}

// AddOutputIDs adds the "outputs" edge to the Amount entity by ids.
func (m *ListingMutation) AddOutputIDs(ids ...string) {
	if m.outputs == nil {
		m.outputs = make(map[string]struct{})
	}
	for i := range ids {
		m.outputs[ids[i]] = struct{}{}
	}
}

// ClearOutputs clears the "outputs" edge to the Amount entity.
func (m *ListingMutation) ClearOutputs() {
	m.clearedoutputs = true
}

// OutputsCleared reports if the "outputs" edge to the Amount entity was cleared.
func (m *ListingMutation) OutputsCleared() bool {
	return m.clearedoutputs
}

// RemoveOutputIDs removes the "outputs" edge to the Amount entity by IDs.
func (m *ListingMutation) RemoveOutputIDs(ids ...string) {
	if m.removedoutputs == nil {
		m.removedoutputs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.outputs, ids[i])
		m.removedoutputs[ids[i]] = struct{}{}
	}
}

// RemovedOutputs returns the removed IDs of the "outputs" edge to the Amount entity.
func (m *ListingMutation) RemovedOutputsIDs() (ids []string) {
	for id := range m.removedoutputs {
		ids = append(ids, id)
	}
	return
}

// OutputsIDs returns the "outputs" edge IDs in the mutation.
func (m *ListingMutation) OutputsIDs() (ids []string) {
	for id := range m.outputs {
		ids = append(ids, id)
	}
	return
}

// ResetOutputs resets all changes to the "outputs" edge.
func (m *ListingMutation) ResetOutputs() {
	m.outputs = nil
	m.clearedoutputs = false
	m.removedoutputs = nil
}

// Where appends a list predicates to the ListingMutation builder.
func (m *ListingMutation) Where(ps ...predicate.Listing) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ListingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Listing).
func (m *ListingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ListingMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.active != nil {
		fields = append(fields, listing.FieldActive)
	}
	if m.source != nil {
		fields = append(fields, listing.FieldSource)
	}
	if m.wyvern_order != nil {
		fields = append(fields, listing.FieldWyvernOrder)
	}
	if m.seaport_order != nil {
		fields = append(fields, listing.FieldSeaportOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ListingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case listing.FieldActive:
		return m.Active()
	case listing.FieldSource:
		return m.Source()
	case listing.FieldWyvernOrder:
		return m.WyvernOrder()
	case listing.FieldSeaportOrder:
		return m.SeaportOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ListingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case listing.FieldActive:
		return m.OldActive(ctx)
	case listing.FieldSource:
		return m.OldSource(ctx)
	case listing.FieldWyvernOrder:
		return m.OldWyvernOrder(ctx)
	case listing.FieldSeaportOrder:
		return m.OldSeaportOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Listing field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ListingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case listing.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case listing.FieldSource:
		v, ok := value.(listing.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case listing.FieldWyvernOrder:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWyvernOrder(v)
		return nil
	case listing.FieldSeaportOrder:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeaportOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Listing field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ListingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ListingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ListingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Listing numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ListingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(listing.FieldWyvernOrder) {
		fields = append(fields, listing.FieldWyvernOrder)
	}
	if m.FieldCleared(listing.FieldSeaportOrder) {
		fields = append(fields, listing.FieldSeaportOrder)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ListingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ListingMutation) ClearField(name string) error {
	switch name {
	case listing.FieldWyvernOrder:
		m.ClearWyvernOrder()
		return nil
	case listing.FieldSeaportOrder:
		m.ClearSeaportOrder()
		return nil
	}
	return fmt.Errorf("unknown Listing nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ListingMutation) ResetField(name string) error {
	switch name {
	case listing.FieldActive:
		m.ResetActive()
		return nil
	case listing.FieldSource:
		m.ResetSource()
		return nil
	case listing.FieldWyvernOrder:
		m.ResetWyvernOrder()
		return nil
	case listing.FieldSeaportOrder:
		m.ResetSeaportOrder()
		return nil
	}
	return fmt.Errorf("unknown Listing field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ListingMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.dope != nil {
		edges = append(edges, listing.EdgeDope)
	}
	if m.dope_lastsales != nil {
		edges = append(edges, listing.EdgeDopeLastsales)
	}
	if m.inputs != nil {
		edges = append(edges, listing.EdgeInputs)
	}
	if m.outputs != nil {
		edges = append(edges, listing.EdgeOutputs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ListingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case listing.EdgeDope:
		if id := m.dope; id != nil {
			return []ent.Value{*id}
		}
	case listing.EdgeDopeLastsales:
		if id := m.dope_lastsales; id != nil {
			return []ent.Value{*id}
		}
	case listing.EdgeInputs:
		ids := make([]ent.Value, 0, len(m.inputs))
		for id := range m.inputs {
			ids = append(ids, id)
		}
		return ids
	case listing.EdgeOutputs:
		ids := make([]ent.Value, 0, len(m.outputs))
		for id := range m.outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ListingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedinputs != nil {
		edges = append(edges, listing.EdgeInputs)
	}
	if m.removedoutputs != nil {
		edges = append(edges, listing.EdgeOutputs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ListingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case listing.EdgeInputs:
		ids := make([]ent.Value, 0, len(m.removedinputs))
		for id := range m.removedinputs {
			ids = append(ids, id)
		}
		return ids
	case listing.EdgeOutputs:
		ids := make([]ent.Value, 0, len(m.removedoutputs))
		for id := range m.removedoutputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ListingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddope {
		edges = append(edges, listing.EdgeDope)
	}
	if m.cleareddope_lastsales {
		edges = append(edges, listing.EdgeDopeLastsales)
	}
	if m.clearedinputs {
		edges = append(edges, listing.EdgeInputs)
	}
	if m.clearedoutputs {
		edges = append(edges, listing.EdgeOutputs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ListingMutation) EdgeCleared(name string) bool {
	switch name {
	case listing.EdgeDope:
		return m.cleareddope
	case listing.EdgeDopeLastsales:
		return m.cleareddope_lastsales
	case listing.EdgeInputs:
		return m.clearedinputs
	case listing.EdgeOutputs:
		return m.clearedoutputs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ListingMutation) ClearEdge(name string) error {
	switch name {
	case listing.EdgeDope:
		m.ClearDope()
		return nil
	case listing.EdgeDopeLastsales:
		m.ClearDopeLastsales()
		return nil
	}
	return fmt.Errorf("unknown Listing unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ListingMutation) ResetEdge(name string) error {
	switch name {
	case listing.EdgeDope:
		m.ResetDope()
		return nil
	case listing.EdgeDopeLastsales:
		m.ResetDopeLastsales()
		return nil
	case listing.EdgeInputs:
		m.ResetInputs()
		return nil
	case listing.EdgeOutputs:
		m.ResetOutputs()
		return nil
	}
	return fmt.Errorf("unknown Listing edge %s", name)
}

// SearchMutation represents an operation that mutates the Search nodes in the graph.
type SearchMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	_type              *search.Type
	greatness          *int
	addgreatness       *int
	claimed            *bool
	opened             *bool
	sale_active        *bool
	sale_price         *schema.BigInt
	addsale_price      *schema.BigInt
	last_sale_price    *schema.BigInt
	addlast_sale_price *schema.BigInt
	clearedFields      map[string]struct{}
	dope               *string
	cleareddope        bool
	item               *string
	cleareditem        bool
	hustler            *string
	clearedhustler     bool
	done               bool
	oldValue           func(context.Context) (*Search, error)
	predicates         []predicate.Search
}

var _ ent.Mutation = (*SearchMutation)(nil)

// searchOption allows management of the mutation configuration using functional options.
type searchOption func(*SearchMutation)

// newSearchMutation creates new mutation for the Search entity.
func newSearchMutation(c config, op Op, opts ...searchOption) *SearchMutation {
	m := &SearchMutation{
		config:        c,
		op:            op,
		typ:           TypeSearch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSearchID sets the ID field of the mutation.
func withSearchID(id string) searchOption {
	return func(m *SearchMutation) {
		var (
			err   error
			once  sync.Once
			value *Search
		)
		m.oldValue = func(ctx context.Context) (*Search, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Search.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSearch sets the old Search of the mutation.
func withSearch(node *Search) searchOption {
	return func(m *SearchMutation) {
		m.oldValue = func(context.Context) (*Search, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SearchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SearchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Search entities.
func (m *SearchMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SearchMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SearchMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Search.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *SearchMutation) SetType(s search.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SearchMutation) GetType() (r search.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Search entity.
// If the Search object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchMutation) OldType(ctx context.Context) (v search.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SearchMutation) ResetType() {
	m._type = nil
}

// SetGreatness sets the "greatness" field.
func (m *SearchMutation) SetGreatness(i int) {
	m.greatness = &i
	m.addgreatness = nil
}

// Greatness returns the value of the "greatness" field in the mutation.
func (m *SearchMutation) Greatness() (r int, exists bool) {
	v := m.greatness
	if v == nil {
		return
	}
	return *v, true
}

// OldGreatness returns the old "greatness" field's value of the Search entity.
// If the Search object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchMutation) OldGreatness(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGreatness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGreatness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGreatness: %w", err)
	}
	return oldValue.Greatness, nil
}

// AddGreatness adds i to the "greatness" field.
func (m *SearchMutation) AddGreatness(i int) {
	if m.addgreatness != nil {
		*m.addgreatness += i
	} else {
		m.addgreatness = &i
	}
}

// AddedGreatness returns the value that was added to the "greatness" field in this mutation.
func (m *SearchMutation) AddedGreatness() (r int, exists bool) {
	v := m.addgreatness
	if v == nil {
		return
	}
	return *v, true
}

// ClearGreatness clears the value of the "greatness" field.
func (m *SearchMutation) ClearGreatness() {
	m.greatness = nil
	m.addgreatness = nil
	m.clearedFields[search.FieldGreatness] = struct{}{}
}

// GreatnessCleared returns if the "greatness" field was cleared in this mutation.
func (m *SearchMutation) GreatnessCleared() bool {
	_, ok := m.clearedFields[search.FieldGreatness]
	return ok
}

// ResetGreatness resets all changes to the "greatness" field.
func (m *SearchMutation) ResetGreatness() {
	m.greatness = nil
	m.addgreatness = nil
	delete(m.clearedFields, search.FieldGreatness)
}

// SetClaimed sets the "claimed" field.
func (m *SearchMutation) SetClaimed(b bool) {
	m.claimed = &b
}

// Claimed returns the value of the "claimed" field in the mutation.
func (m *SearchMutation) Claimed() (r bool, exists bool) {
	v := m.claimed
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimed returns the old "claimed" field's value of the Search entity.
// If the Search object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchMutation) OldClaimed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimed: %w", err)
	}
	return oldValue.Claimed, nil
}

// ResetClaimed resets all changes to the "claimed" field.
func (m *SearchMutation) ResetClaimed() {
	m.claimed = nil
}

// SetOpened sets the "opened" field.
func (m *SearchMutation) SetOpened(b bool) {
	m.opened = &b
}

// Opened returns the value of the "opened" field in the mutation.
func (m *SearchMutation) Opened() (r bool, exists bool) {
	v := m.opened
	if v == nil {
		return
	}
	return *v, true
}

// OldOpened returns the old "opened" field's value of the Search entity.
// If the Search object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchMutation) OldOpened(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpened is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpened requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpened: %w", err)
	}
	return oldValue.Opened, nil
}

// ResetOpened resets all changes to the "opened" field.
func (m *SearchMutation) ResetOpened() {
	m.opened = nil
}

// SetSaleActive sets the "sale_active" field.
func (m *SearchMutation) SetSaleActive(b bool) {
	m.sale_active = &b
}

// SaleActive returns the value of the "sale_active" field in the mutation.
func (m *SearchMutation) SaleActive() (r bool, exists bool) {
	v := m.sale_active
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleActive returns the old "sale_active" field's value of the Search entity.
// If the Search object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchMutation) OldSaleActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleActive: %w", err)
	}
	return oldValue.SaleActive, nil
}

// ResetSaleActive resets all changes to the "sale_active" field.
func (m *SearchMutation) ResetSaleActive() {
	m.sale_active = nil
}

// SetSalePrice sets the "sale_price" field.
func (m *SearchMutation) SetSalePrice(si schema.BigInt) {
	m.sale_price = &si
	m.addsale_price = nil
}

// SalePrice returns the value of the "sale_price" field in the mutation.
func (m *SearchMutation) SalePrice() (r schema.BigInt, exists bool) {
	v := m.sale_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSalePrice returns the old "sale_price" field's value of the Search entity.
// If the Search object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchMutation) OldSalePrice(ctx context.Context) (v schema.BigInt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalePrice: %w", err)
	}
	return oldValue.SalePrice, nil
}

// AddSalePrice adds si to the "sale_price" field.
func (m *SearchMutation) AddSalePrice(si schema.BigInt) {
	if m.addsale_price != nil {
		*m.addsale_price = m.addsale_price.Add(si)
	} else {
		m.addsale_price = &si
	}
}

// AddedSalePrice returns the value that was added to the "sale_price" field in this mutation.
func (m *SearchMutation) AddedSalePrice() (r schema.BigInt, exists bool) {
	v := m.addsale_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetSalePrice resets all changes to the "sale_price" field.
func (m *SearchMutation) ResetSalePrice() {
	m.sale_price = nil
	m.addsale_price = nil
}

// SetLastSalePrice sets the "last_sale_price" field.
func (m *SearchMutation) SetLastSalePrice(si schema.BigInt) {
	m.last_sale_price = &si
	m.addlast_sale_price = nil
}

// LastSalePrice returns the value of the "last_sale_price" field in the mutation.
func (m *SearchMutation) LastSalePrice() (r schema.BigInt, exists bool) {
	v := m.last_sale_price
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSalePrice returns the old "last_sale_price" field's value of the Search entity.
// If the Search object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchMutation) OldLastSalePrice(ctx context.Context) (v schema.BigInt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSalePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSalePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSalePrice: %w", err)
	}
	return oldValue.LastSalePrice, nil
}

// AddLastSalePrice adds si to the "last_sale_price" field.
func (m *SearchMutation) AddLastSalePrice(si schema.BigInt) {
	if m.addlast_sale_price != nil {
		*m.addlast_sale_price = m.addlast_sale_price.Add(si)
	} else {
		m.addlast_sale_price = &si
	}
}

// AddedLastSalePrice returns the value that was added to the "last_sale_price" field in this mutation.
func (m *SearchMutation) AddedLastSalePrice() (r schema.BigInt, exists bool) {
	v := m.addlast_sale_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastSalePrice resets all changes to the "last_sale_price" field.
func (m *SearchMutation) ResetLastSalePrice() {
	m.last_sale_price = nil
	m.addlast_sale_price = nil
}

// SetDopeID sets the "dope" edge to the Dope entity by id.
func (m *SearchMutation) SetDopeID(id string) {
	m.dope = &id
}

// ClearDope clears the "dope" edge to the Dope entity.
func (m *SearchMutation) ClearDope() {
	m.cleareddope = true
}

// DopeCleared reports if the "dope" edge to the Dope entity was cleared.
func (m *SearchMutation) DopeCleared() bool {
	return m.cleareddope
}

// DopeID returns the "dope" edge ID in the mutation.
func (m *SearchMutation) DopeID() (id string, exists bool) {
	if m.dope != nil {
		return *m.dope, true
	}
	return
}

// DopeIDs returns the "dope" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DopeID instead. It exists only for internal usage by the builders.
func (m *SearchMutation) DopeIDs() (ids []string) {
	if id := m.dope; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDope resets all changes to the "dope" edge.
func (m *SearchMutation) ResetDope() {
	m.dope = nil
	m.cleareddope = false
}

// SetItemID sets the "item" edge to the Item entity by id.
func (m *SearchMutation) SetItemID(id string) {
	m.item = &id
}

// ClearItem clears the "item" edge to the Item entity.
func (m *SearchMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the Item entity was cleared.
func (m *SearchMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemID returns the "item" edge ID in the mutation.
func (m *SearchMutation) ItemID() (id string, exists bool) {
	if m.item != nil {
		return *m.item, true
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *SearchMutation) ItemIDs() (ids []string) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *SearchMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// SetHustlerID sets the "hustler" edge to the Hustler entity by id.
func (m *SearchMutation) SetHustlerID(id string) {
	m.hustler = &id
}

// ClearHustler clears the "hustler" edge to the Hustler entity.
func (m *SearchMutation) ClearHustler() {
	m.clearedhustler = true
}

// HustlerCleared reports if the "hustler" edge to the Hustler entity was cleared.
func (m *SearchMutation) HustlerCleared() bool {
	return m.clearedhustler
}

// HustlerID returns the "hustler" edge ID in the mutation.
func (m *SearchMutation) HustlerID() (id string, exists bool) {
	if m.hustler != nil {
		return *m.hustler, true
	}
	return
}

// HustlerIDs returns the "hustler" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HustlerID instead. It exists only for internal usage by the builders.
func (m *SearchMutation) HustlerIDs() (ids []string) {
	if id := m.hustler; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHustler resets all changes to the "hustler" edge.
func (m *SearchMutation) ResetHustler() {
	m.hustler = nil
	m.clearedhustler = false
}

// Where appends a list predicates to the SearchMutation builder.
func (m *SearchMutation) Where(ps ...predicate.Search) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SearchMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Search).
func (m *SearchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SearchMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._type != nil {
		fields = append(fields, search.FieldType)
	}
	if m.greatness != nil {
		fields = append(fields, search.FieldGreatness)
	}
	if m.claimed != nil {
		fields = append(fields, search.FieldClaimed)
	}
	if m.opened != nil {
		fields = append(fields, search.FieldOpened)
	}
	if m.sale_active != nil {
		fields = append(fields, search.FieldSaleActive)
	}
	if m.sale_price != nil {
		fields = append(fields, search.FieldSalePrice)
	}
	if m.last_sale_price != nil {
		fields = append(fields, search.FieldLastSalePrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SearchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case search.FieldType:
		return m.GetType()
	case search.FieldGreatness:
		return m.Greatness()
	case search.FieldClaimed:
		return m.Claimed()
	case search.FieldOpened:
		return m.Opened()
	case search.FieldSaleActive:
		return m.SaleActive()
	case search.FieldSalePrice:
		return m.SalePrice()
	case search.FieldLastSalePrice:
		return m.LastSalePrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SearchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case search.FieldType:
		return m.OldType(ctx)
	case search.FieldGreatness:
		return m.OldGreatness(ctx)
	case search.FieldClaimed:
		return m.OldClaimed(ctx)
	case search.FieldOpened:
		return m.OldOpened(ctx)
	case search.FieldSaleActive:
		return m.OldSaleActive(ctx)
	case search.FieldSalePrice:
		return m.OldSalePrice(ctx)
	case search.FieldLastSalePrice:
		return m.OldLastSalePrice(ctx)
	}
	return nil, fmt.Errorf("unknown Search field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SearchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case search.FieldType:
		v, ok := value.(search.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case search.FieldGreatness:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGreatness(v)
		return nil
	case search.FieldClaimed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimed(v)
		return nil
	case search.FieldOpened:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpened(v)
		return nil
	case search.FieldSaleActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleActive(v)
		return nil
	case search.FieldSalePrice:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalePrice(v)
		return nil
	case search.FieldLastSalePrice:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSalePrice(v)
		return nil
	}
	return fmt.Errorf("unknown Search field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SearchMutation) AddedFields() []string {
	var fields []string
	if m.addgreatness != nil {
		fields = append(fields, search.FieldGreatness)
	}
	if m.addsale_price != nil {
		fields = append(fields, search.FieldSalePrice)
	}
	if m.addlast_sale_price != nil {
		fields = append(fields, search.FieldLastSalePrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SearchMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case search.FieldGreatness:
		return m.AddedGreatness()
	case search.FieldSalePrice:
		return m.AddedSalePrice()
	case search.FieldLastSalePrice:
		return m.AddedLastSalePrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SearchMutation) AddField(name string, value ent.Value) error {
	switch name {
	case search.FieldGreatness:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGreatness(v)
		return nil
	case search.FieldSalePrice:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalePrice(v)
		return nil
	case search.FieldLastSalePrice:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastSalePrice(v)
		return nil
	}
	return fmt.Errorf("unknown Search numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SearchMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(search.FieldGreatness) {
		fields = append(fields, search.FieldGreatness)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SearchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SearchMutation) ClearField(name string) error {
	switch name {
	case search.FieldGreatness:
		m.ClearGreatness()
		return nil
	}
	return fmt.Errorf("unknown Search nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SearchMutation) ResetField(name string) error {
	switch name {
	case search.FieldType:
		m.ResetType()
		return nil
	case search.FieldGreatness:
		m.ResetGreatness()
		return nil
	case search.FieldClaimed:
		m.ResetClaimed()
		return nil
	case search.FieldOpened:
		m.ResetOpened()
		return nil
	case search.FieldSaleActive:
		m.ResetSaleActive()
		return nil
	case search.FieldSalePrice:
		m.ResetSalePrice()
		return nil
	case search.FieldLastSalePrice:
		m.ResetLastSalePrice()
		return nil
	}
	return fmt.Errorf("unknown Search field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SearchMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.dope != nil {
		edges = append(edges, search.EdgeDope)
	}
	if m.item != nil {
		edges = append(edges, search.EdgeItem)
	}
	if m.hustler != nil {
		edges = append(edges, search.EdgeHustler)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SearchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case search.EdgeDope:
		if id := m.dope; id != nil {
			return []ent.Value{*id}
		}
	case search.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	case search.EdgeHustler:
		if id := m.hustler; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SearchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SearchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SearchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddope {
		edges = append(edges, search.EdgeDope)
	}
	if m.cleareditem {
		edges = append(edges, search.EdgeItem)
	}
	if m.clearedhustler {
		edges = append(edges, search.EdgeHustler)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SearchMutation) EdgeCleared(name string) bool {
	switch name {
	case search.EdgeDope:
		return m.cleareddope
	case search.EdgeItem:
		return m.cleareditem
	case search.EdgeHustler:
		return m.clearedhustler
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SearchMutation) ClearEdge(name string) error {
	switch name {
	case search.EdgeDope:
		m.ClearDope()
		return nil
	case search.EdgeItem:
		m.ClearItem()
		return nil
	case search.EdgeHustler:
		m.ClearHustler()
		return nil
	}
	return fmt.Errorf("unknown Search unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SearchMutation) ResetEdge(name string) error {
	switch name {
	case search.EdgeDope:
		m.ResetDope()
		return nil
	case search.EdgeItem:
		m.ResetItem()
		return nil
	case search.EdgeHustler:
		m.ResetHustler()
		return nil
	}
	return fmt.Errorf("unknown Search edge %s", name)
}

// SyncStateMutation represents an operation that mutates the SyncState nodes in the graph.
type SyncStateMutation struct {
	config
	op             Op
	typ            string
	id             *string
	start_block    *uint64
	addstart_block *int64
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*SyncState, error)
	predicates     []predicate.SyncState
}

var _ ent.Mutation = (*SyncStateMutation)(nil)

// syncstateOption allows management of the mutation configuration using functional options.
type syncstateOption func(*SyncStateMutation)

// newSyncStateMutation creates new mutation for the SyncState entity.
func newSyncStateMutation(c config, op Op, opts ...syncstateOption) *SyncStateMutation {
	m := &SyncStateMutation{
		config:        c,
		op:            op,
		typ:           TypeSyncState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSyncStateID sets the ID field of the mutation.
func withSyncStateID(id string) syncstateOption {
	return func(m *SyncStateMutation) {
		var (
			err   error
			once  sync.Once
			value *SyncState
		)
		m.oldValue = func(ctx context.Context) (*SyncState, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SyncState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSyncState sets the old SyncState of the mutation.
func withSyncState(node *SyncState) syncstateOption {
	return func(m *SyncStateMutation) {
		m.oldValue = func(context.Context) (*SyncState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SyncStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SyncStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SyncState entities.
func (m *SyncStateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SyncStateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SyncStateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SyncState.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartBlock sets the "start_block" field.
func (m *SyncStateMutation) SetStartBlock(u uint64) {
	m.start_block = &u
	m.addstart_block = nil
}

// StartBlock returns the value of the "start_block" field in the mutation.
func (m *SyncStateMutation) StartBlock() (r uint64, exists bool) {
	v := m.start_block
	if v == nil {
		return
	}
	return *v, true
}

// OldStartBlock returns the old "start_block" field's value of the SyncState entity.
// If the SyncState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncStateMutation) OldStartBlock(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartBlock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartBlock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartBlock: %w", err)
	}
	return oldValue.StartBlock, nil
}

// AddStartBlock adds u to the "start_block" field.
func (m *SyncStateMutation) AddStartBlock(u int64) {
	if m.addstart_block != nil {
		*m.addstart_block += u
	} else {
		m.addstart_block = &u
	}
}

// AddedStartBlock returns the value that was added to the "start_block" field in this mutation.
func (m *SyncStateMutation) AddedStartBlock() (r int64, exists bool) {
	v := m.addstart_block
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartBlock resets all changes to the "start_block" field.
func (m *SyncStateMutation) ResetStartBlock() {
	m.start_block = nil
	m.addstart_block = nil
}

// Where appends a list predicates to the SyncStateMutation builder.
func (m *SyncStateMutation) Where(ps ...predicate.SyncState) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SyncStateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SyncState).
func (m *SyncStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SyncStateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.start_block != nil {
		fields = append(fields, syncstate.FieldStartBlock)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SyncStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case syncstate.FieldStartBlock:
		return m.StartBlock()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SyncStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case syncstate.FieldStartBlock:
		return m.OldStartBlock(ctx)
	}
	return nil, fmt.Errorf("unknown SyncState field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case syncstate.FieldStartBlock:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartBlock(v)
		return nil
	}
	return fmt.Errorf("unknown SyncState field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SyncStateMutation) AddedFields() []string {
	var fields []string
	if m.addstart_block != nil {
		fields = append(fields, syncstate.FieldStartBlock)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SyncStateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case syncstate.FieldStartBlock:
		return m.AddedStartBlock()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case syncstate.FieldStartBlock:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartBlock(v)
		return nil
	}
	return fmt.Errorf("unknown SyncState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SyncStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SyncStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SyncStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SyncState nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SyncStateMutation) ResetField(name string) error {
	switch name {
	case syncstate.FieldStartBlock:
		m.ResetStartBlock()
		return nil
	}
	return fmt.Errorf("unknown SyncState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SyncStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SyncStateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SyncStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SyncStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SyncStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SyncStateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SyncStateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SyncState unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SyncStateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SyncState edge %s", name)
}

// WalletMutation represents an operation that mutates the Wallet nodes in the graph.
type WalletMutation struct {
	config
	op              Op
	typ             string
	id              *string
	paper           *schema.BigInt
	addpaper        *schema.BigInt
	created_at      *time.Time
	clearedFields   map[string]struct{}
	dopes           map[string]struct{}
	removeddopes    map[string]struct{}
	cleareddopes    bool
	items           map[string]struct{}
	removeditems    map[string]struct{}
	cleareditems    bool
	hustlers        map[string]struct{}
	removedhustlers map[string]struct{}
	clearedhustlers bool
	done            bool
	oldValue        func(context.Context) (*Wallet, error)
	predicates      []predicate.Wallet
}

var _ ent.Mutation = (*WalletMutation)(nil)

// walletOption allows management of the mutation configuration using functional options.
type walletOption func(*WalletMutation)

// newWalletMutation creates new mutation for the Wallet entity.
func newWalletMutation(c config, op Op, opts ...walletOption) *WalletMutation {
	m := &WalletMutation{
		config:        c,
		op:            op,
		typ:           TypeWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWalletID sets the ID field of the mutation.
func withWalletID(id string) walletOption {
	return func(m *WalletMutation) {
		var (
			err   error
			once  sync.Once
			value *Wallet
		)
		m.oldValue = func(ctx context.Context) (*Wallet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Wallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWallet sets the old Wallet of the mutation.
func withWallet(node *Wallet) walletOption {
	return func(m *WalletMutation) {
		m.oldValue = func(context.Context) (*Wallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Wallet entities.
func (m *WalletMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WalletMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WalletMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Wallet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPaper sets the "paper" field.
func (m *WalletMutation) SetPaper(si schema.BigInt) {
	m.paper = &si
	m.addpaper = nil
}

// Paper returns the value of the "paper" field in the mutation.
func (m *WalletMutation) Paper() (r schema.BigInt, exists bool) {
	v := m.paper
	if v == nil {
		return
	}
	return *v, true
}

// OldPaper returns the old "paper" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldPaper(ctx context.Context) (v schema.BigInt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaper: %w", err)
	}
	return oldValue.Paper, nil
}

// AddPaper adds si to the "paper" field.
func (m *WalletMutation) AddPaper(si schema.BigInt) {
	if m.addpaper != nil {
		*m.addpaper = m.addpaper.Add(si)
	} else {
		m.addpaper = &si
	}
}

// AddedPaper returns the value that was added to the "paper" field in this mutation.
func (m *WalletMutation) AddedPaper() (r schema.BigInt, exists bool) {
	v := m.addpaper
	if v == nil {
		return
	}
	return *v, true
}

// ResetPaper resets all changes to the "paper" field.
func (m *WalletMutation) ResetPaper() {
	m.paper = nil
	m.addpaper = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WalletMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WalletMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WalletMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddDopeIDs adds the "dopes" edge to the Dope entity by ids.
func (m *WalletMutation) AddDopeIDs(ids ...string) {
	if m.dopes == nil {
		m.dopes = make(map[string]struct{})
	}
	for i := range ids {
		m.dopes[ids[i]] = struct{}{}
	}
}

// ClearDopes clears the "dopes" edge to the Dope entity.
func (m *WalletMutation) ClearDopes() {
	m.cleareddopes = true
}

// DopesCleared reports if the "dopes" edge to the Dope entity was cleared.
func (m *WalletMutation) DopesCleared() bool {
	return m.cleareddopes
}

// RemoveDopeIDs removes the "dopes" edge to the Dope entity by IDs.
func (m *WalletMutation) RemoveDopeIDs(ids ...string) {
	if m.removeddopes == nil {
		m.removeddopes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dopes, ids[i])
		m.removeddopes[ids[i]] = struct{}{}
	}
}

// RemovedDopes returns the removed IDs of the "dopes" edge to the Dope entity.
func (m *WalletMutation) RemovedDopesIDs() (ids []string) {
	for id := range m.removeddopes {
		ids = append(ids, id)
	}
	return
}

// DopesIDs returns the "dopes" edge IDs in the mutation.
func (m *WalletMutation) DopesIDs() (ids []string) {
	for id := range m.dopes {
		ids = append(ids, id)
	}
	return
}

// ResetDopes resets all changes to the "dopes" edge.
func (m *WalletMutation) ResetDopes() {
	m.dopes = nil
	m.cleareddopes = false
	m.removeddopes = nil
}

// AddItemIDs adds the "items" edge to the WalletItems entity by ids.
func (m *WalletMutation) AddItemIDs(ids ...string) {
	if m.items == nil {
		m.items = make(map[string]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the WalletItems entity.
func (m *WalletMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the WalletItems entity was cleared.
func (m *WalletMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the WalletItems entity by IDs.
func (m *WalletMutation) RemoveItemIDs(ids ...string) {
	if m.removeditems == nil {
		m.removeditems = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the WalletItems entity.
func (m *WalletMutation) RemovedItemsIDs() (ids []string) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *WalletMutation) ItemsIDs() (ids []string) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *WalletMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddHustlerIDs adds the "hustlers" edge to the Hustler entity by ids.
func (m *WalletMutation) AddHustlerIDs(ids ...string) {
	if m.hustlers == nil {
		m.hustlers = make(map[string]struct{})
	}
	for i := range ids {
		m.hustlers[ids[i]] = struct{}{}
	}
}

// ClearHustlers clears the "hustlers" edge to the Hustler entity.
func (m *WalletMutation) ClearHustlers() {
	m.clearedhustlers = true
}

// HustlersCleared reports if the "hustlers" edge to the Hustler entity was cleared.
func (m *WalletMutation) HustlersCleared() bool {
	return m.clearedhustlers
}

// RemoveHustlerIDs removes the "hustlers" edge to the Hustler entity by IDs.
func (m *WalletMutation) RemoveHustlerIDs(ids ...string) {
	if m.removedhustlers == nil {
		m.removedhustlers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hustlers, ids[i])
		m.removedhustlers[ids[i]] = struct{}{}
	}
}

// RemovedHustlers returns the removed IDs of the "hustlers" edge to the Hustler entity.
func (m *WalletMutation) RemovedHustlersIDs() (ids []string) {
	for id := range m.removedhustlers {
		ids = append(ids, id)
	}
	return
}

// HustlersIDs returns the "hustlers" edge IDs in the mutation.
func (m *WalletMutation) HustlersIDs() (ids []string) {
	for id := range m.hustlers {
		ids = append(ids, id)
	}
	return
}

// ResetHustlers resets all changes to the "hustlers" edge.
func (m *WalletMutation) ResetHustlers() {
	m.hustlers = nil
	m.clearedhustlers = false
	m.removedhustlers = nil
}

// Where appends a list predicates to the WalletMutation builder.
func (m *WalletMutation) Where(ps ...predicate.Wallet) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WalletMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Wallet).
func (m *WalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WalletMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.paper != nil {
		fields = append(fields, wallet.FieldPaper)
	}
	if m.created_at != nil {
		fields = append(fields, wallet.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldPaper:
		return m.Paper()
	case wallet.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wallet.FieldPaper:
		return m.OldPaper(ctx)
	case wallet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Wallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldPaper:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaper(v)
		return nil
	case wallet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WalletMutation) AddedFields() []string {
	var fields []string
	if m.addpaper != nil {
		fields = append(fields, wallet.FieldPaper)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldPaper:
		return m.AddedPaper()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldPaper:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaper(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WalletMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WalletMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Wallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WalletMutation) ResetField(name string) error {
	switch name {
	case wallet.FieldPaper:
		m.ResetPaper()
		return nil
	case wallet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.dopes != nil {
		edges = append(edges, wallet.EdgeDopes)
	}
	if m.items != nil {
		edges = append(edges, wallet.EdgeItems)
	}
	if m.hustlers != nil {
		edges = append(edges, wallet.EdgeHustlers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WalletMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wallet.EdgeDopes:
		ids := make([]ent.Value, 0, len(m.dopes))
		for id := range m.dopes {
			ids = append(ids, id)
		}
		return ids
	case wallet.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case wallet.EdgeHustlers:
		ids := make([]ent.Value, 0, len(m.hustlers))
		for id := range m.hustlers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddopes != nil {
		edges = append(edges, wallet.EdgeDopes)
	}
	if m.removeditems != nil {
		edges = append(edges, wallet.EdgeItems)
	}
	if m.removedhustlers != nil {
		edges = append(edges, wallet.EdgeHustlers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WalletMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case wallet.EdgeDopes:
		ids := make([]ent.Value, 0, len(m.removeddopes))
		for id := range m.removeddopes {
			ids = append(ids, id)
		}
		return ids
	case wallet.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case wallet.EdgeHustlers:
		ids := make([]ent.Value, 0, len(m.removedhustlers))
		for id := range m.removedhustlers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddopes {
		edges = append(edges, wallet.EdgeDopes)
	}
	if m.cleareditems {
		edges = append(edges, wallet.EdgeItems)
	}
	if m.clearedhustlers {
		edges = append(edges, wallet.EdgeHustlers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WalletMutation) EdgeCleared(name string) bool {
	switch name {
	case wallet.EdgeDopes:
		return m.cleareddopes
	case wallet.EdgeItems:
		return m.cleareditems
	case wallet.EdgeHustlers:
		return m.clearedhustlers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WalletMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Wallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WalletMutation) ResetEdge(name string) error {
	switch name {
	case wallet.EdgeDopes:
		m.ResetDopes()
		return nil
	case wallet.EdgeItems:
		m.ResetItems()
		return nil
	case wallet.EdgeHustlers:
		m.ResetHustlers()
		return nil
	}
	return fmt.Errorf("unknown Wallet edge %s", name)
}

// WalletItemsMutation represents an operation that mutates the WalletItems nodes in the graph.
type WalletItemsMutation struct {
	config
	op            Op
	typ           string
	id            *string
	balance       *schema.BigInt
	addbalance    *schema.BigInt
	clearedFields map[string]struct{}
	wallet        *string
	clearedwallet bool
	item          *string
	cleareditem   bool
	done          bool
	oldValue      func(context.Context) (*WalletItems, error)
	predicates    []predicate.WalletItems
}

var _ ent.Mutation = (*WalletItemsMutation)(nil)

// walletitemsOption allows management of the mutation configuration using functional options.
type walletitemsOption func(*WalletItemsMutation)

// newWalletItemsMutation creates new mutation for the WalletItems entity.
func newWalletItemsMutation(c config, op Op, opts ...walletitemsOption) *WalletItemsMutation {
	m := &WalletItemsMutation{
		config:        c,
		op:            op,
		typ:           TypeWalletItems,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWalletItemsID sets the ID field of the mutation.
func withWalletItemsID(id string) walletitemsOption {
	return func(m *WalletItemsMutation) {
		var (
			err   error
			once  sync.Once
			value *WalletItems
		)
		m.oldValue = func(ctx context.Context) (*WalletItems, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WalletItems.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWalletItems sets the old WalletItems of the mutation.
func withWalletItems(node *WalletItems) walletitemsOption {
	return func(m *WalletItemsMutation) {
		m.oldValue = func(context.Context) (*WalletItems, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WalletItemsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WalletItemsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WalletItems entities.
func (m *WalletItemsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WalletItemsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WalletItemsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WalletItems.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBalance sets the "balance" field.
func (m *WalletItemsMutation) SetBalance(si schema.BigInt) {
	m.balance = &si
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *WalletItemsMutation) Balance() (r schema.BigInt, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the WalletItems entity.
// If the WalletItems object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletItemsMutation) OldBalance(ctx context.Context) (v schema.BigInt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds si to the "balance" field.
func (m *WalletItemsMutation) AddBalance(si schema.BigInt) {
	if m.addbalance != nil {
		*m.addbalance = m.addbalance.Add(si)
	} else {
		m.addbalance = &si
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *WalletItemsMutation) AddedBalance() (r schema.BigInt, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *WalletItemsMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetWalletID sets the "wallet" edge to the Wallet entity by id.
func (m *WalletItemsMutation) SetWalletID(id string) {
	m.wallet = &id
}

// ClearWallet clears the "wallet" edge to the Wallet entity.
func (m *WalletItemsMutation) ClearWallet() {
	m.clearedwallet = true
}

// WalletCleared reports if the "wallet" edge to the Wallet entity was cleared.
func (m *WalletItemsMutation) WalletCleared() bool {
	return m.clearedwallet
}

// WalletID returns the "wallet" edge ID in the mutation.
func (m *WalletItemsMutation) WalletID() (id string, exists bool) {
	if m.wallet != nil {
		return *m.wallet, true
	}
	return
}

// WalletIDs returns the "wallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WalletID instead. It exists only for internal usage by the builders.
func (m *WalletItemsMutation) WalletIDs() (ids []string) {
	if id := m.wallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWallet resets all changes to the "wallet" edge.
func (m *WalletItemsMutation) ResetWallet() {
	m.wallet = nil
	m.clearedwallet = false
}

// SetItemID sets the "item" edge to the Item entity by id.
func (m *WalletItemsMutation) SetItemID(id string) {
	m.item = &id
}

// ClearItem clears the "item" edge to the Item entity.
func (m *WalletItemsMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the Item entity was cleared.
func (m *WalletItemsMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemID returns the "item" edge ID in the mutation.
func (m *WalletItemsMutation) ItemID() (id string, exists bool) {
	if m.item != nil {
		return *m.item, true
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *WalletItemsMutation) ItemIDs() (ids []string) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *WalletItemsMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// Where appends a list predicates to the WalletItemsMutation builder.
func (m *WalletItemsMutation) Where(ps ...predicate.WalletItems) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WalletItemsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WalletItems).
func (m *WalletItemsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WalletItemsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.balance != nil {
		fields = append(fields, walletitems.FieldBalance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WalletItemsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case walletitems.FieldBalance:
		return m.Balance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WalletItemsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case walletitems.FieldBalance:
		return m.OldBalance(ctx)
	}
	return nil, fmt.Errorf("unknown WalletItems field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletItemsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case walletitems.FieldBalance:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	}
	return fmt.Errorf("unknown WalletItems field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WalletItemsMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, walletitems.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WalletItemsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case walletitems.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletItemsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case walletitems.FieldBalance:
		v, ok := value.(schema.BigInt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown WalletItems numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WalletItemsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WalletItemsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WalletItemsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WalletItems nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WalletItemsMutation) ResetField(name string) error {
	switch name {
	case walletitems.FieldBalance:
		m.ResetBalance()
		return nil
	}
	return fmt.Errorf("unknown WalletItems field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WalletItemsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.wallet != nil {
		edges = append(edges, walletitems.EdgeWallet)
	}
	if m.item != nil {
		edges = append(edges, walletitems.EdgeItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WalletItemsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case walletitems.EdgeWallet:
		if id := m.wallet; id != nil {
			return []ent.Value{*id}
		}
	case walletitems.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WalletItemsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WalletItemsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WalletItemsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedwallet {
		edges = append(edges, walletitems.EdgeWallet)
	}
	if m.cleareditem {
		edges = append(edges, walletitems.EdgeItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WalletItemsMutation) EdgeCleared(name string) bool {
	switch name {
	case walletitems.EdgeWallet:
		return m.clearedwallet
	case walletitems.EdgeItem:
		return m.cleareditem
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WalletItemsMutation) ClearEdge(name string) error {
	switch name {
	case walletitems.EdgeWallet:
		m.ClearWallet()
		return nil
	case walletitems.EdgeItem:
		m.ClearItem()
		return nil
	}
	return fmt.Errorf("unknown WalletItems unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WalletItemsMutation) ResetEdge(name string) error {
	switch name {
	case walletitems.EdgeWallet:
		m.ResetWallet()
		return nil
	case walletitems.EdgeItem:
		m.ResetItem()
		return nil
	}
	return fmt.Errorf("unknown WalletItems edge %s", name)
}
