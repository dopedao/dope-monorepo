// Code generated by github.com/withtally/synceth, DO NOT EDIT.

package bindings

import (
	"context"
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"

	"github.com/dopedao/dope-monorepo/packages/api/ent"
)

type HustlerProcessor interface {
	Setup(address common.Address, eth interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}) error
	Initialize(ctx context.Context, start uint64, tx *ent.Tx) error

	ProcessAddRles(ctx context.Context, e HustlerAddRles) (func(tx *ent.Tx) error, error)

	ProcessApprovalForAll(ctx context.Context, e HustlerApprovalForAll) (func(tx *ent.Tx) error, error)

	ProcessMetadataUpdate(ctx context.Context, e HustlerMetadataUpdate) (func(tx *ent.Tx) error, error)

	ProcessOwnershipTransferred(ctx context.Context, e HustlerOwnershipTransferred) (func(tx *ent.Tx) error, error)

	ProcessTransferBatch(ctx context.Context, e HustlerTransferBatch) (func(tx *ent.Tx) error, error)

	ProcessTransferSingle(ctx context.Context, e HustlerTransferSingle) (func(tx *ent.Tx) error, error)

	ProcessURI(ctx context.Context, e HustlerURI) (func(tx *ent.Tx) error, error)

	mustEmbedBaseHustlerProcessor()
}

type BaseHustlerProcessor struct {
	Address  common.Address
	ABI      abi.ABI
	Contract *Hustler
	Eth      interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}
}

func (h *BaseHustlerProcessor) Setup(address common.Address, eth interface {
	ethereum.ChainReader
	ethereum.ChainStateReader
	ethereum.TransactionReader
	bind.ContractBackend
}) error {
	contract, err := NewHustler(address, eth)
	if err != nil {
		return fmt.Errorf("new Hustler: %w", err)
	}

	abi, err := abi.JSON(strings.NewReader(string(HustlerABI)))
	if err != nil {
		return fmt.Errorf("parsing Hustler abi: %w", err)
	}

	h.Address = address
	h.ABI = abi
	h.Contract = contract
	h.Eth = eth
	return nil
}

func (h *BaseHustlerProcessor) ProcessElement(p interface{}) func(context.Context, types.Log) (func(*ent.Tx) error, error) {
	return func(ctx context.Context, vLog types.Log) (func(*ent.Tx) error, error) {
		switch vLog.Topics[0].Hex() {

		case h.ABI.Events["AddRles"].ID.Hex():
			e := HustlerAddRles{}
			if err := h.UnpackLog(&e, "AddRles", vLog); err != nil {
				return nil, fmt.Errorf("unpacking AddRles: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(HustlerProcessor).ProcessAddRles(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing AddRles: %w", err)
			}

			return cb, nil

		case h.ABI.Events["ApprovalForAll"].ID.Hex():
			e := HustlerApprovalForAll{}
			if err := h.UnpackLog(&e, "ApprovalForAll", vLog); err != nil {
				return nil, fmt.Errorf("unpacking ApprovalForAll: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(HustlerProcessor).ProcessApprovalForAll(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing ApprovalForAll: %w", err)
			}

			return cb, nil

		case h.ABI.Events["MetadataUpdate"].ID.Hex():
			e := HustlerMetadataUpdate{}
			if err := h.UnpackLog(&e, "MetadataUpdate", vLog); err != nil {
				return nil, fmt.Errorf("unpacking MetadataUpdate: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(HustlerProcessor).ProcessMetadataUpdate(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing MetadataUpdate: %w", err)
			}

			return cb, nil

		case h.ABI.Events["OwnershipTransferred"].ID.Hex():
			e := HustlerOwnershipTransferred{}
			if err := h.UnpackLog(&e, "OwnershipTransferred", vLog); err != nil {
				return nil, fmt.Errorf("unpacking OwnershipTransferred: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(HustlerProcessor).ProcessOwnershipTransferred(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing OwnershipTransferred: %w", err)
			}

			return cb, nil

		case h.ABI.Events["TransferBatch"].ID.Hex():
			e := HustlerTransferBatch{}
			if err := h.UnpackLog(&e, "TransferBatch", vLog); err != nil {
				return nil, fmt.Errorf("unpacking TransferBatch: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(HustlerProcessor).ProcessTransferBatch(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing TransferBatch: %w", err)
			}

			return cb, nil

		case h.ABI.Events["TransferSingle"].ID.Hex():
			e := HustlerTransferSingle{}
			if err := h.UnpackLog(&e, "TransferSingle", vLog); err != nil {
				return nil, fmt.Errorf("unpacking TransferSingle: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(HustlerProcessor).ProcessTransferSingle(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing TransferSingle: %w", err)
			}

			return cb, nil

		case h.ABI.Events["URI"].ID.Hex():
			e := HustlerURI{}
			if err := h.UnpackLog(&e, "URI", vLog); err != nil {
				return nil, fmt.Errorf("unpacking URI: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(HustlerProcessor).ProcessURI(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing URI: %w", err)
			}

			return cb, nil

		}
		return nil, nil
	}
}

func (h *BaseHustlerProcessor) UnpackLog(out interface{}, event string, log types.Log) error {
	if len(log.Data) > 0 {
		if err := h.ABI.UnpackIntoInterface(out, event, log.Data); err != nil {
			return err
		}
	}
	var indexed abi.Arguments
	for _, arg := range h.ABI.Events[event].Inputs {
		if arg.Indexed {
			indexed = append(indexed, arg)
		}
	}
	return abi.ParseTopics(out, indexed, log.Topics[1:])
}

func (h *BaseHustlerProcessor) Initialize(ctx context.Context, start uint64, tx *ent.Tx) error {
	return nil
}

func (h *BaseHustlerProcessor) ProcessAddRles(ctx context.Context, e HustlerAddRles) (func(tx *ent.Tx) error, error) {
	return nil, nil
}

func (h *BaseHustlerProcessor) ProcessApprovalForAll(ctx context.Context, e HustlerApprovalForAll) (func(tx *ent.Tx) error, error) {
	return nil, nil
}

func (h *BaseHustlerProcessor) ProcessMetadataUpdate(ctx context.Context, e HustlerMetadataUpdate) (func(tx *ent.Tx) error, error) {
	return nil, nil
}

func (h *BaseHustlerProcessor) ProcessOwnershipTransferred(ctx context.Context, e HustlerOwnershipTransferred) (func(tx *ent.Tx) error, error) {
	return nil, nil
}

func (h *BaseHustlerProcessor) ProcessTransferBatch(ctx context.Context, e HustlerTransferBatch) (func(tx *ent.Tx) error, error) {
	return nil, nil
}

func (h *BaseHustlerProcessor) ProcessTransferSingle(ctx context.Context, e HustlerTransferSingle) (func(tx *ent.Tx) error, error) {
	return nil, nil
}

func (h *BaseHustlerProcessor) ProcessURI(ctx context.Context, e HustlerURI) (func(tx *ent.Tx) error, error) {
	return nil, nil
}

func (h *BaseHustlerProcessor) mustEmbedBaseHustlerProcessor() {}
