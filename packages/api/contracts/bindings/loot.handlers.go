// Code generated by github.com/withtally/ethgen, DO NOT EDIT.

package bindings

import (
	"context"
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
)

type LootProcessor interface {
	Setup(address common.Address, eth interface {
		ethereum.ChainReader
		bind.ContractBackend
	}) error
	Initialize(ctx context.Context, start uint64, emit func(string, []interface{})) error

	ProcessApproval(ctx context.Context, e *LootApproval, emit func(string, []interface{})) error

	ProcessApprovalForAll(ctx context.Context, e *LootApprovalForAll, emit func(string, []interface{})) error

	ProcessDelegateChanged(ctx context.Context, e *LootDelegateChanged, emit func(string, []interface{})) error

	ProcessDelegateVotesChanged(ctx context.Context, e *LootDelegateVotesChanged, emit func(string, []interface{})) error

	ProcessOwnershipTransferred(ctx context.Context, e *LootOwnershipTransferred, emit func(string, []interface{})) error

	ProcessTransfer(ctx context.Context, e *LootTransfer, emit func(string, []interface{})) error

	mustEmbedUnimplementedLootProcessor()
}

type UnimplementedLootProcessor struct {
	Address  common.Address
	ABI      abi.ABI
	Contract *Loot
	Eth      interface {
		ethereum.ChainReader
		bind.ContractBackend
	}
}

func (h *UnimplementedLootProcessor) Setup(address common.Address, eth interface {
	ethereum.ChainReader
	bind.ContractBackend
}) error {
	contract, err := NewLoot(address, eth)
	if err != nil {
		return fmt.Errorf("new Loot: %w", err)
	}

	abi, err := abi.JSON(strings.NewReader(string(LootABI)))
	if err != nil {
		return fmt.Errorf("parsing Loot abi: %w", err)
	}

	h.Address = address
	h.ABI = abi
	h.Contract = contract
	h.Eth = eth
	return nil
}

func (h *UnimplementedLootProcessor) ProcessElement(p interface{}) func(context.Context, types.Log, func(string, []interface{})) error {
	return func(ctx context.Context, vLog types.Log, emit func(string, []interface{})) error {
		switch vLog.Topics[0].Hex() {

		case h.ABI.Events["Approval"].ID.Hex():
			e := new(LootApproval)
			if err := h.UnpackLog(e, "Approval", vLog); err != nil {
				return fmt.Errorf("unpacking Approval: %w", err)
			}

			e.Raw = vLog
			if err := p.(LootProcessor).ProcessApproval(ctx, e, emit); err != nil {
				return fmt.Errorf("processing Approval: %w", err)
			}

		case h.ABI.Events["ApprovalForAll"].ID.Hex():
			e := new(LootApprovalForAll)
			if err := h.UnpackLog(e, "ApprovalForAll", vLog); err != nil {
				return fmt.Errorf("unpacking ApprovalForAll: %w", err)
			}

			e.Raw = vLog
			if err := p.(LootProcessor).ProcessApprovalForAll(ctx, e, emit); err != nil {
				return fmt.Errorf("processing ApprovalForAll: %w", err)
			}

		case h.ABI.Events["DelegateChanged"].ID.Hex():
			e := new(LootDelegateChanged)
			if err := h.UnpackLog(e, "DelegateChanged", vLog); err != nil {
				return fmt.Errorf("unpacking DelegateChanged: %w", err)
			}

			e.Raw = vLog
			if err := p.(LootProcessor).ProcessDelegateChanged(ctx, e, emit); err != nil {
				return fmt.Errorf("processing DelegateChanged: %w", err)
			}

		case h.ABI.Events["DelegateVotesChanged"].ID.Hex():
			e := new(LootDelegateVotesChanged)
			if err := h.UnpackLog(e, "DelegateVotesChanged", vLog); err != nil {
				return fmt.Errorf("unpacking DelegateVotesChanged: %w", err)
			}

			e.Raw = vLog
			if err := p.(LootProcessor).ProcessDelegateVotesChanged(ctx, e, emit); err != nil {
				return fmt.Errorf("processing DelegateVotesChanged: %w", err)
			}

		case h.ABI.Events["OwnershipTransferred"].ID.Hex():
			e := new(LootOwnershipTransferred)
			if err := h.UnpackLog(e, "OwnershipTransferred", vLog); err != nil {
				return fmt.Errorf("unpacking OwnershipTransferred: %w", err)
			}

			e.Raw = vLog
			if err := p.(LootProcessor).ProcessOwnershipTransferred(ctx, e, emit); err != nil {
				return fmt.Errorf("processing OwnershipTransferred: %w", err)
			}

		case h.ABI.Events["Transfer"].ID.Hex():
			e := new(LootTransfer)
			if err := h.UnpackLog(e, "Transfer", vLog); err != nil {
				return fmt.Errorf("unpacking Transfer: %w", err)
			}

			e.Raw = vLog
			if err := p.(LootProcessor).ProcessTransfer(ctx, e, emit); err != nil {
				return fmt.Errorf("processing Transfer: %w", err)
			}

		}
		return nil
	}
}

func (h *UnimplementedLootProcessor) UnpackLog(out interface{}, event string, log types.Log) error {
	if len(log.Data) > 0 {
		if err := h.ABI.UnpackIntoInterface(out, event, log.Data); err != nil {
			return err
		}
	}
	var indexed abi.Arguments
	for _, arg := range h.ABI.Events[event].Inputs {
		if arg.Indexed {
			indexed = append(indexed, arg)
		}
	}
	return abi.ParseTopics(out, indexed, log.Topics[1:])
}

func (h *UnimplementedLootProcessor) Initialize(ctx context.Context, start uint64, emit func(string, []interface{})) error {
	return nil
}

func (h *UnimplementedLootProcessor) ProcessApproval(ctx context.Context, e *LootApproval, emit func(string, []interface{})) error {
	return nil
}

func (h *UnimplementedLootProcessor) ProcessApprovalForAll(ctx context.Context, e *LootApprovalForAll, emit func(string, []interface{})) error {
	return nil
}

func (h *UnimplementedLootProcessor) ProcessDelegateChanged(ctx context.Context, e *LootDelegateChanged, emit func(string, []interface{})) error {
	return nil
}

func (h *UnimplementedLootProcessor) ProcessDelegateVotesChanged(ctx context.Context, e *LootDelegateVotesChanged, emit func(string, []interface{})) error {
	return nil
}

func (h *UnimplementedLootProcessor) ProcessOwnershipTransferred(ctx context.Context, e *LootOwnershipTransferred, emit func(string, []interface{})) error {
	return nil
}

func (h *UnimplementedLootProcessor) ProcessTransfer(ctx context.Context, e *LootTransfer, emit func(string, []interface{})) error {
	return nil
}

func (h *UnimplementedLootProcessor) mustEmbedUnimplementedLootProcessor() {}
